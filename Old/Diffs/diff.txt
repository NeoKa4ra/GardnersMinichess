3c3,4
< # Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
> # Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
> # Copyright (C) 2015-2016 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
24c25,28
< UNAME = $(shell uname)
---
> KERNEL = $(shell uname -s)
> ifeq ($(KERNEL),Linux)
> 	OS = $(shell uname -o)
> endif
34c38
< PGOBENCH = ./$(EXE) bench 16 1 1 default time
---
> PGOBENCH = ./$(EXE) bench
38c42
< 	material.o misc.o movegen.o movepick.o pawns.o position.o \
---
> 	material.o misc.o movegen.o movepick.o pawns.o position.o psqt.o \
48a53
> # sanitize = yes/no   --- (-fsanitize )    --- enable undefined behavior checks
52,55c57,58
< # prefetch = yes/no   --- -DUSE_PREFETCH   --- Use prefetch x86 asm-instruction
< # bsfq = yes/no       --- -DUSE_BSFQ       --- Use bsfq x86_64 asm-instruction (only
< #                                              with GCC and ICC 64-bit)
< # popcnt = yes/no     --- -DUSE_POPCNT     --- Use popcnt x86_64 asm-instruction
---
> # prefetch = yes/no   --- -DUSE_PREFETCH   --- Use prefetch asm-instruction
> # popcnt = yes/no     --- -DUSE_POPCNT     --- Use popcnt asm-instruction
65a69
> sanitize = no
68d71
< bsfq = no
98d100
< 	bsfq = yes
106d107
< 	bsfq = yes
115d115
< 	bsfq = yes
124d123
< 	bsfq = yes
143c142,143
< CXXFLAGS += -Wall -Wcast-qual -fno-exceptions -fno-rtti $(EXTRACXXFLAGS)
---
> CXXFLAGS += -Wall -Wcast-qual -fno-exceptions -fno-rtti -std=c++11 $(EXTRACXXFLAGS)
> DEPENDFLAGS += -std=c++11
153c153,165
< 	CXXFLAGS += -ansi -pedantic -Wno-long-long -Wextra -Wshadow
---
> 	CXXFLAGS += -pedantic -Wextra -Wshadow
> 
> 	ifeq ($(ARCH),armv7)
> 		ifeq ($(OS),Android)
> 			CXXFLAGS += -m$(bits)
> 		endif
> 	else
> 		CXXFLAGS += -m$(bits)
> 	endif
> 
> 	ifneq ($(KERNEL),Darwin)
> 	   LDFLAGS += -Wl,--no-as-needed
> 	endif
158c170,188
< 	CXX=g++
---
> 
> 	ifeq ($(KERNEL),Linux)
> 		ifeq ($(bits),64)
> 			ifeq ($(shell which x86_64-w64-mingw32-c++-posix),)
> 				CXX=x86_64-w64-mingw32-c++
> 			else
> 				CXX=x86_64-w64-mingw32-c++-posix
> 			endif
> 		else
> 			ifeq ($(shell which i686-w64-mingw32-c++-posix),)
> 				CXX=i686-w64-mingw32-c++
> 			else
> 				CXX=i686-w64-mingw32-c++-posix
> 			endif
> 		endif
> 	else
> 		CXX=g++
> 	endif
> 
160c190
< 	LDFLAGS += -static-libstdc++ -static-libgcc
---
> 	LDFLAGS += -static
172c202,212
< 	CXXFLAGS += -pedantic -Wno-long-long -Wextra -Wshadow
---
> 	CXXFLAGS += -pedantic -Wextra -Wshadow
> 
> 	ifeq ($(ARCH),armv7)
> 		ifeq ($(OS),Android)
> 			CXXFLAGS += -m$(bits)
> 			LDFLAGS += -m$(bits)
> 		endif
> 	else
> 		CXXFLAGS += -m$(bits)
> 		LDFLAGS += -m$(bits)
> 	endif
176d215
< 	profile_prepare = icc-profile-prepare
179d217
< 	profile_clean = icc-profile-clean
181c219,222
< 	profile_prepare = gcc-profile-prepare
---
> ifeq ($(comp),clang)
> 	profile_make = clang-profile-make
> 	profile_use = clang-profile-use
> else
184c225
< 	profile_clean = gcc-profile-clean
---
> endif
187,189c228,240
< ifeq ($(UNAME),Darwin)
< 	CXXFLAGS += -arch $(arch) -mmacosx-version-min=10.6
< 	LDFLAGS += -arch $(arch) -mmacosx-version-min=10.6
---
> ifeq ($(KERNEL),Darwin)
> 	CXXFLAGS += -arch $(arch) -mmacosx-version-min=10.9
> 	LDFLAGS += -arch $(arch) -mmacosx-version-min=10.9
> endif
> 
> ### Travis CI script uses COMPILER to overwrite CXX
> ifdef COMPILER
> 	COMPCXX=$(COMPILER)
> endif
> 
> ### Allow overwriting CXX from command line
> ifdef COMPCXX
> 	CXX=$(COMPCXX)
195c246
< 	ifneq ($(arch),armv7)
---
> 	ifneq ($(OS),Android)
197c248
< 		ifneq ($(UNAME),Haiku)
---
> 		ifneq ($(KERNEL),Haiku)
203c254
< ### 3.4 Debugging
---
> ### 3.2.1 Debugging
210c261,267
< ### 3.5 Optimization
---
> ### 3.2.2 Debugging with undefined behavior sanitizers
> ifeq ($(sanitize),yes)
>         CXXFLAGS += -g3 -fsanitize=undefined
>         LDFLAGS += -fsanitize=undefined
> endif
> 
> ### 3.3 Optimization
212a270,271
> 	CXXFLAGS += -O3
> 
214d272
< 		CXXFLAGS += -O3
216c274
< 		ifeq ($(UNAME),Darwin)
---
> 		ifeq ($(KERNEL),Darwin)
225c283
< 		ifeq ($(arch),armv7)
---
> 		ifeq ($(OS), Android)
230,233d287
< 	ifeq ($(comp),mingw)
< 		CXXFLAGS += -O3
< 	endif
< 
235,238c289,290
< 		ifeq ($(UNAME),Darwin)
< 			CXXFLAGS += -fast -mdynamic-no-pic
< 		else
< 			CXXFLAGS += -fast
---
> 		ifeq ($(KERNEL),Darwin)
> 			CXXFLAGS += -mdynamic-no-pic
243,246c295
< 		CXXFLAGS += -O3
< 
< 		ifeq ($(UNAME),Darwin)
< 			ifeq ($(pext),no)
---
> 		ifeq ($(KERNEL),Darwin)
249d297
< 			endif
260c308
< ### 3.6. Bits
---
> ### 3.4 Bits
265c313
< ### 3.7 prefetch
---
> ### 3.5 prefetch
275,280c323
< ### 3.8 bsfq
< ifeq ($(bsfq),yes)
< 	CXXFLAGS += -DUSE_BSFQ
< endif
< 
< ### 3.9 popcnt
---
> ### 3.6 popcnt
289c332
< ### 3.10 pext
---
> ### 3.7 pext
293c336
< 		CXXFLAGS += -mbmi -mbmi2
---
> 		CXXFLAGS += -mbmi2
297c340
< ### 3.11 Link Time Optimization, it works since gcc 4.5 but not on mingw.
---
> ### 3.8 Link Time Optimization, it works since gcc 4.5 but not on mingw under Windows.
303,308c346,347
< 		GCC_MAJOR := `$(CXX) -dumpversion | cut -f1 -d.`
< 		GCC_MINOR := `$(CXX) -dumpversion | cut -f2 -d.`
< 		ifeq (1,$(shell expr \( $(GCC_MAJOR) \> 4 \) \| \( $(GCC_MAJOR) \= 4 \& $(GCC_MINOR) \>= 5 \)))
< 			CXXFLAGS += -flto
< 			LDFLAGS += $(CXXFLAGS)
< 		endif
---
> 		CXXFLAGS += -flto
> 		LDFLAGS += $(CXXFLAGS)
312a352,370
> ifeq ($(comp),mingw)
> 	ifeq ($(KERNEL),Linux)
> 	ifeq ($(optimize),yes)
> 	ifeq ($(debug),no)
> 		CXXFLAGS += -flto
> 		LDFLAGS += $(CXXFLAGS)
> 	endif
> 	endif
> 	endif
> endif
> 
> ### 3.9 Android 5 can only run position independent executables. Note that this
> ### breaks Android 4.0 and earlier.
> ifeq ($(OS), Android)
> 	CXXFLAGS += -fPIE
> 	LDFLAGS += -fPIE -pie
> endif
> 
> 
321c379
< 	@echo "make target ARCH=arch [COMP=comp]"
---
> 	@echo "make target ARCH=arch [COMP=compiler] [COMPCXX=cxx]"
351c409
< 	@echo "Examples. If you don't know what to do, you likely want to run: "
---
> 	@echo "Simple examples. If you don't know what to do, you likely want to run: "
355a414,418
> 	@echo "Advanced examples, for experienced users: "
> 	@echo ""
> 	@echo "make build ARCH=x86-64 COMP=clang"
> 	@echo "make profile-build ARCH=x86-64-modern COMP=gcc COMPCXX=g++-4.8"
> 	@echo ""
357,359c420,425
< .PHONY: build profile-build
< build:
< 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) config-sanity
---
> 
> .PHONY: help build profile-build strip install clean objclean profileclean help \
>         config-sanity icc-profile-use icc-profile-make gcc-profile-use gcc-profile-make \
>         clang-profile-use clang-profile-make
> 
> build: config-sanity
362,363c428
< profile-build:
< 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) config-sanity
---
> profile-build: config-sanity objclean profileclean
365,369c430
< 	@echo "Step 0/4. Preparing for profile build."
< 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) $(profile_prepare)
< 	@echo ""
< 	@echo "Step 1/4. Building executable for benchmark ..."
< 	@touch *.cpp *.h syzygy/*.cpp syzygy/*.h
---
> 	@echo "Step 1/4. Building instrumented executable ..."
373c434
< 	@$(PGOBENCH) > /dev/null
---
> 	$(PGOBENCH) > /dev/null
375,379c436,437
< 	@echo "Step 3/4. Building final executable ..."
< # Deleting corrupt ucioption.gc* profile files is necessary to avoid an 
< # "internal compiler error" for gcc versions 4.7.x
< 	@rm ucioption.gc*
< 	@touch *.cpp *.h syzygy/*.cpp syzygy/*.h
---
> 	@echo "Step 3/4. Building optimized executable ..."
> 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) objclean
383c441
< 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) $(profile_clean)
---
> 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) profileclean
393,394c451,463
< clean:
< 	$(RM) $(EXE) $(EXE).exe *.o .depend *~ core bench.txt *.gcda ./syzygy/*.o ./syzygy/*.gcda
---
> #clean all
> clean: objclean profileclean
> 	@rm -f .depend *~ core 
> 
> # clean binaries and objects
> objclean:
> 	@rm -f $(EXE) $(EXE).exe *.o ./syzygy/*.o
> 
> # clean auxiliary profiling files
> profileclean:
> 	@rm -rf profdir
> 	@rm -f bench.txt *.gcda ./syzygy/*.gcda *.gcno ./syzygy/*.gcno
> 	@rm -f stockfish.profdata *.profraw
408a478
> 	@echo "sanitize: '$(sanitize)'"
411a482,483
> 	@echo "kernel: '$(KERNEL)'"
> 	@echo "os: '$(OS)'"
413d484
< 	@echo "bsfq: '$(bsfq)'"
425a497
> 	@test "$(sanitize)" = "yes" || test "$(sanitize)" = "no"
431d502
< 	@test "$(bsfq)" = "yes" || test "$(bsfq)" = "no"
440,441c511,522
< gcc-profile-prepare:
< 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) gcc-profile-clean
---
> clang-profile-make:
> 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) \
> 	EXTRACXXFLAGS='-fprofile-instr-generate ' \
> 	EXTRALDFLAGS=' -fprofile-instr-generate' \
> 	all
> 
> clang-profile-use:
> 	llvm-profdata merge -output=stockfish.profdata *.profraw
> 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) \
> 	EXTRACXXFLAGS='-fprofile-instr-use=stockfish.profdata' \
> 	EXTRALDFLAGS='-fprofile-use ' \
> 	all
445c526
< 	EXTRACXXFLAGS='-fprofile-arcs' \
---
> 	EXTRACXXFLAGS='-fprofile-generate' \
451c532
< 	EXTRACXXFLAGS='-fbranch-probabilities' \
---
> 	EXTRACXXFLAGS='-fprofile-use -fno-peel-loops -fno-tracer' \
455,461d535
< gcc-profile-clean:
< 	@rm -rf *.gcda *.gcno syzygy/*.gcda syzygy/*.gcno bench.txt
< 
< icc-profile-prepare:
< 	$(MAKE) ARCH=$(ARCH) COMP=$(COMP) icc-profile-clean
< 	@mkdir profdir
< 
462a537
> 	@mkdir -p profdir
471,473d545
< 
< icc-profile-clean:
< 	@rm -rf profdir bench.txt
****************************************************************
ucioption
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
22,23c23
< #include <cstdlib>
< #include <sstream>
---
> #include <ostream>
25a26
> #include "search.h"
38c39
< void on_clear_hash(const Option&) { TT.clear(); }
---
> void on_clear_hash(const Option&) { Search::clear(); }
46,47d46
< bool ci_less(char c1, char c2) { return tolower(c1) < tolower(c2); }
< 
49c48,50
<   return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(), ci_less);
---
> 
>   return std::lexicographical_compare(s1.begin(), s1.end(), s2.begin(), s2.end(),
>          [](char c1, char c2) { return tolower(c1) < tolower(c2); });
57c58,60
<   o["Write Debug Log"]       << Option(false, on_logger);
---
>   const int MaxHashMB = Is64Bit ? 1024 * 1024 : 2048;
> 
>   o["Debug Log File"]        << Option("", on_logger);
59,61c62,63
<   o["Min Split Depth"]       << Option(0, 0, 12, on_threads);
<   o["Threads"]               << Option(1, 1, MAX_THREADS, on_threads);
<   o["Hash"]                  << Option(16, 1, 1024 * 1024, on_hash_size);
---
>   o["Threads"]               << Option(1, 1, 128, on_threads);
>   o["Hash"]                  << Option(16, 1, MaxHashMB, on_hash_size);
63c65
<   o["Ponder"]                << Option(true);
---
>   o["Ponder"]                << Option(false);
68c70,71
<   o["Slow Mover"]            << Option(80, 10, 1000);
---
>   o["Slow Mover"]            << Option(89, 10, 1000);
>   o["nodestime"]             << Option(0, 0, 10000);
83,84c86,87
<       for (OptionsMap::const_iterator it = om.begin(); it != om.end(); ++it)
<           if (it->second.idx == idx)
---
>       for (const auto& it : om)
>           if (it.second.idx == idx)
86,87c89,90
<               const Option& o = it->second;
<               os << "\noption name " << it->first << " type " << o.type;
---
>               const Option& o = it.second;
>               os << "\noption name " << it.first << " type " << o.type;
96a100
> 
113,114c117
< { std::ostringstream ss; ss << v; defaultValue = currentValue = ss.str(); }
< 
---
> { defaultValue = currentValue = std::to_string(v); }
118c121
<   return (type == "spin" ? atoi(currentValue.c_str()) : currentValue == "true");
---
>   return (type == "spin" ? stoi(currentValue) : currentValue == "true");
148c151
<       || (type == "spin" && (atoi(v.c_str()) < min || atoi(v.c_str()) > max)))
---
>       || (type == "spin" && (stoi(v) < min || stoi(v) > max)))
****************************************************************
main
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23d23
< #include "evaluate.h"
30a31,34
> namespace PSQT {
>   void init();
> }
> 
35a40
>   PSQT::init();
38c43
<   Bitbases::init_kpk();
---
>   Bitbases::init();
40d44
<   Eval::init();
48a53
>   return 0;
****************************************************************
bitbase
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
19a21
> #include <algorithm>
20a23
> #include <numeric>
54c57
<   inline Result& operator|=(Result& r, Result v) { return r = Result(r | v); }
---
>   Result& operator|=(Result& r, Result v) { return r = Result(r | v); }
57,58c60,61
< 
<     KPKPosition(unsigned idx);
---
>     KPKPosition() = default;
>     explicit KPKPosition(unsigned idx);
63d65
<   private:
67c69
<     Square bksq, wksq, psq;
---
>     Square ksq[COLOR_NB], psq;
74c76
< bool Bitbases::probe_kpk(Square wksq, Square wpsq, Square bksq, Color us) {
---
> bool Bitbases::probe(Square wksq, Square wpsq, Square bksq, Color us) {
83c85
< void Bitbases::init_kpk() {
---
> void Bitbases::init() {
84a87
>   std::vector<KPKPosition> db(MAX_INDEX);
86,87d88
<   std::vector<KPKPosition> db;
<   db.reserve(MAX_INDEX);
91c92
<       db.push_back(KPKPosition(idx));
---
>       db[idx] = KPKPosition(idx);
110,114c111,114
<     wksq   = Square((idx >>  0) & 0x3F);
<     bksq   = Square((idx >>  6) & 0x3F);
<     us     = Color ((idx >> 12) & 0x01);
<     psq    = make_square(File((idx >> 13) & 0x3), RANK_7 - Rank((idx >> 15) & 0x7));
<     result = UNKNOWN;
---
>     ksq[WHITE] = Square((idx >>  0) & 0x3F);
>     ksq[BLACK] = Square((idx >>  6) & 0x3F);
>     us         = Color ((idx >> 12) & 0x01);
>     psq        = make_square(File((idx >> 13) & 0x3), RANK_7 - Rank((idx >> 15) & 0x7));
117,120c117,120
<     if (   distance(wksq, bksq) <= 1
<         || wksq == psq
<         || bksq == psq
<         || (us == WHITE && (StepAttacksBB[PAWN][psq] & bksq)))
---
>     if (   distance(ksq[WHITE], ksq[BLACK]) <= 1
>         || ksq[WHITE] == psq
>         || ksq[BLACK] == psq
>         || (us == WHITE && (StepAttacksBB[PAWN][psq] & ksq[BLACK])))
123,131c123,130
<     else if (us == WHITE)
<     {
<         // Immediate win if a pawn can be promoted without getting captured
<         if (   rank_of(psq) == RANK_7
<             && wksq != psq + DELTA_N
<             && (   distance(bksq, psq + DELTA_N) > 1
<                 ||(StepAttacksBB[KING][wksq] & (psq + DELTA_N))))
<             result = WIN;
<     }
---
>     // Immediate win if a pawn can be promoted without getting captured
>     else if (   us == WHITE
>              && rank_of(psq) == RANK_7
>              && ksq[us] != psq + NORTH
>              && (    distance(ksq[~us], psq + NORTH) > 1
>                  || (StepAttacksBB[KING][ksq[us]] & (psq + NORTH))))
>         result = WIN;
> 
133,134c132,134
<     else if (  !(StepAttacksBB[KING][bksq] & ~(StepAttacksBB[KING][wksq] | StepAttacksBB[PAWN][psq]))
<              || (StepAttacksBB[KING][bksq] & psq & ~StepAttacksBB[KING][wksq]))
---
>     else if (   us == BLACK
>              && (  !(StepAttacksBB[KING][ksq[us]] & ~(StepAttacksBB[KING][ksq[~us]] | StepAttacksBB[PAWN][psq]))
>                  || (StepAttacksBB[KING][ksq[us]] & psq & ~StepAttacksBB[KING][ksq[~us]])))
135a136,139
> 
>     // Position will be classified later
>     else
>         result = UNKNOWN;
141c145
<     // White to Move: If one move leads to a position classified as WIN, the result
---
>     // White to move: If one move leads to a position classified as WIN, the result
146c150
<     // Black to Move: If one move leads to a position classified as DRAW, the result
---
>     // Black to move: If one move leads to a position classified as DRAW, the result
151c155,157
<     const Color Them = (Us == WHITE ? BLACK : WHITE);
---
>     const Color  Them = (Us == WHITE ? BLACK : WHITE);
>     const Result Good = (Us == WHITE ? WIN   : DRAW);
>     const Result Bad  = (Us == WHITE ? DRAW  : WIN);
154c160
<     Bitboard b = StepAttacksBB[KING][Us == WHITE ? wksq : bksq];
---
>     Bitboard b = StepAttacksBB[KING][ksq[Us]];
157,158c163,164
<         r |= Us == WHITE ? db[index(Them, bksq, pop_lsb(&b), psq)]
<                          : db[index(Them, pop_lsb(&b), wksq, psq)];
---
>         r |= Us == WHITE ? db[index(Them, ksq[Them]  , pop_lsb(&b), psq)]
>                          : db[index(Them, pop_lsb(&b), ksq[Them]  , psq)];
160c166
<     if (Us == WHITE && rank_of(psq) < RANK_7)
---
>     if (Us == WHITE)
162,163c168,169
<         Square s = psq + DELTA_N;
<         r |= db[index(BLACK, bksq, wksq, s)]; // Single push
---
>         if (rank_of(psq) < RANK_7)      // Single push
>             r |= db[index(Them, ksq[Them], ksq[Us], psq + NORTH)];
165,166c171,174
<         if (rank_of(psq) == RANK_2 && s != wksq && s != bksq)
<             r |= db[index(BLACK, bksq, wksq, s + DELTA_N)]; // Double push
---
>         if (   rank_of(psq) == RANK_2   // Double push
>             && psq + NORTH != ksq[Us]
>             && psq + NORTH != ksq[Them])
>             r |= db[index(Them, ksq[Them], ksq[Us], psq + NORTH + NORTH)];
169,172c177
<     if (Us == WHITE)
<         return result = r & WIN  ? WIN  : r & UNKNOWN ? UNKNOWN : DRAW;
<     else
<         return result = r & DRAW ? DRAW : r & UNKNOWN ? UNKNOWN : WIN;
---
>     return result = r & Good  ? Good  : r & UNKNOWN ? UNKNOWN : Bad;
****************************************************************
benchmark
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
20d20
< #include <algorithm>
30d29
< #include "tt.h"
37c36
< const char* Defaults[] = {
---
> const vector<string> Defaults = {
80a80,86
> 
>   // Mate and stalemate positions
>   "8/8/8/8/8/6k1/6p1/6K1 w - -",
>   "5k2/5P2/5K2/8/8/8/8/8 b - -",
>   "8/8/8/8/8/4k3/4p3/4K3 w - -",
>   "8/8/8/8/8/5K2/8/3Q1k2 b - -",
>   "7k/7P/6K1/8/3B4/8/8/8 b - -"
91c97
< /// limit value: depth (default), time in secs or number of nodes.
---
> /// limit value: depth (default), time in millisecs or number of nodes.
96d101
<   Search::LimitsType limits;
97a103
>   Search::LimitsType limits;
108c114
<   TT.clear();
---
>   Search::clear();
111c117
<       limits.movetime = 1000 * atoi(limit.c_str()); // movetime is in ms
---
>       limits.movetime = stoi(limit); // movetime is in millisecs
114c120
<       limits.nodes = atoi(limit.c_str());
---
>       limits.nodes = stoll(limit);
117c123
<       limits.mate = atoi(limit.c_str());
---
>       limits.mate = stoi(limit);
120c126
<       limits.depth = atoi(limit.c_str());
---
>       limits.depth = stoi(limit);
123c129
<       fens.assign(Defaults, Defaults + 37);
---
>       fens = Defaults;
131c137
<       ifstream file(fenFile.c_str());
---
>       ifstream file(fenFile);
147,148c153,154
<   Search::StateStackPtr st;
<   Time::point elapsed = Time::now();
---
>   TimePoint elapsed = now();
>   Position pos;
152c158,159
<       Position pos(fens[i], Options["UCI_Chess960"], Threads.main());
---
>       StateListPtr states(new std::deque<StateInfo>(1));
>       pos.set(fens[i], Options["UCI_Chess960"], &states->back(), Threads.main());
157c164
<           nodes += Search::perft<true>(pos, limits.depth * ONE_PLY);
---
>           nodes += Search::perft(pos, limits.depth * ONE_PLY);
161,163c168,171
<           Threads.start_thinking(pos, limits, st);
<           Threads.wait_for_think_finished();
<           nodes += Search::RootPos.nodes_searched();
---
>           limits.startTime = now();
>           Threads.start_thinking(pos, states, limits);
>           Threads.main()->wait_for_search_finished();
>           nodes += Threads.nodes_searched();
167c175
<   elapsed = std::max(Time::now() - elapsed, Time::point(1)); // Avoid a 'divide by zero'
---
>   elapsed = now() - elapsed + 1; // Ensure positivity to avoid a 'divide by zero'
169c177
<   dbg_print(); // Just before to exit
---
>   dbg_print(); // Just before exiting
****************************************************************
types
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23,24c24,25
< /// For Linux and OSX configuration is done automatically using Makefile. To get
< /// started type 'make help'.
---
> /// When compiling with provided Makefile (e.g. for Linux and OSX), configuration
> /// is done automatically. To get started type 'make help'.
26,27c27,28
< /// For Windows, part of the configuration is detected automatically, but some
< /// switches need to be set manually:
---
> /// When Makefile is not used (e.g. with Microsoft Visual Studio) some switches
> /// need to be set manually:
29c30
< /// -DNDEBUG      | Disable debugging mode. Always use this.
---
> /// -DNDEBUG      | Disable debugging mode. Always use this for release.
31,32c32,33
< /// -DNO_PREFETCH | Disable use of prefetch asm-instruction. A must if you want
< ///               | the executable to run on some very old machines.
---
> /// -DNO_PREFETCH | Disable use of prefetch asm-instruction. You may need this to
> ///               | run on some very old machines.
35,36c36,39
< ///               | only in 64-bit mode. For compiling requires hardware with
< ///               | popcnt support.
---
> ///               | only in 64-bit mode and requires hardware with popcnt support.
> ///
> /// -DUSE_PEXT    | Add runtime support for use of pext asm-instruction. Works
> ///               | only in 64-bit mode and requires hardware with pext support.
40a44
> #include <cstdint>
43c47,52
< #include "platform.h"
---
> #if defined(_MSC_VER)
> // Disable some silly and noisy warning from MSVC compiler
> #pragma warning(disable: 4127) // Conditional expression is constant
> #pragma warning(disable: 4146) // Unary minus operator applied to unsigned type
> #pragma warning(disable: 4800) // Forcing value to bool 'true' or 'false'
> #endif
45c54,60
< #define unlikely(x) (x) // For code annotation purposes
---
> /// Predefined macros hell:
> ///
> /// __GNUC__           Compiler is gcc, Clang or Intel on Linux
> /// __INTEL_COMPILER   Compiler is Intel
> /// _MSC_VER           Compiler is MSVC or Intel on Windows
> /// _WIN32             Building on Windows (any)
> /// _WIN64             Building on Windows 64 bit
47,48c62,63
< #if defined(_WIN64) && !defined(IS_64BIT)
< #  include <intrin.h> // MSVC popcnt and bsfq instrinsics
---
> #if defined(_WIN64) && defined(_MSC_VER) // No Makefile used
> #  include <intrin.h> // Microsoft header for _BitScanForward64()
50d64
< #  define USE_BSFQ
53,54c67,68
< #if defined(USE_POPCNT) && defined(_MSC_VER) && defined(__INTEL_COMPILER)
< #  include <nmmintrin.h> // Intel header for _mm_popcnt_u64() intrinsic
---
> #if defined(USE_POPCNT) && (defined(__INTEL_COMPILER) || defined(_MSC_VER))
> #  include <nmmintrin.h> // Intel and Microsoft header for _mm_popcnt_u64()
57,60c71,72
< #if defined(USE_PEXT)
< #  include <immintrin.h> // Header for _pext_u64() intrinsic
< #else
< #  define _pext_u64(b, m) (0)
---
> #if !defined(NO_PREFETCH) && (defined(__INTEL_COMPILER) || defined(_MSC_VER))
> #  include <xmmintrin.h> // Intel and Microsoft header for _mm_prefetch()
63,72c75,77
< #  if !defined(NO_PREFETCH) && (defined(__INTEL_COMPILER) || defined(_MSC_VER))
< #   include <xmmintrin.h> // Intel and Microsoft header for _mm_prefetch()
< #  endif
< 
< #define CACHE_LINE_SIZE 64
< 
< #ifdef _MSC_VER
< #  define FORCE_INLINE  __forceinline
< #elif defined(__GNUC__)
< #  define FORCE_INLINE  inline __attribute__((always_inline))
---
> #if defined(USE_PEXT)
> #  include <immintrin.h> // Header for _pext_u64() intrinsic
> #  define pext(b, m) _pext_u64(b, m)
74c79
< #  define FORCE_INLINE  inline
---
> #  define pext(b, m) (0)
113c118
< enum Move {
---
> enum Move : int {
136,138c141,143
<   WHITE_OOO   = WHITE_OO << 1,
<   BLACK_OO    = WHITE_OO << 2,
<   BLACK_OOO   = WHITE_OO << 3,
---
>   WHITE_OOO = WHITE_OO << 1,
>   BLACK_OO  = WHITE_OO << 2,
>   BLACK_OOO = WHITE_OO << 3,
170c175
< enum Value {
---
> enum Value : int {
181,188c186,190
<   VALUE_ENSURE_INTEGER_SIZE_P = INT_MAX,
<   VALUE_ENSURE_INTEGER_SIZE_N = INT_MIN,
< 
<   PawnValueMg   = 198,   PawnValueEg   = 258,
<   KnightValueMg = 817,   KnightValueEg = 846,
<   BishopValueMg = 836,   BishopValueEg = 857,
<   RookValueMg   = 1270,  RookValueEg   = 1278,
<   QueenValueMg  = 2521,  QueenValueEg  = 2558,
---
>   PawnValueMg   = 188,   PawnValueEg   = 248,
>   KnightValueMg = 753,   KnightValueEg = 832,
>   BishopValueMg = 826,   BishopValueEg = 897,
>   RookValueMg   = 1285,  RookValueEg   = 1371,
>   QueenValueMg  = 2513,  QueenValueEg  = 2650,
190c192
<   MidgameLimit  = 15581, EndgameLimit  = 3998
---
>   MidgameLimit  = 15258, EndgameLimit  = 3915
206c208,212
< enum Depth {
---
> const Piece Pieces[] = { W_PAWN, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
>                          B_PAWN, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING };
> extern Value PieceValue[PHASE_NB][PIECE_NB];
> 
> enum Depth : int {
210,213c216,219
<   DEPTH_ZERO          =  0,
<   DEPTH_QS_CHECKS     =  0,
<   DEPTH_QS_NO_CHECKS  = -1,
<   DEPTH_QS_RECAPTURES = -5,
---
>   DEPTH_ZERO          =  0 * ONE_PLY,
>   DEPTH_QS_CHECKS     =  0 * ONE_PLY,
>   DEPTH_QS_NO_CHECKS  = -1 * ONE_PLY,
>   DEPTH_QS_RECAPTURES = -5 * ONE_PLY,
215,216c221,222
<   DEPTH_NONE = -6,
<   DEPTH_MAX  = MAX_PLY
---
>   DEPTH_NONE = -6 * ONE_PLY,
>   DEPTH_MAX  = MAX_PLY * ONE_PLY
218a225,226
> static_assert(!(ONE_PLY & (ONE_PLY - 1)), "ONE_PLY is not a power of 2");
> 
232,242c240,248
<   DELTA_N =  8,
<   DELTA_E =  1,
<   DELTA_S = -8,
<   DELTA_W = -1,
< 
<   DELTA_NN = DELTA_N + DELTA_N,
<   DELTA_NE = DELTA_N + DELTA_E,
<   DELTA_SE = DELTA_S + DELTA_E,
<   DELTA_SS = DELTA_S + DELTA_S,
<   DELTA_SW = DELTA_S + DELTA_W,
<   DELTA_NW = DELTA_N + DELTA_W
---
>   NORTH =  8,
>   EAST  =  1,
>   SOUTH = -8,
>   WEST  = -1,
> 
>   NORTH_EAST = NORTH + EAST,
>   SOUTH_EAST = SOUTH + EAST,
>   SOUTH_WEST = SOUTH + WEST,
>   NORTH_WEST = NORTH + WEST
245c251
< enum File {
---
> enum File : int {
249c255
< enum Rank {
---
> enum Rank : int {
254c260
< /// The Score enum stores a middlegame and an endgame value in a single integer
---
> /// Score enum stores a middlegame and an endgame value in a single integer
256,263c262,264
< /// and the upper 16 bits are used to store the middlegame value. The compiler
< /// is free to choose the enum type as long as it can store the data, so we
< /// ensure that Score is an integer type by assigning some big int values.
< enum Score {
<   SCORE_ZERO,
<   SCORE_ENSURE_INTEGER_SIZE_P = INT_MAX,
<   SCORE_ENSURE_INTEGER_SIZE_N = INT_MIN
< };
---
> /// and the upper 16 bits are used to store the middlegame value. Take some
> /// care to avoid left-shifting a signed int to avoid undefined behavior.
> enum Score : int { SCORE_ZERO };
265c266,268
< inline Score make_score(int mg, int eg) { return Score((mg << 16) + eg); }
---
> inline Score make_score(int mg, int eg) {
>   return Score((int)((unsigned int)eg << 16) + mg);
> }
270,271c273,276
< inline Value mg_value(Score s) {
<   return Value(((s + 0x8000) & ~0xffff) / 0x10000);
---
> inline Value eg_value(Score s) {
> 
>   union { uint16_t u; int16_t s; } eg = { uint16_t(unsigned(s + 0x8000) >> 16) };
>   return Value(eg.s);
274,275c279,282
< inline Value eg_value(Score s) {
<   return Value((int)(unsigned(s) & 0x7FFFU) - (int)(unsigned(s) & 0x8000U));
---
> inline Value mg_value(Score s) {
> 
>   union { uint16_t u; int16_t s; } mg = { uint16_t(unsigned(s)) };
>   return Value(mg.s);
281,282d287
< inline T operator*(int i, T d) { return T(i * int(d)); }        \
< inline T operator*(T d, int i) { return T(int(d) * i); }        \
286,288d290
< inline T& operator*=(T& d, int i) { return d = T(int(d) * i); }
< 
< ENABLE_BASE_OPERATORS_ON(Score)
291a294,295
> inline T operator*(int i, T d) { return T(i * int(d)); }        \
> inline T operator*(T d, int i) { return T(int(d) * i); }        \
295a300
> inline T& operator*=(T& d, int i) { return d = T(int(d) * i); } \
306a312,313
> ENABLE_BASE_OPERATORS_ON(Score)
> 
325,330c332,338
< extern Value PieceValue[PHASE_NB][PIECE_NB];
< 
< struct ExtMove {
<   Move move;
<   Value value;
< };
---
> /// Multiplication of a Score by an integer. We check for overflow in debug mode.
> inline Score operator*(Score s, int i) {
>   Score result = Score(int(s) * i);
> 
>   assert(eg_value(result) == (i * eg_value(s)));
>   assert(mg_value(result) == (i * mg_value(s)));
>   assert((i == 0) || (result / i) == s );
332,333c340
< inline bool operator<(const ExtMove& f, const ExtMove& s) {
<   return f.value < s.value;
---
>   return result;
337c344
<   return Color(c ^ BLACK);
---
>   return Color(c ^ BLACK); // Toggle color
343a351,354
> inline Piece operator~(Piece pc) {
>   return Piece(pc ^ 8); // Swap color of piece B_KNIGHT -> W_KNIGHT
> }
> 
357c368
<   return Square((r << 3) | f);
---
>   return Square((r << 3) + f);
361c372
<   return Piece((c << 3) | pt);
---
>   return Piece((c << 3) + pt);
364c375
< inline PieceType type_of(Piece pc)  {
---
> inline PieceType type_of(Piece pc) {
403c414
<   return c == WHITE ? DELTA_N : DELTA_S;
---
>   return c == WHITE ? NORTH : SOUTH;
419c430
<   return PieceType(((m >> 12) & 3) + 2);
---
>   return PieceType(((m >> 12) & 3) + KNIGHT);
423c434
<   return Move(to | (from << 6));
---
>   return Move((from << 6) + to);
428c439
<   return Move(to | (from << 6) | T | ((pt - KNIGHT) << 12));
---
>   return Move(T + ((pt - KNIGHT) << 12) + (from << 6) + to);
432c443
<   return from_sq(m) != to_sq(m); // Catch also MOVE_NULL and MOVE_NONE
---
>   return from_sq(m) != to_sq(m); // Catch MOVE_NULL and MOVE_NONE
****************************************************************
syzygy/tbprobe
****************************************************************
1a2
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
3c4
<   This file may be redistributed and/or modified without restrictions.
---
>   Copyright (C) 2016-2017 Marco Costalba, Lucas Braesch
5,7c6,17
<   tbprobe.cpp contains the Stockfish-specific routines of the
<   tablebase probing code. It should be relatively easy to adapt
<   this code to other chess engines.
---
>   Stockfish is free software: you can redistribute it and/or modify
>   it under the terms of the GNU General Public License as published by
>   the Free Software Foundation, either version 3 of the License, or
>   (at your option) any later version.
> 
>   Stockfish is distributed in the hope that it will be useful,
>   but WITHOUT ANY WARRANTY; without even the implied warranty of
>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>   GNU General Public License for more details.
> 
>   You should have received a copy of the GNU General Public License
>   along with this program.  If not, see <http://www.gnu.org/licenses/>.
10a21,29
> #include <atomic>
> #include <cstdint>
> #include <cstring>   // For std::memset
> #include <deque>
> #include <fstream>
> #include <iostream>
> #include <list>
> #include <sstream>
> #include <type_traits>
12,13d30
< #include "../position.h"
< #include "../movegen.h"
14a32,33
> #include "../movegen.h"
> #include "../position.h"
16c35,36
< #include "../bitcount.h"
---
> #include "../thread_win32.h"
> #include "../types.h"
19d38
< #include "tbcore.h"
21c40,58
< #include "tbcore.cpp"
---
> #ifndef _WIN32
> #include <fcntl.h>
> #include <unistd.h>
> #include <sys/mman.h>
> #include <sys/stat.h>
> #else
> #define WIN32_LEAN_AND_MEAN
> #define NOMINMAX
> #include <windows.h>
> #endif
> 
> using namespace Tablebases;
> 
> int Tablebases::MaxCardinality;
> 
> namespace {
> 
> // Each table has a set of flags: all of them refer to DTZ tables, the last one to WDL tables
> enum TBFlag { STM = 1, Mapped = 2, WinPlies = 4, LossPlies = 8, SingleValue = 128 };
23,24c60,71
< namespace Zobrist {
<   extern Key psq[COLOR_NB][PIECE_TYPE_NB][SQUARE_NB];
---
> inline WDLScore operator-(WDLScore d) { return WDLScore(-int(d)); }
> inline Square operator^=(Square& s, int i) { return s = Square(int(s) ^ i); }
> inline Square operator^(Square s, int i) { return Square(int(s) ^ i); }
> 
> // DTZ tables don't store valid scores for moves that reset the rule50 counter
> // like captures and pawn moves but we can easily recover the correct dtz of the
> // previous move if we know the position's WDL score.
> int dtz_before_zeroing(WDLScore wdl) {
>     return wdl == WDLWin         ?  1   :
>            wdl == WDLCursedWin   ?  101 :
>            wdl == WDLBlessedLoss ? -101 :
>            wdl == WDLLoss        ? -1   : 0;
27c74,77
< int Tablebases::MaxCardinality = 0;
---
> // Return the sign of a number (-1, 0, 1)
> template <typename T> int sign_of(T val) {
>     return (T(0) < val) - (val < T(0));
> }
29,75c79,228
< // Given a position with 6 or fewer pieces, produce a text string
< // of the form KQPvKRP, where "KQP" represents the white pieces if
< // mirror == 0 and the black pieces if mirror == 1.
< static void prt_str(Position& pos, char *str, int mirror)
< {
<   Color color;
<   PieceType pt;
<   int i;
< 
<   color = !mirror ? WHITE : BLACK;
<   for (pt = KING; pt >= PAWN; --pt)
<     for (i = popcount<Max15>(pos.pieces(color, pt)); i > 0; i--)
<       *str++ = pchr[6 - pt];
<   *str++ = 'v';
<   color = ~color;
<   for (pt = KING; pt >= PAWN; --pt)
<     for (i = popcount<Max15>(pos.pieces(color, pt)); i > 0; i--)
<       *str++ = pchr[6 - pt];
<   *str++ = 0;
< }
< 
< // Given a position, produce a 64-bit material signature key.
< // If the engine supports such a key, it should equal the engine's key.
< static uint64 calc_key(Position& pos, int mirror)
< {
<   Color color;
<   PieceType pt;
<   int i;
<   uint64 key = 0;
< 
<   color = !mirror ? WHITE : BLACK;
<   for (pt = PAWN; pt <= KING; ++pt)
<     for (i = popcount<Max15>(pos.pieces(color, pt)); i > 0; i--)
<       key ^= Zobrist::psq[WHITE][pt][i - 1];
<   color = ~color;
<   for (pt = PAWN; pt <= KING; ++pt)
<     for (i = popcount<Max15>(pos.pieces(color, pt)); i > 0; i--)
<       key ^= Zobrist::psq[BLACK][pt][i - 1];
< 
<   return key;
< }
< 
< // Produce a 64-bit material key corresponding to the material combination
< // defined by pcs[16], where pcs[1], ..., pcs[6] is the number of white
< // pawns, ..., kings and pcs[9], ..., pcs[14] is the number of black
< // pawns, ..., kings.
< static uint64 calc_key_from_pcs(int *pcs, int mirror)
---
> // Numbers in little endian used by sparseIndex[] to point into blockLength[]
> struct SparseEntry {
>     char block[4];   // Number of block
>     char offset[2];  // Offset within the block
> };
> 
> static_assert(sizeof(SparseEntry) == 6, "SparseEntry must be 6 bytes");
> 
> typedef uint16_t Sym; // Huffman symbol
> 
> struct LR {
>     enum Side { Left, Right, Value };
> 
>     uint8_t lr[3]; // The first 12 bits is the left-hand symbol, the second 12
>                    // bits is the right-hand symbol. If symbol has length 1,
>                    // then the first byte is the stored value.
>     template<Side S>
>     Sym get() {
>         return S == Left  ? ((lr[1] & 0xF) << 8) | lr[0] :
>                S == Right ?  (lr[2] << 4) | (lr[1] >> 4) :
>                S == Value ?   lr[0] : (assert(false), Sym(-1));
>     }
> };
> 
> static_assert(sizeof(LR) == 3, "LR tree entry must be 3 bytes");
> 
> const int TBPIECES = 6;
> 
> struct PairsData {
>     int flags;
>     size_t sizeofBlock;            // Block size in bytes
>     size_t span;                   // About every span values there is a SparseIndex[] entry
>     int blocksNum;                 // Number of blocks in the TB file
>     int maxSymLen;                 // Maximum length in bits of the Huffman symbols
>     int minSymLen;                 // Minimum length in bits of the Huffman symbols
>     Sym* lowestSym;                // lowestSym[l] is the symbol of length l with the lowest value
>     LR* btree;                     // btree[sym] stores the left and right symbols that expand sym
>     uint16_t* blockLength;         // Number of stored positions (minus one) for each block: 1..65536
>     int blockLengthSize;           // Size of blockLength[] table: padded so it's bigger than blocksNum
>     SparseEntry* sparseIndex;      // Partial indices into blockLength[]
>     size_t sparseIndexSize;        // Size of SparseIndex[] table
>     uint8_t* data;                 // Start of Huffman compressed data
>     std::vector<uint64_t> base64;  // base64[l - min_sym_len] is the 64bit-padded lowest symbol of length l
>     std::vector<uint8_t> symlen;   // Number of values (-1) represented by a given Huffman symbol: 1..256
>     Piece pieces[TBPIECES];        // Position pieces: the order of pieces defines the groups
>     uint64_t groupIdx[TBPIECES+1]; // Start index used for the encoding of the group's pieces
>     int groupLen[TBPIECES+1];      // Number of pieces in a given group: KRKN -> (3, 1)
> };
> 
> // Helper struct to avoid manually defining entry copy constructor as we
> // should because the default one is not compatible with std::atomic_bool.
> struct Atomic {
>     Atomic() = default;
>     Atomic(const Atomic& e) { ready = e.ready.load(); } // MSVC 2013 wants assignment within body
>     std::atomic_bool ready;
> };
> 
> // We define types for the different parts of the WLDEntry and DTZEntry with
> // corresponding specializations for pieces or pawns.
> 
> struct WLDEntryPiece {
>     PairsData* precomp;
> };
> 
> struct WDLEntryPawn {
>     uint8_t pawnCount[2];     // [Lead color / other color]
>     WLDEntryPiece file[2][4]; // [wtm / btm][FILE_A..FILE_D]
> };
> 
> struct DTZEntryPiece {
>     PairsData* precomp;
>     uint16_t map_idx[4]; // WDLWin, WDLLoss, WDLCursedWin, WDLBlessedLoss
>     uint8_t* map;
> };
> 
> struct DTZEntryPawn {
>     uint8_t pawnCount[2];
>     DTZEntryPiece file[4];
>     uint8_t* map;
> };
> 
> struct TBEntry : public Atomic {
>     void* baseAddress;
>     uint64_t mapping;
>     Key key;
>     Key key2;
>     int pieceCount;
>     bool hasPawns;
>     bool hasUniquePieces;
> };
> 
> // Now the main types: WDLEntry and DTZEntry
> struct WDLEntry : public TBEntry {
>     WDLEntry(const std::string& code);
>    ~WDLEntry();
>     union {
>         WLDEntryPiece pieceTable[2]; // [wtm / btm]
>         WDLEntryPawn  pawnTable;
>     };
> };
> 
> struct DTZEntry : public TBEntry {
>     DTZEntry(const WDLEntry& wdl);
>    ~DTZEntry();
>     union {
>         DTZEntryPiece pieceTable;
>         DTZEntryPawn  pawnTable;
>     };
> };
> 
> typedef decltype(WDLEntry::pieceTable) WDLPieceTable;
> typedef decltype(DTZEntry::pieceTable) DTZPieceTable;
> typedef decltype(WDLEntry::pawnTable ) WDLPawnTable;
> typedef decltype(DTZEntry::pawnTable ) DTZPawnTable;
> 
> auto item(WDLPieceTable& e, int stm, int  ) -> decltype(e[stm])& { return e[stm]; }
> auto item(DTZPieceTable& e, int    , int  ) -> decltype(e)& { return e; }
> auto item(WDLPawnTable&  e, int stm, int f) -> decltype(e.file[stm][f])& { return e.file[stm][f]; }
> auto item(DTZPawnTable&  e, int    , int f) -> decltype(e.file[f])& { return e.file[f]; }
> 
> template<typename E> struct Ret { typedef int type; };
> template<> struct Ret<WDLEntry> { typedef WDLScore type; };
> 
> int MapPawns[SQUARE_NB];
> int MapB1H1H7[SQUARE_NB];
> int MapA1D1D4[SQUARE_NB];
> int MapKK[10][SQUARE_NB]; // [MapA1D1D4][SQUARE_NB]
> 
> // Comparison function to sort leading pawns in ascending MapPawns[] order
> bool pawns_comp(Square i, Square j) { return MapPawns[i] < MapPawns[j]; }
> int off_A1H8(Square sq) { return int(rank_of(sq)) - file_of(sq); }
> 
> const Value WDL_to_value[] = {
>    -VALUE_MATE + MAX_PLY + 1,
>     VALUE_DRAW - 2,
>     VALUE_DRAW,
>     VALUE_DRAW + 2,
>     VALUE_MATE - MAX_PLY - 1
> };
> 
> const std::string PieceToChar = " PNBRQK  pnbrqk";
> 
> int Binomial[6][SQUARE_NB];    // [k][n] k elements from a set of n elements
> int LeadPawnIdx[5][SQUARE_NB]; // [leadPawnsCnt][SQUARE_NB]
> int LeadPawnsSize[5][4];       // [leadPawnsCnt][FILE_A..FILE_D]
> 
> enum { BigEndian, LittleEndian };
> 
> template<typename T, int Half = sizeof(T) / 2, int End = sizeof(T) - 1>
> inline void swap_byte(T& x)
77,100c230,232
<   int color;
<   PieceType pt;
<   int i;
<   uint64 key = 0;
< 
<   color = !mirror ? 0 : 8;
<   for (pt = PAWN; pt <= KING; ++pt)
<     for (i = 0; i < pcs[color + pt]; i++)
<       key ^= Zobrist::psq[WHITE][pt][i];
<   color ^= 8;
<   for (pt = PAWN; pt <= KING; ++pt)
<     for (i = 0; i < pcs[color + pt]; i++)
<       key ^= Zobrist::psq[BLACK][pt][i];
< 
<   return key;
< }
< 
< bool is_little_endian() {
<   union {
<     int i;
<     char c[sizeof(int)];
<   } x;
<   x.i = 1;
<   return x.c[0] == 1;
---
>     char tmp, *c = (char*)&x;
>     for (int i = 0; i < Half; ++i)
>         tmp = c[i], c[i] = c[End - i], c[End - i] = tmp;
101a234
> template<> inline void swap_byte<uint8_t, 0, 0>(uint8_t&) {}
103c236
< static ubyte decompress_pairs(struct PairsData *d, uint64 idx)
---
> template<typename T, int LE> T number(void* addr)
105,107c238,250
<   static const bool isLittleEndian = is_little_endian();
<   return isLittleEndian ? decompress_pairs<true >(d, idx)
<                         : decompress_pairs<false>(d, idx);
---
>     const union { uint32_t i; char c[4]; } Le = { 0x01020304 };
>     const bool IsLittleEndian = (Le.c[0] == 4);
> 
>     T v;
> 
>     if ((uintptr_t)addr & (alignof(T) - 1)) // Unaligned pointer (very rare)
>         std::memcpy(&v, addr, sizeof(T));
>     else
>         v = *((T*)addr);
> 
>     if (LE != IsLittleEndian)
>         swap_byte(v);
>     return v;
110,133c253,288
< // probe_wdl_table and probe_dtz_table require similar adaptations.
< static int probe_wdl_table(Position& pos, int *success)
< {
<   struct TBEntry *ptr;
<   struct TBHashEntry *ptr2;
<   uint64 idx;
<   uint64 key;
<   int i;
<   ubyte res;
<   int p[TBPIECES];
< 
<   // Obtain the position's material signature key.
<   key = pos.material_key();
< 
<   // Test for KvK.
<   if (key == (Zobrist::psq[WHITE][KING][0] ^ Zobrist::psq[BLACK][KING][0]))
<     return 0;
< 
<   ptr2 = TB_hash[key >> (64 - TBHASHBITS)];
<   for (i = 0; i < HSHMAX; i++)
<     if (ptr2[i].key == key) break;
<   if (i == HSHMAX) {
<     *success = 0;
<     return 0;
---
> class HashTable {
> 
>     typedef std::pair<WDLEntry*, DTZEntry*> EntryPair;
>     typedef std::pair<Key, EntryPair> Entry;
> 
>     static const int TBHASHBITS = 10;
>     static const int HSHMAX     = 5;
> 
>     Entry hashTable[1 << TBHASHBITS][HSHMAX];
> 
>     std::deque<WDLEntry> wdlTable;
>     std::deque<DTZEntry> dtzTable;
> 
>     void insert(Key key, WDLEntry* wdl, DTZEntry* dtz) {
>         Entry* entry = hashTable[key >> (64 - TBHASHBITS)];
> 
>         for (int i = 0; i < HSHMAX; ++i, ++entry)
>             if (!entry->second.first || entry->first == key) {
>                 *entry = std::make_pair(key, std::make_pair(wdl, dtz));
>                 return;
>             }
> 
>         std::cerr << "HSHMAX too low!" << std::endl;
>         exit(1);
>     }
> 
> public:
>     template<typename E, int I = std::is_same<E, WDLEntry>::value ? 0 : 1>
>     E* get(Key key) {
>       Entry* entry = hashTable[key >> (64 - TBHASHBITS)];
> 
>       for (int i = 0; i < HSHMAX; ++i, ++entry)
>           if (entry->first == key)
>               return std::get<I>(entry->second);
> 
>       return nullptr;
136,150c291,318
<   ptr = ptr2[i].ptr;
<   if (!ptr->ready) {
<     LOCK(TB_mutex);
<     if (!ptr->ready) {
<       char str[16];
<       prt_str(pos, str, ptr->key != key);
<       if (!init_table_wdl(ptr, str)) {
<         ptr2[i].key = 0ULL;
<         *success = 0;
<         UNLOCK(TB_mutex);
<         return 0;
<       }
<       // Memory barrier to ensure ptr->ready = 1 is not reordered.
< #ifdef _MSC_VER
<       _ReadWriteBarrier();
---
>   void clear() {
>       std::memset(hashTable, 0, sizeof(hashTable));
>       wdlTable.clear();
>       dtzTable.clear();
>   }
>   size_t size() const { return wdlTable.size(); }
>   void insert(const std::vector<PieceType>& pieces);
> };
> 
> HashTable EntryTable;
> 
> class TBFile : public std::ifstream {
> 
>     std::string fname;
> 
> public:
>     // Look for and open the file among the Paths directories where the .rtbw
>     // and .rtbz files can be found. Multiple directories are separated by ";"
>     // on Windows and by ":" on Unix-based operating systems.
>     //
>     // Example:
>     // C:\tb\wdl345;C:\tb\wdl6;D:\tb\dtz345;D:\tb\dtz6
>     static std::string Paths;
> 
>     TBFile(const std::string& f) {
> 
> #ifndef _WIN32
>         const char SepChar = ':';
152c320
<       __asm__ __volatile__ ("" ::: "memory");
---
>         const char SepChar = ';';
154c322,330
<       ptr->ready = 1;
---
>         std::stringstream ss(Paths);
>         std::string path;
> 
>         while (std::getline(ss, path, SepChar)) {
>             fname = path + "/" + f;
>             std::ifstream::open(fname);
>             if (is_open())
>                 return;
>         }
156,157d331
<     UNLOCK(TB_mutex);
<   }
159,173c333,367
<   int bside, mirror, cmirror;
<   if (!ptr->symmetric) {
<     if (key != ptr->key) {
<       cmirror = 8;
<       mirror = 0x38;
<       bside = (pos.side_to_move() == WHITE);
<     } else {
<       cmirror = mirror = 0;
<       bside = !(pos.side_to_move() == WHITE);
<     }
<   } else {
<     cmirror = pos.side_to_move() == WHITE ? 0 : 8;
<     mirror = pos.side_to_move() == WHITE ? 0 : 0x38;
<     bside = 0;
<   }
---
>     // Memory map the file and check it. File should be already open and will be
>     // closed after mapping.
>     uint8_t* map(void** baseAddress, uint64_t* mapping, const uint8_t* TB_MAGIC) {
> 
>         assert(is_open());
> 
>         close(); // Need to re-open to get native file descriptor
> 
> #ifndef _WIN32
>         struct stat statbuf;
>         int fd = ::open(fname.c_str(), O_RDONLY);
>         fstat(fd, &statbuf);
>         *mapping = statbuf.st_size;
>         *baseAddress = mmap(nullptr, statbuf.st_size, PROT_READ, MAP_SHARED, fd, 0);
>         ::close(fd);
> 
>         if (*baseAddress == MAP_FAILED) {
>             std::cerr << "Could not mmap() " << fname << std::endl;
>             exit(1);
>         }
> #else
>         HANDLE fd = CreateFile(fname.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr,
>                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
>         DWORD size_high;
>         DWORD size_low = GetFileSize(fd, &size_high);
>         HANDLE mmap = CreateFileMapping(fd, nullptr, PAGE_READONLY, size_high, size_low, nullptr);
>         CloseHandle(fd);
> 
>         if (!mmap) {
>             std::cerr << "CreateFileMapping() failed" << std::endl;
>             exit(1);
>         }
> 
>         *mapping = (uint64_t)mmap;
>         *baseAddress = MapViewOfFile(mmap, FILE_MAP_READ, 0, 0, 0);
175,205c369,428
<   // p[i] is to contain the square 0-63 (A1-H8) for a piece of type
<   // pc[i] ^ cmirror, where 1 = white pawn, ..., 14 = black king.
<   // Pieces of the same type are guaranteed to be consecutive.
<   if (!ptr->has_pawns) {
<     struct TBEntry_piece *entry = (struct TBEntry_piece *)ptr;
<     ubyte *pc = entry->pieces[bside];
<     for (i = 0; i < entry->num;) {
<       Bitboard bb = pos.pieces((Color)((pc[i] ^ cmirror) >> 3),
<                                       (PieceType)(pc[i] & 0x07));
<       do {
<         p[i++] = pop_lsb(&bb);
<       } while (bb);
<     }
<     idx = encode_piece(entry, entry->norm[bside], p, entry->factor[bside]);
<     res = decompress_pairs(entry->precomp[bside], idx);
<   } else {
<     struct TBEntry_pawn *entry = (struct TBEntry_pawn *)ptr;
<     int k = entry->file[0].pieces[0][0] ^ cmirror;
<     Bitboard bb = pos.pieces((Color)(k >> 3), (PieceType)(k & 0x07));
<     i = 0;
<     do {
<       p[i++] = pop_lsb(&bb) ^ mirror;
<     } while (bb);
<     int f = pawn_file(entry, p);
<     ubyte *pc = entry->file[f].pieces[bside];
<     for (; i < entry->num;) {
<       bb = pos.pieces((Color)((pc[i] ^ cmirror) >> 3),
<                                     (PieceType)(pc[i] & 0x07));
<       do {
<         p[i++] = pop_lsb(&bb) ^ mirror;
<       } while (bb);
---
>         if (!*baseAddress) {
>             std::cerr << "MapViewOfFile() failed, name = " << fname
>                       << ", error = " << GetLastError() << std::endl;
>             exit(1);
>         }
> #endif
>         uint8_t* data = (uint8_t*)*baseAddress;
> 
>         if (   *data++ != *TB_MAGIC++
>             || *data++ != *TB_MAGIC++
>             || *data++ != *TB_MAGIC++
>             || *data++ != *TB_MAGIC) {
>             std::cerr << "Corrupted table in file " << fname << std::endl;
>             unmap(*baseAddress, *mapping);
>             *baseAddress = nullptr;
>             return nullptr;
>         }
> 
>         return data;
>     }
> 
>     static void unmap(void* baseAddress, uint64_t mapping) {
> 
> #ifndef _WIN32
>         munmap(baseAddress, mapping);
> #else
>         UnmapViewOfFile(baseAddress);
>         CloseHandle((HANDLE)mapping);
> #endif
>     }
> };
> 
> std::string TBFile::Paths;
> 
> WDLEntry::WDLEntry(const std::string& code) {
> 
>     StateInfo st;
>     Position pos;
> 
>     memset(this, 0, sizeof(WDLEntry));
> 
>     ready = false;
>     key = pos.set(code, WHITE, &st).material_key();
>     pieceCount = popcount(pos.pieces());
>     hasPawns = pos.pieces(PAWN);
> 
>     for (Color c = WHITE; c <= BLACK; ++c)
>         for (PieceType pt = PAWN; pt < KING; ++pt)
>             if (popcount(pos.pieces(c, pt)) == 1)
>                 hasUniquePieces = true;
> 
>     if (hasPawns) {
>         // Set the leading color. In case both sides have pawns the leading color
>         // is the side with less pawns because this leads to better compression.
>         bool c =   !pos.count<PAWN>(BLACK)
>                 || (   pos.count<PAWN>(WHITE)
>                     && pos.count<PAWN>(BLACK) >= pos.count<PAWN>(WHITE));
> 
>         pawnTable.pawnCount[0] = pos.count<PAWN>(c ? WHITE : BLACK);
>         pawnTable.pawnCount[1] = pos.count<PAWN>(c ? BLACK : WHITE);
207,209d429
<     idx = encode_pawn(entry, entry->file[f].norm[bside], p, entry->file[f].factor[bside]);
<     res = decompress_pairs(entry->file[f].precomp[bside], idx);
<   }
211c431
<   return ((int)res) - 2;
---
>     key2 = pos.set(code, BLACK, &st).material_key();
214,248c434,460
< static int probe_dtz_table(Position& pos, int wdl, int *success)
< {
<   struct TBEntry *ptr;
<   uint64 idx;
<   int i, res;
<   int p[TBPIECES];
< 
<   // Obtain the position's material signature key.
<   uint64 key = pos.material_key();
< 
<   if (DTZ_table[0].key1 != key && DTZ_table[0].key2 != key) {
<     for (i = 1; i < DTZ_ENTRIES; i++)
<       if (DTZ_table[i].key1 == key) break;
<     if (i < DTZ_ENTRIES) {
<       struct DTZTableEntry table_entry = DTZ_table[i];
<       for (; i > 0; i--)
<         DTZ_table[i] = DTZ_table[i - 1];
<       DTZ_table[0] = table_entry;
<     } else {
<       struct TBHashEntry *ptr2 = TB_hash[key >> (64 - TBHASHBITS)];
<       for (i = 0; i < HSHMAX; i++)
<         if (ptr2[i].key == key) break;
<       if (i == HSHMAX) {
<         *success = 0;
<         return 0;
<       }
<       ptr = ptr2[i].ptr;
<       char str[16];
<       int mirror = (ptr->key != key);
<       prt_str(pos, str, mirror);
<       if (DTZ_table[DTZ_ENTRIES - 1].entry)
<         free_dtz_entry(DTZ_table[DTZ_ENTRIES-1].entry);
<       for (i = DTZ_ENTRIES - 1; i > 0; i--)
<         DTZ_table[i] = DTZ_table[i - 1];
<       load_dtz_table(str, calc_key(pos, mirror), calc_key(pos, !mirror));
---
> WDLEntry::~WDLEntry() {
> 
>     if (baseAddress)
>         TBFile::unmap(baseAddress, mapping);
> 
>     for (int i = 0; i < 2; ++i)
>         if (hasPawns)
>             for (File f = FILE_A; f <= FILE_D; ++f)
>                 delete pawnTable.file[i][f].precomp;
>         else
>             delete pieceTable[i].precomp;
> }
> 
> DTZEntry::DTZEntry(const WDLEntry& wdl) {
> 
>     memset(this, 0, sizeof(DTZEntry));
> 
>     ready = false;
>     key = wdl.key;
>     key2 = wdl.key2;
>     pieceCount = wdl.pieceCount;
>     hasPawns = wdl.hasPawns;
>     hasUniquePieces = wdl.hasUniquePieces;
> 
>     if (hasPawns) {
>         pawnTable.pawnCount[0] = wdl.pawnTable.pawnCount[0];
>         pawnTable.pawnCount[1] = wdl.pawnTable.pawnCount[1];
250c462
<   }
---
> }
252,256c464
<   ptr = DTZ_table[0].entry;
<   if (!ptr) {
<     *success = 0;
<     return 0;
<   }
---
> DTZEntry::~DTZEntry() {
258,272c466,486
<   int bside, mirror, cmirror;
<   if (!ptr->symmetric) {
<     if (key != ptr->key) {
<       cmirror = 8;
<       mirror = 0x38;
<       bside = (pos.side_to_move() == WHITE);
<     } else {
<       cmirror = mirror = 0;
<       bside = !(pos.side_to_move() == WHITE);
<     }
<   } else {
<     cmirror = pos.side_to_move() == WHITE ? 0 : 8;
<     mirror = pos.side_to_move() == WHITE ? 0 : 0x38;
<     bside = 0;
<   }
---
>     if (baseAddress)
>         TBFile::unmap(baseAddress, mapping);
> 
>     if (hasPawns)
>         for (File f = FILE_A; f <= FILE_D; ++f)
>             delete pawnTable.file[f].precomp;
>     else
>         delete pieceTable.precomp;
> }
> 
> void HashTable::insert(const std::vector<PieceType>& pieces) {
> 
>     std::string code;
> 
>     for (PieceType pt : pieces)
>         code += PieceToChar[pt];
> 
>     TBFile file(code.insert(code.find('K', 1), "v") + ".rtbw"); // KRK -> KRvK
> 
>     if (!file.is_open())
>         return;
274,315c488,620
<   if (!ptr->has_pawns) {
<     struct DTZEntry_piece *entry = (struct DTZEntry_piece *)ptr;
<     if ((entry->flags & 1) != bside && !entry->symmetric) {
<       *success = -1;
<       return 0;
<     }
<     ubyte *pc = entry->pieces;
<     for (i = 0; i < entry->num;) {
<       Bitboard bb = pos.pieces((Color)((pc[i] ^ cmirror) >> 3),
<                                     (PieceType)(pc[i] & 0x07));
<       do {
<         p[i++] = pop_lsb(&bb);
<       } while (bb);
<     }
<     idx = encode_piece((struct TBEntry_piece *)entry, entry->norm, p, entry->factor);
<     res = decompress_pairs(entry->precomp, idx);
< 
<     if (entry->flags & 2)
<       res = entry->map[entry->map_idx[wdl_to_map[wdl + 2]] + res];
< 
<     if (!(entry->flags & pa_flags[wdl + 2]) || (wdl & 1))
<       res *= 2;
<   } else {
<     struct DTZEntry_pawn *entry = (struct DTZEntry_pawn *)ptr;
<     int k = entry->file[0].pieces[0] ^ cmirror;
<     Bitboard bb = pos.pieces((Color)(k >> 3), (PieceType)(k & 0x07));
<     i = 0;
<     do {
<       p[i++] = pop_lsb(&bb) ^ mirror;
<     } while (bb);
<     int f = pawn_file((struct TBEntry_pawn *)entry, p);
<     if ((entry->flags[f] & 1) != bside) {
<       *success = -1;
<       return 0;
<     }
<     ubyte *pc = entry->file[f].pieces;
<     for (; i < entry->num;) {
<       bb = pos.pieces((Color)((pc[i] ^ cmirror) >> 3),
<                             (PieceType)(pc[i] & 0x07));
<       do {
<         p[i++] = pop_lsb(&bb) ^ mirror;
<       } while (bb);
---
>     file.close();
> 
>     MaxCardinality = std::max((int)pieces.size(), MaxCardinality);
> 
>     wdlTable.push_back(WDLEntry(code));
>     dtzTable.push_back(DTZEntry(wdlTable.back()));
> 
>     insert(wdlTable.back().key , &wdlTable.back(), &dtzTable.back());
>     insert(wdlTable.back().key2, &wdlTable.back(), &dtzTable.back());
> }
> 
> // TB tables are compressed with canonical Huffman code. The compressed data is divided into
> // blocks of size d->sizeofBlock, and each block stores a variable number of symbols.
> // Each symbol represents either a WDL or a (remapped) DTZ value, or a pair of other symbols
> // (recursively). If you keep expanding the symbols in a block, you end up with up to 65536
> // WDL or DTZ values. Each symbol represents up to 256 values and will correspond after
> // Huffman coding to at least 1 bit. So a block of 32 bytes corresponds to at most
> // 32 x 8 x 256 = 65536 values. This maximum is only reached for tables that consist mostly
> // of draws or mostly of wins, but such tables are actually quite common. In principle, the
> // blocks in WDL tables are 64 bytes long (and will be aligned on cache lines). But for
> // mostly-draw or mostly-win tables this can leave many 64-byte blocks only half-filled, so
> // in such cases blocks are 32 bytes long. The blocks of DTZ tables are up to 1024 bytes long.
> // The generator picks the size that leads to the smallest table. The "book" of symbols and
> // Huffman codes is the same for all blocks in the table. A non-symmetric pawnless TB file
> // will have one table for wtm and one for btm, a TB file with pawns will have tables per
> // file a,b,c,d also in this case one set for wtm and one for btm.
> int decompress_pairs(PairsData* d, uint64_t idx) {
> 
>     // Special case where all table positions store the same value
>     if (d->flags & TBFlag::SingleValue)
>         return d->minSymLen;
> 
>     // First we need to locate the right block that stores the value at index "idx".
>     // Because each block n stores blockLength[n] + 1 values, the index i of the block
>     // that contains the value at position idx is:
>     //
>     //                    for (i = -1, sum = 0; sum <= idx; i++)
>     //                        sum += blockLength[i + 1] + 1;
>     //
>     // This can be slow, so we use SparseIndex[] populated with a set of SparseEntry that
>     // point to known indices into blockLength[]. Namely SparseIndex[k] is a SparseEntry
>     // that stores the blockLength[] index and the offset within that block of the value
>     // with index I(k), where:
>     //
>     //       I(k) = k * d->span + d->span / 2      (1)
> 
>     // First step is to get the 'k' of the I(k) nearest to our idx, using defintion (1)
>     uint32_t k = idx / d->span;
> 
>     // Then we read the corresponding SparseIndex[] entry
>     uint32_t block = number<uint32_t, LittleEndian>(&d->sparseIndex[k].block);
>     int offset     = number<uint16_t, LittleEndian>(&d->sparseIndex[k].offset);
> 
>     // Now compute the difference idx - I(k). From defintion of k we know that
>     //
>     //       idx = k * d->span + idx % d->span    (2)
>     //
>     // So from (1) and (2) we can compute idx - I(K):
>     int diff = idx % d->span - d->span / 2;
> 
>     // Sum the above to offset to find the offset corresponding to our idx
>     offset += diff;
> 
>     // Move to previous/next block, until we reach the correct block that contains idx,
>     // that is when 0 <= offset <= d->blockLength[block]
>     while (offset < 0)
>         offset += d->blockLength[--block] + 1;
> 
>     while (offset > d->blockLength[block])
>         offset -= d->blockLength[block++] + 1;
> 
>     // Finally, we find the start address of our block of canonical Huffman symbols
>     uint32_t* ptr = (uint32_t*)(d->data + block * d->sizeofBlock);
> 
>     // Read the first 64 bits in our block, this is a (truncated) sequence of
>     // unknown number of symbols of unknown length but we know the first one
>     // is at the beginning of this 64 bits sequence.
>     uint64_t buf64 = number<uint64_t, BigEndian>(ptr); ptr += 2;
>     int buf64Size = 64;
>     Sym sym;
> 
>     while (true) {
>         int len = 0; // This is the symbol length - d->min_sym_len
> 
>         // Now get the symbol length. For any symbol s64 of length l right-padded
>         // to 64 bits we know that d->base64[l-1] >= s64 >= d->base64[l] so we
>         // can find the symbol length iterating through base64[].
>         while (buf64 < d->base64[len])
>             ++len;
> 
>         // All the symbols of a given length are consecutive integers (numerical
>         // sequence property), so we can compute the offset of our symbol of
>         // length len, stored at the beginning of buf64.
>         sym = (buf64 - d->base64[len]) >> (64 - len - d->minSymLen);
> 
>         // Now add the value of the lowest symbol of length len to get our symbol
>         sym += number<Sym, LittleEndian>(&d->lowestSym[len]);
> 
>         // If our offset is within the number of values represented by symbol sym
>         // we are done...
>         if (offset < d->symlen[sym] + 1)
>             break;
> 
>         // ...otherwise update the offset and continue to iterate
>         offset -= d->symlen[sym] + 1;
>         len += d->minSymLen; // Get the real length
>         buf64 <<= len;       // Consume the just processed symbol
>         buf64Size -= len;
> 
>         if (buf64Size <= 32) { // Refill the buffer
>             buf64Size += 32;
>             buf64 |= (uint64_t)number<uint32_t, BigEndian>(ptr++) << (64 - buf64Size);
>         }
>     }
> 
>     // Ok, now we have our symbol that expands into d->symlen[sym] + 1 symbols.
>     // We binary-search for our value recursively expanding into the left and
>     // right child symbols until we reach a leaf node where symlen[sym] + 1 == 1
>     // that will store the value we need.
>     while (d->symlen[sym]) {
> 
>         Sym left = d->btree[sym].get<LR::Left>();
> 
>         // If a symbol contains 36 sub-symbols (d->symlen[sym] + 1 = 36) and
>         // expands in a pair (d->symlen[left] = 23, d->symlen[right] = 11), then
>         // we know that, for instance the ten-th value (offset = 10) will be on
>         // the left side because in Recursive Pairing child symbols are adjacent.
>         if (offset < d->symlen[left] + 1)
>             sym = left;
>         else {
>             offset -= d->symlen[left] + 1;
>             sym = d->btree[sym].get<LR::Right>();
>         }
317,318d621
<     idx = encode_pawn((struct TBEntry_pawn *)entry, entry->file[f].norm, p, entry->file[f].factor);
<     res = decompress_pairs(entry->file[f].precomp, idx);
320,321c623,624
<     if (entry->flags[f] & 2)
<       res = entry->map[entry->map_idx[f][wdl_to_map[wdl + 2]] + res];
---
>     return d->btree[sym].get<LR::Value>();
> }
323,325c626,628
<     if (!(entry->flags[f] & pa_flags[wdl + 2]) || (wdl & 1))
<       res *= 2;
<   }
---
> bool check_dtz_stm(WDLEntry*, int, File) { return true; }
> 
> bool check_dtz_stm(DTZEntry* entry, int stm, File f) {
327c630,634
<   return res;
---
>     int flags = entry->hasPawns ? entry->pawnTable.file[f].precomp->flags
>                                 : entry->pieceTable.precomp->flags;
> 
>     return   (flags & TBFlag::STM) == stm
>           || ((entry->key == entry->key2) && !entry->hasPawns);
330,333c637,879
< // Add underpromotion captures to list of captures.
< static ExtMove *add_underprom_caps(Position& pos, ExtMove *stack, ExtMove *end)
< {
<   ExtMove *moves, *extra = end;
---
> // DTZ scores are sorted by frequency of occurrence and then assigned the
> // values 0, 1, 2, ... in order of decreasing frequency. This is done for each
> // of the four WDLScore values. The mapping information necessary to reconstruct
> // the original values is stored in the TB file and read during map[] init.
> WDLScore map_score(WDLEntry*, File, int value, WDLScore) { return WDLScore(value - 2); }
> 
> int map_score(DTZEntry* entry, File f, int value, WDLScore wdl) {
> 
>     const int WDLMap[] = { 1, 3, 0, 2, 0 };
> 
>     int flags = entry->hasPawns ? entry->pawnTable.file[f].precomp->flags
>                                 : entry->pieceTable.precomp->flags;
> 
>     uint8_t* map = entry->hasPawns ? entry->pawnTable.map
>                                    : entry->pieceTable.map;
> 
>     uint16_t* idx = entry->hasPawns ? entry->pawnTable.file[f].map_idx
>                                     : entry->pieceTable.map_idx;
>     if (flags & TBFlag::Mapped)
>         value = map[idx[WDLMap[wdl + 2]] + value];
> 
>     // DTZ tables store distance to zero in number of moves or plies. We
>     // want to return plies, so we have convert to plies when needed.
>     if (   (wdl == WDLWin  && !(flags & TBFlag::WinPlies))
>         || (wdl == WDLLoss && !(flags & TBFlag::LossPlies))
>         ||  wdl == WDLCursedWin
>         ||  wdl == WDLBlessedLoss)
>         value *= 2;
> 
>     return value + 1;
> }
> 
> // Compute a unique index out of a position and use it to probe the TB file. To
> // encode k pieces of same type and color, first sort the pieces by square in
> // ascending order s1 <= s2 <= ... <= sk then compute the unique index as:
> //
> //      idx = Binomial[1][s1] + Binomial[2][s2] + ... + Binomial[k][sk]
> //
> template<typename Entry, typename T = typename Ret<Entry>::type>
> T do_probe_table(const Position& pos,  Entry* entry, WDLScore wdl, ProbeState* result) {
> 
>     const bool IsWDL = std::is_same<Entry, WDLEntry>::value;
> 
>     Square squares[TBPIECES];
>     Piece pieces[TBPIECES];
>     uint64_t idx;
>     int next = 0, size = 0, leadPawnsCnt = 0;
>     PairsData* d;
>     Bitboard b, leadPawns = 0;
>     File tbFile = FILE_A;
> 
>     // A given TB entry like KRK has associated two material keys: KRvk and Kvkr.
>     // If both sides have the same pieces keys are equal. In this case TB tables
>     // only store the 'white to move' case, so if the position to lookup has black
>     // to move, we need to switch the color and flip the squares before to lookup.
>     bool symmetricBlackToMove = (entry->key == entry->key2 && pos.side_to_move());
> 
>     // TB files are calculated for white as stronger side. For instance we have
>     // KRvK, not KvKR. A position where stronger side is white will have its
>     // material key == entry->key, otherwise we have to switch the color and
>     // flip the squares before to lookup.
>     bool blackStronger = (pos.material_key() != entry->key);
> 
>     int flipColor   = (symmetricBlackToMove || blackStronger) * 8;
>     int flipSquares = (symmetricBlackToMove || blackStronger) * 070;
>     int stm         = (symmetricBlackToMove || blackStronger) ^ pos.side_to_move();
> 
>     // For pawns, TB files store 4 separate tables according if leading pawn is on
>     // file a, b, c or d after reordering. The leading pawn is the one with maximum
>     // MapPawns[] value, that is the one most toward the edges and with lowest rank.
>     if (entry->hasPawns) {
> 
>         // In all the 4 tables, pawns are at the beginning of the piece sequence and
>         // their color is the reference one. So we just pick the first one.
>         Piece pc = Piece(item(entry->pawnTable, 0, 0).precomp->pieces[0] ^ flipColor);
> 
>         assert(type_of(pc) == PAWN);
> 
>         leadPawns = b = pos.pieces(color_of(pc), PAWN);
>         while (b)
>             squares[size++] = pop_lsb(&b) ^ flipSquares;
> 
>         leadPawnsCnt = size;
> 
>         std::swap(squares[0], *std::max_element(squares, squares + leadPawnsCnt, pawns_comp));
> 
>         tbFile = file_of(squares[0]);
>         if (tbFile > FILE_D)
>             tbFile = file_of(squares[0] ^ 7); // Horizontal flip: SQ_H1 -> SQ_A1
> 
>         d = item(entry->pawnTable , stm, tbFile).precomp;
>     } else
>         d = item(entry->pieceTable, stm, tbFile).precomp;
> 
>     // DTZ tables are one-sided, i.e. they store positions only for white to
>     // move or only for black to move, so check for side to move to be stm,
>     // early exit otherwise.
>     if (!IsWDL && !check_dtz_stm(entry, stm, tbFile))
>         return *result = CHANGE_STM, T();
> 
>     // Now we are ready to get all the position pieces (but the lead pawns) and
>     // directly map them to the correct color and square.
>     b = pos.pieces() ^ leadPawns;
>     while (b) {
>         Square s = pop_lsb(&b);
>         squares[size] = s ^ flipSquares;
>         pieces[size++] = Piece(pos.piece_on(s) ^ flipColor);
>     }
> 
>     // Then we reorder the pieces to have the same sequence as the one stored
>     // in precomp->pieces[i]: the sequence that ensures the best compression.
>     for (int i = leadPawnsCnt; i < size; ++i)
>         for (int j = i; j < size; ++j)
>             if (d->pieces[i] == pieces[j])
>             {
>                 std::swap(pieces[i], pieces[j]);
>                 std::swap(squares[i], squares[j]);
>                 break;
>             }
> 
>     // Now we map again the squares so that the square of the lead piece is in
>     // the triangle A1-D1-D4.
>     if (file_of(squares[0]) > FILE_D)
>         for (int i = 0; i < size; ++i)
>             squares[i] ^= 7; // Horizontal flip: SQ_H1 -> SQ_A1
> 
>     // Encode leading pawns starting with the one with minimum MapPawns[] and
>     // proceeding in ascending order.
>     if (entry->hasPawns) {
>         idx = LeadPawnIdx[leadPawnsCnt][squares[0]];
> 
>         std::sort(squares + 1, squares + leadPawnsCnt, pawns_comp);
> 
>         for (int i = 1; i < leadPawnsCnt; ++i)
>             idx += Binomial[i][MapPawns[squares[i]]];
> 
>         goto encode_remaining; // With pawns we have finished special treatments
>     }
> 
>     // In positions withouth pawns, we further flip the squares to ensure leading
>     // piece is below RANK_5.
>     if (rank_of(squares[0]) > RANK_4)
>         for (int i = 0; i < size; ++i)
>             squares[i] ^= 070; // Vertical flip: SQ_A8 -> SQ_A1
> 
>     // Look for the first piece of the leading group not on the A1-D4 diagonal
>     // and ensure it is mapped below the diagonal.
>     for (int i = 0; i < d->groupLen[0]; ++i) {
>         if (!off_A1H8(squares[i]))
>             continue;
> 
>         if (off_A1H8(squares[i]) > 0) // A1-H8 diagonal flip: SQ_A3 -> SQ_C3
>             for (int j = i; j < size; ++j)
>                 squares[j] = Square(((squares[j] >> 3) | (squares[j] << 3)) & 63);
>         break;
>     }
> 
>     // Encode the leading group.
>     //
>     // Suppose we have KRvK. Let's say the pieces are on square numbers wK, wR
>     // and bK (each 0...63). The simplest way to map this position to an index
>     // is like this:
>     //
>     //   index = wK * 64 * 64 + wR * 64 + bK;
>     //
>     // But this way the TB is going to have 64*64*64 = 262144 positions, with
>     // lots of positions being equivalent (because they are mirrors of each
>     // other) and lots of positions being invalid (two pieces on one square,
>     // adjacent kings, etc.).
>     // Usually the first step is to take the wK and bK together. There are just
>     // 462 ways legal and not-mirrored ways to place the wK and bK on the board.
>     // Once we have placed the wK and bK, there are 62 squares left for the wR
>     // Mapping its square from 0..63 to available squares 0..61 can be done like:
>     //
>     //   wR -= (wR > wK) + (wR > bK);
>     //
>     // In words: if wR "comes later" than wK, we deduct 1, and the same if wR
>     // "comes later" than bK. In case of two same pieces like KRRvK we want to
>     // place the two Rs "together". If we have 62 squares left, we can place two
>     // Rs "together" in 62 * 61 / 2 ways (we divide by 2 because rooks can be
>     // swapped and still get the same position.)
>     //
>     // In case we have at least 3 unique pieces (inlcuded kings) we encode them
>     // together.
>     if (entry->hasUniquePieces) {
> 
>         int adjust1 =  squares[1] > squares[0];
>         int adjust2 = (squares[2] > squares[0]) + (squares[2] > squares[1]);
> 
>         // First piece is below a1-h8 diagonal. MapA1D1D4[] maps the b1-d1-d3
>         // triangle to 0...5. There are 63 squares for second piece and and 62
>         // (mapped to 0...61) for the third.
>         if (off_A1H8(squares[0]))
>             idx = (   MapA1D1D4[squares[0]]  * 63
>                    + (squares[1] - adjust1)) * 62
>                    +  squares[2] - adjust2;
> 
>         // First piece is on a1-h8 diagonal, second below: map this occurence to
>         // 6 to differentiate from the above case, rank_of() maps a1-d4 diagonal
>         // to 0...3 and finally MapB1H1H7[] maps the b1-h1-h7 triangle to 0..27.
>         else if (off_A1H8(squares[1]))
>             idx = (  6 * 63 + rank_of(squares[0]) * 28
>                    + MapB1H1H7[squares[1]])       * 62
>                    + squares[2] - adjust2;
> 
>         // First two pieces are on a1-h8 diagonal, third below
>         else if (off_A1H8(squares[2]))
>             idx =  6 * 63 * 62 + 4 * 28 * 62
>                  +  rank_of(squares[0])        * 7 * 28
>                  + (rank_of(squares[1]) - adjust1) * 28
>                  +  MapB1H1H7[squares[2]];
> 
>         // All 3 pieces on the diagonal a1-h8
>         else
>             idx = 6 * 63 * 62 + 4 * 28 * 62 + 4 * 7 * 28
>                  +  rank_of(squares[0])         * 7 * 6
>                  + (rank_of(squares[1]) - adjust1)  * 6
>                  + (rank_of(squares[2]) - adjust2);
>     } else
>         // We don't have at least 3 unique pieces, like in KRRvKBB, just map
>         // the kings.
>         idx = MapKK[MapA1D1D4[squares[0]]][squares[1]];
> 
> encode_remaining:
>     idx *= d->groupIdx[0];
>     Square* groupSq = squares + d->groupLen[0];
> 
>     // Encode remainig pawns then pieces according to square, in ascending order
>     bool remainingPawns = entry->hasPawns && entry->pawnTable.pawnCount[1];
> 
>     while (d->groupLen[++next])
>     {
>         std::sort(groupSq, groupSq + d->groupLen[next]);
>         uint64_t n = 0;
> 
>         // Map down a square if "comes later" than a square in the previous
>         // groups (similar to what done earlier for leading group pieces).
>         for (int i = 0; i < d->groupLen[next]; ++i)
>         {
>             auto f = [&](Square s) { return groupSq[i] > s; };
>             auto adjust = std::count_if(squares, groupSq, f);
>             n += Binomial[i + 1][groupSq[i] - adjust - 8 * remainingPawns];
>         }
335,340c881,883
<   for (moves = stack; moves < end; moves++) {
<     Move move = moves->move;
<     if (type_of(move) == PROMOTION && !pos.empty(to_sq(move))) {
<       (*extra++).move = (Move)(move - (1 << 12));
<       (*extra++).move = (Move)(move - (2 << 12));
<       (*extra++).move = (Move)(move - (3 << 12));
---
>         remainingPawns = false;
>         idx += n * d->groupIdx[next];
>         groupSq += d->groupLen[next];
342d884
<   }
344c886,887
<   return extra;
---
>     // Now that we have the index, decompress the pair and get the score
>     return map_score(entry, tbFile, decompress_pairs(d, idx), wdl);
347,379c890,1054
< static int probe_ab(Position& pos, int alpha, int beta, int *success)
< {
<   int v;
<   ExtMove stack[64];
<   ExtMove *moves, *end;
<   StateInfo st;
< 
<   // Generate (at least) all legal non-ep captures including (under)promotions.
<   // It is OK to generate more, as long as they are filtered out below.
<   if (!pos.checkers()) {
<     end = generate<CAPTURES>(pos, stack);
<     // Since underpromotion captures are not included, we need to add them.
<     end = add_underprom_caps(pos, stack, end);
<   } else
<     end = generate<EVASIONS>(pos, stack);
< 
<   CheckInfo ci(pos);
< 
<   for (moves = stack; moves < end; moves++) {
<     Move capture = moves->move;
<     if (!pos.capture(capture) || type_of(capture) == ENPASSANT
<                         || !pos.legal(capture, ci.pinned))
<       continue;
<     pos.do_move(capture, st, ci, pos.gives_check(capture, ci));
<     v = -probe_ab(pos, -beta, -alpha, success);
<     pos.undo_move(capture);
<     if (*success == 0) return 0;
<     if (v > alpha) {
<       if (v >= beta) {
<         *success = 2;
<         return v;
<       }
<       alpha = v;
---
> // Group together pieces that will be encoded together. The general rule is that
> // a group contains pieces of same type and color. The exception is the leading
> // group that, in case of positions withouth pawns, can be formed by 3 different
> // pieces (default) or by the king pair when there is not a unique piece apart
> // from the kings. When there are pawns, pawns are always first in pieces[].
> //
> // As example KRKN -> KRK + N, KNNK -> KK + NN, KPPKP -> P + PP + K + K
> //
> // The actual grouping depends on the TB generator and can be inferred from the
> // sequence of pieces in piece[] array.
> template<typename T>
> void set_groups(T& e, PairsData* d, int order[], File f) {
> 
>     int n = 0, firstLen = e.hasPawns ? 0 : e.hasUniquePieces ? 3 : 2;
>     d->groupLen[n] = 1;
> 
>     // Number of pieces per group is stored in groupLen[], for instance in KRKN
>     // the encoder will default on '111', so groupLen[] will be (3, 1).
>     for (int i = 1; i < e.pieceCount; ++i)
>         if (--firstLen > 0 || d->pieces[i] == d->pieces[i - 1])
>             d->groupLen[n]++;
>         else
>             d->groupLen[++n] = 1;
> 
>     d->groupLen[++n] = 0; // Zero-terminated
> 
>     // The sequence in pieces[] defines the groups, but not the order in which
>     // they are encoded. If the pieces in a group g can be combined on the board
>     // in N(g) different ways, then the position encoding will be of the form:
>     //
>     //           g1 * N(g2) * N(g3) + g2 * N(g3) + g3
>     //
>     // This ensures unique encoding for the whole position. The order of the
>     // groups is a per-table parameter and could not follow the canonical leading
>     // pawns/pieces -> remainig pawns -> remaining pieces. In particular the
>     // first group is at order[0] position and the remaining pawns, when present,
>     // are at order[1] position.
>     bool pp = e.hasPawns && e.pawnTable.pawnCount[1]; // Pawns on both sides
>     int next = pp ? 2 : 1;
>     int freeSquares = 64 - d->groupLen[0] - (pp ? d->groupLen[1] : 0);
>     uint64_t idx = 1;
> 
>     for (int k = 0; next < n || k == order[0] || k == order[1]; ++k)
>         if (k == order[0]) // Leading pawns or pieces
>         {
>             d->groupIdx[0] = idx;
>             idx *=         e.hasPawns ? LeadPawnsSize[d->groupLen[0]][f]
>                   : e.hasUniquePieces ? 31332 : 462;
>         }
>         else if (k == order[1]) // Remaining pawns
>         {
>             d->groupIdx[1] = idx;
>             idx *= Binomial[d->groupLen[1]][48 - d->groupLen[0]];
>         }
>         else // Remainig pieces
>         {
>             d->groupIdx[next] = idx;
>             idx *= Binomial[d->groupLen[next]][freeSquares];
>             freeSquares -= d->groupLen[next++];
>         }
> 
>     d->groupIdx[n] = idx;
> }
> 
> // In Recursive Pairing each symbol represents a pair of childern symbols. So
> // read d->btree[] symbols data and expand each one in his left and right child
> // symbol until reaching the leafs that represent the symbol value.
> uint8_t set_symlen(PairsData* d, Sym s, std::vector<bool>& visited) {
> 
>     visited[s] = true; // We can set it now because tree is acyclic
>     Sym sr = d->btree[s].get<LR::Right>();
> 
>     if (sr == 0xFFF)
>         return 0;
> 
>     Sym sl = d->btree[s].get<LR::Left>();
> 
>     if (!visited[sl])
>         d->symlen[sl] = set_symlen(d, sl, visited);
> 
>     if (!visited[sr])
>         d->symlen[sr] = set_symlen(d, sr, visited);
> 
>     return d->symlen[sl] + d->symlen[sr] + 1;
> }
> 
> uint8_t* set_sizes(PairsData* d, uint8_t* data) {
> 
>     d->flags = *data++;
> 
>     if (d->flags & TBFlag::SingleValue) {
>         d->blocksNum = d->span =
>         d->blockLengthSize = d->sparseIndexSize = 0; // Broken MSVC zero-init
>         d->minSymLen = *data++; // Here we store the single value
>         return data;
>     }
> 
>     // groupLen[] is a zero-terminated list of group lengths, the last groupIdx[]
>     // element stores the biggest index that is the tb size.
>     uint64_t tbSize = d->groupIdx[std::find(d->groupLen, d->groupLen + 7, 0) - d->groupLen];
> 
>     d->sizeofBlock = 1ULL << *data++;
>     d->span = 1ULL << *data++;
>     d->sparseIndexSize = (tbSize + d->span - 1) / d->span; // Round up
>     int padding = number<uint8_t, LittleEndian>(data++);
>     d->blocksNum = number<uint32_t, LittleEndian>(data); data += sizeof(uint32_t);
>     d->blockLengthSize = d->blocksNum + padding; // Padded to ensure SparseIndex[]
>                                                  // does not point out of range.
>     d->maxSymLen = *data++;
>     d->minSymLen = *data++;
>     d->lowestSym = (Sym*)data;
>     d->base64.resize(d->maxSymLen - d->minSymLen + 1);
> 
>     // The canonical code is ordered such that longer symbols (in terms of
>     // the number of bits of their Huffman code) have lower numeric value,
>     // so that d->lowestSym[i] >= d->lowestSym[i+1] (when read as LittleEndian).
>     // Starting from this we compute a base64[] table indexed by symbol length
>     // and containing 64 bit values so that d->base64[i] >= d->base64[i+1].
>     // See http://www.eecs.harvard.edu/~michaelm/E210/huffman.pdf
>     for (int i = d->base64.size() - 2; i >= 0; --i) {
>         d->base64[i] = (d->base64[i + 1] + number<Sym, LittleEndian>(&d->lowestSym[i])
>                                          - number<Sym, LittleEndian>(&d->lowestSym[i + 1])) / 2;
> 
>         assert(d->base64[i] * 2 >= d->base64[i+1]);
>     }
> 
>     // Now left-shift by an amount so that d->base64[i] gets shifted 1 bit more
>     // than d->base64[i+1] and given the above assert condition, we ensure that
>     // d->base64[i] >= d->base64[i+1]. Moreover for any symbol s64 of length i
>     // and right-padded to 64 bits holds d->base64[i-1] >= s64 >= d->base64[i].
>     for (size_t i = 0; i < d->base64.size(); ++i)
>         d->base64[i] <<= 64 - i - d->minSymLen; // Right-padding to 64 bits
> 
>     data += d->base64.size() * sizeof(Sym);
>     d->symlen.resize(number<uint16_t, LittleEndian>(data)); data += sizeof(uint16_t);
>     d->btree = (LR*)data;
> 
>     // The comrpession scheme used is "Recursive Pairing", that replaces the most
>     // frequent adjacent pair of symbols in the source message by a new symbol,
>     // reevaluating the frequencies of all of the symbol pairs with respect to
>     // the extended alphabet, and then repeating the process.
>     // See http://www.larsson.dogma.net/dcc99.pdf
>     std::vector<bool> visited(d->symlen.size());
> 
>     for (Sym sym = 0; sym < d->symlen.size(); ++sym)
>         if (!visited[sym])
>             d->symlen[sym] = set_symlen(d, sym, visited);
> 
>     return data + d->symlen.size() * sizeof(LR) + (d->symlen.size() & 1);
> }
> 
> template<typename T>
> uint8_t* set_dtz_map(WDLEntry&, T&, uint8_t*, File) { return nullptr; }
> 
> template<typename T>
> uint8_t* set_dtz_map(DTZEntry&, T& p, uint8_t* data, File maxFile) {
> 
>     p.map = data;
> 
>     for (File f = FILE_A; f <= maxFile; ++f) {
>         if (item(p, 0, f).precomp->flags & TBFlag::Mapped)
>             for (int i = 0; i < 4; ++i) { // Sequence like 3,x,x,x,1,x,0,2,x,x
>                 item(p, 0, f).map_idx[i] = (uint16_t)(data - p.map + 1);
>                 data += *data + 1;
>             }
381d1055
<   }
383,391c1057
<   v = probe_wdl_table(pos, success);
<   if (*success == 0) return 0;
<   if (alpha >= v) {
<     *success = 1 + (alpha > 0);
<     return alpha;
<   } else {
<     *success = 1;
<     return v;
<   }
---
>     return data += (uintptr_t)data & 1; // Word alignment
394,404c1060,1061
< // Probe the WDL table for a particular position.
< // If *success != 0, the probe was successful.
< // The return value is from the point of view of the side to move:
< // -2 : loss
< // -1 : loss, but draw under 50-move rule
< //  0 : draw
< //  1 : win, but draw under 50-move rule
< //  2 : win
< int Tablebases::probe_wdl(Position& pos, int *success)
< {
<   int v;
---
> template<typename Entry, typename T>
> void do_init(Entry& e, T& p, uint8_t* data) {
406,407c1063
<   *success = 1;
<   v = probe_ab(pos, -2, 2, success);
---
>     const bool IsWDL = std::is_same<Entry, WDLEntry>::value;
409,412c1065
<   // If en passant is not possible, we are done.
<   if (pos.ep_square() == SQ_NONE)
<     return v;
<   if (!(*success)) return 0;
---
>     PairsData* d;
414,453c1067,1110
<   // Now handle en passant.
<   int v1 = -3;
<   // Generate (at least) all legal en passant captures.
<   ExtMove stack[192];
<   ExtMove *moves, *end;
<   StateInfo st;
< 
<   if (!pos.checkers())
<     end = generate<CAPTURES>(pos, stack);
<   else
<     end = generate<EVASIONS>(pos, stack);
< 
<   CheckInfo ci(pos);
< 
<   for (moves = stack; moves < end; moves++) {
<     Move capture = moves->move;
<     if (type_of(capture) != ENPASSANT
<           || !pos.legal(capture, ci.pinned))
<       continue;
<     pos.do_move(capture, st, ci, pos.gives_check(capture, ci));
<     int v0 = -probe_ab(pos, -2, 2, success);
<     pos.undo_move(capture);
<     if (*success == 0) return 0;
<     if (v0 > v1) v1 = v0;
<   }
<   if (v1 > -3) {
<     if (v1 >= v) v = v1;
<     else if (v == 0) {
<       // Check whether there is at least one legal non-ep move.
<       for (moves = stack; moves < end; moves++) {
<         Move capture = moves->move;
<         if (type_of(capture) == ENPASSANT) continue;
<         if (pos.legal(capture, ci.pinned)) break;
<       }
<       if (moves == end && !pos.checkers()) {
<         end = generate<QUIETS>(pos, end);
<         for (; moves < end; moves++) {
<           Move move = moves->move;
<           if (pos.legal(move, ci.pinned))
<             break;
---
>     enum { Split = 1, HasPawns = 2 };
> 
>     assert(e.hasPawns        == !!(*data & HasPawns));
>     assert((e.key != e.key2) == !!(*data & Split));
> 
>     data++; // First byte stores flags
> 
>     const int Sides = IsWDL && (e.key != e.key2) ? 2 : 1;
>     const File MaxFile = e.hasPawns ? FILE_D : FILE_A;
> 
>     bool pp = e.hasPawns && e.pawnTable.pawnCount[1]; // Pawns on both sides
> 
>     assert(!pp || e.pawnTable.pawnCount[0]);
> 
>     for (File f = FILE_A; f <= MaxFile; ++f) {
> 
>         for (int i = 0; i < Sides; i++)
>             item(p, i, f).precomp = new PairsData();
> 
>         int order[][2] = { { *data & 0xF, pp ? *(data + 1) & 0xF : 0xF },
>                            { *data >>  4, pp ? *(data + 1) >>  4 : 0xF } };
>         data += 1 + pp;
> 
>         for (int k = 0; k < e.pieceCount; ++k, ++data)
>             for (int i = 0; i < Sides; i++)
>                 item(p, i, f).precomp->pieces[k] = Piece(i ? *data >>  4 : *data & 0xF);
> 
>         for (int i = 0; i < Sides; ++i)
>             set_groups(e, item(p, i, f).precomp, order[i], f);
>     }
> 
>     data += (uintptr_t)data & 1; // Word alignment
> 
>     for (File f = FILE_A; f <= MaxFile; ++f)
>         for (int i = 0; i < Sides; i++)
>             data = set_sizes(item(p, i, f).precomp, data);
> 
>     if (!IsWDL)
>         data = set_dtz_map(e, p, data, MaxFile);
> 
>     for (File f = FILE_A; f <= MaxFile; ++f)
>         for (int i = 0; i < Sides; i++) {
>             (d = item(p, i, f).precomp)->sparseIndex = (SparseEntry*)data;
>             data += d->sparseIndexSize * sizeof(SparseEntry) ;
455,458c1112,1148
<       }
<       // If not, then we are forced to play the losing ep capture.
<       if (moves == end)
<         v = v1;
---
> 
>     for (File f = FILE_A; f <= MaxFile; ++f)
>         for (int i = 0; i < Sides; i++) {
>             (d = item(p, i, f).precomp)->blockLength = (uint16_t*)data;
>             data += d->blockLengthSize * sizeof(uint16_t);
>         }
> 
>     for (File f = FILE_A; f <= MaxFile; ++f)
>         for (int i = 0; i < Sides; i++) {
>             data = (uint8_t*)(((uintptr_t)data + 0x3F) & ~0x3F); // 64 byte alignment
>             (d = item(p, i, f).precomp)->data = data;
>             data += d->blocksNum * d->sizeofBlock;
>         }
> }
> 
> template<typename Entry>
> void* init(Entry& e, const Position& pos) {
> 
>     const bool IsWDL = std::is_same<Entry, WDLEntry>::value;
> 
>     static Mutex mutex;
> 
>     // Avoid a thread reads 'ready' == true while another is still in do_init(),
>     // this could happen due to compiler reordering.
>     if (e.ready.load(std::memory_order_acquire))
>         return e.baseAddress;
> 
>     std::unique_lock<Mutex> lk(mutex);
> 
>     if (e.ready.load(std::memory_order_relaxed)) // Recheck under lock
>         return e.baseAddress;
> 
>     // Pieces strings in decreasing order for each color, like ("KPP","KR")
>     std::string fname, w, b;
>     for (PieceType pt = KING; pt >= PAWN; --pt) {
>         w += std::string(popcount(pos.pieces(WHITE, pt)), PieceToChar[pt]);
>         b += std::string(popcount(pos.pieces(BLACK, pt)), PieceToChar[pt]);
460d1149
<   }
462c1151,1162
<   return v;
---
>     const uint8_t TB_MAGIC[][4] = { { 0xD7, 0x66, 0x0C, 0xA5 },
>                                     { 0x71, 0xE8, 0x23, 0x5D } };
> 
>     fname =  (e.key == pos.material_key() ? w + 'v' + b : b + 'v' + w)
>            + (IsWDL ? ".rtbw" : ".rtbz");
> 
>     uint8_t* data = TBFile(fname).map(&e.baseAddress, &e.mapping, TB_MAGIC[IsWDL]);
>     if (data)
>         e.hasPawns ? do_init(e, e.pawnTable, data) : do_init(e, e.pieceTable, data);
> 
>     e.ready.store(true, std::memory_order_release);
>     return e.baseAddress;
465,468c1165,1166
< // This routine treats a position with en passant captures as one without.
< static int probe_dtz_no_ep(Position& pos, int *success)
< {
<   int wdl, dtz;
---
> template<typename E, typename T = typename Ret<E>::type>
> T probe_table(const Position& pos, ProbeState* result, WDLScore wdl = WDLDraw) {
470,471c1168,1169
<   wdl = probe_ab(pos, -2, 2, success);
<   if (*success == 0) return 0;
---
>     if (!(pos.pieces() ^ pos.pieces(KING)))
>         return T(WDLDraw); // KvK
473c1171
<   if (wdl == 0) return 0;
---
>     E* entry = EntryTable.get<E>(pos.material_key());
475,489c1173,1174
<   if (*success == 2)
<     return wdl == 2 ? 1 : 101;
< 
<   ExtMove stack[192];
<   ExtMove *moves, *end = NULL;
<   StateInfo st;
<   CheckInfo ci(pos);
< 
<   if (wdl > 0) {
<     // Generate at least all legal non-capturing pawn moves
<     // including non-capturing promotions.
<     if (!pos.checkers())
<       end = generate<NON_EVASIONS>(pos, stack);
<     else
<       end = generate<EVASIONS>(pos, stack);
---
>     if (!entry || !init(*entry, pos))
>         return *result = FAIL, T();
491,501c1176,1225
<     for (moves = stack; moves < end; moves++) {
<       Move move = moves->move;
<       if (type_of(pos.moved_piece(move)) != PAWN || pos.capture(move)
<                 || !pos.legal(move, ci.pinned))
<         continue;
<       pos.do_move(move, st, ci, pos.gives_check(move, ci));
<       int v = -probe_ab(pos, -2, -wdl + 1, success);
<       pos.undo_move(move);
<       if (*success == 0) return 0;
<       if (v == wdl)
<         return v == 2 ? 1 : 101;
---
>     return do_probe_table(pos, entry, wdl, result);
> }
> 
> // For a position where the side to move has a winning capture it is not necessary
> // to store a winning value so the generator treats such positions as "don't cares"
> // and tries to assign to it a value that improves the compression ratio. Similarly,
> // if the side to move has a drawing capture, then the position is at least drawn.
> // If the position is won, then the TB needs to store a win value. But if the
> // position is drawn, the TB may store a loss value if that is better for compression.
> // All of this means that during probing, the engine must look at captures and probe
> // their results and must probe the position itself. The "best" result of these
> // probes is the correct result for the position.
> // DTZ table don't store values when a following move is a zeroing winning move
> // (winning capture or winning pawn move). Also DTZ store wrong values for positions
> // where the best move is an ep-move (even if losing). So in all these cases set
> // the state to ZEROING_BEST_MOVE.
> template<bool CheckZeroingMoves = false>
> WDLScore search(Position& pos, ProbeState* result) {
> 
>     WDLScore value, bestValue = WDLLoss;
>     StateInfo st;
> 
>     auto moveList = MoveList<LEGAL>(pos);
>     size_t totalCount = moveList.size(), moveCount = 0;
> 
>     for (const Move& move : moveList)
>     {
>         if (   !pos.capture(move)
>             && (!CheckZeroingMoves || type_of(pos.moved_piece(move)) != PAWN))
>             continue;
> 
>         moveCount++;
> 
>         pos.do_move(move, st);
>         value = -search(pos, result);
>         pos.undo_move(move);
> 
>         if (*result == FAIL)
>             return WDLDraw;
> 
>         if (value > bestValue)
>         {
>             bestValue = value;
> 
>             if (value >= WDLWin)
>             {
>                 *result = ZEROING_BEST_MOVE; // Winning DTZ-zeroing move
>                 return value;
>             }
>         }
503d1226
<   }
505,509c1228,1234
<   dtz = 1 + probe_dtz_table(pos, wdl, success);
<   if (*success >= 0) {
<     if (wdl & 1) dtz += 100;
<     return wdl >= 0 ? dtz : -dtz;
<   }
---
>     // In case we have already searched all the legal moves we don't have to probe
>     // the TB because the stored score could be wrong. For instance TB tables
>     // do not contain information on position with ep rights, so in this case
>     // the result of probe_wdl_table is wrong. Also in case of only capture
>     // moves, for instance here 4K3/4q3/6p1/2k5/6p1/8/8/8 w - - 0 7, we have to
>     // return with ZEROING_BEST_MOVE set.
>     bool noMoreMoves = (moveCount && moveCount == totalCount);
511,529c1236,1237
<   if (wdl > 0) {
<     int best = 0xffff;
<     for (moves = stack; moves < end; moves++) {
<       Move move = moves->move;
<       if (pos.capture(move) || type_of(pos.moved_piece(move)) == PAWN
<                 || !pos.legal(move, ci.pinned))
<         continue;
<       pos.do_move(move, st, ci, pos.gives_check(move, ci));
<       int v = -Tablebases::probe_dtz(pos, success);
<       pos.undo_move(move);
<       if (*success == 0) return 0;
<       if (v > 0 && v + 1 < best)
<         best = v + 1;
<     }
<     return best;
<   } else {
<     int best = -1;
<     if (!pos.checkers())
<       end = generate<NON_EVASIONS>(pos, stack);
---
>     if (noMoreMoves)
>         value = bestValue;
531,542c1239,1381
<       end = generate<EVASIONS>(pos, stack);
<     for (moves = stack; moves < end; moves++) {
<       int v;
<       Move move = moves->move;
<       if (!pos.legal(move, ci.pinned))
<         continue;
<       pos.do_move(move, st, ci, pos.gives_check(move, ci));
<       if (st.rule50 == 0) {
<         if (wdl == -2) v = -1;
<         else {
<           v = probe_ab(pos, 1, 2, success);
<           v = (v == 2) ? 0 : -101;
---
>     {
>         value = probe_table<WDLEntry>(pos, result);
> 
>         if (*result == FAIL)
>             return WDLDraw;
>     }
> 
>     // DTZ stores a "don't care" value if bestValue is a win
>     if (bestValue >= value)
>         return *result = (   bestValue > WDLDraw
>                           || noMoreMoves ? ZEROING_BEST_MOVE : OK), bestValue;
> 
>     return *result = OK, value;
> }
> 
> } // namespace
> 
> void Tablebases::init(const std::string& paths) {
> 
>     EntryTable.clear();
>     MaxCardinality = 0;
>     TBFile::Paths = paths;
> 
>     if (paths.empty() || paths == "<empty>")
>         return;
> 
>     // MapB1H1H7[] encodes a square below a1-h8 diagonal to 0..27
>     int code = 0;
>     for (Square s = SQ_A1; s <= SQ_H8; ++s)
>         if (off_A1H8(s) < 0)
>             MapB1H1H7[s] = code++;
> 
>     // MapA1D1D4[] encodes a square in the a1-d1-d4 triangle to 0..9
>     std::vector<Square> diagonal;
>     code = 0;
>     for (Square s = SQ_A1; s <= SQ_D4; ++s)
>         if (off_A1H8(s) < 0 && file_of(s) <= FILE_D)
>             MapA1D1D4[s] = code++;
> 
>         else if (!off_A1H8(s) && file_of(s) <= FILE_D)
>             diagonal.push_back(s);
> 
>     // Diagonal squares are encoded as last ones
>     for (auto s : diagonal)
>         MapA1D1D4[s] = code++;
> 
>     // MapKK[] encodes all the 461 possible legal positions of two kings where
>     // the first is in the a1-d1-d4 triangle. If the first king is on the a1-d4
>     // diagonal, the other one shall not to be above the a1-h8 diagonal.
>     std::vector<std::pair<int, Square>> bothOnDiagonal;
>     code = 0;
>     for (int idx = 0; idx < 10; idx++)
>         for (Square s1 = SQ_A1; s1 <= SQ_D4; ++s1)
>             if (MapA1D1D4[s1] == idx && (idx || s1 == SQ_B1)) // SQ_B1 is mapped to 0
>             {
>                 for (Square s2 = SQ_A1; s2 <= SQ_H8; ++s2)
>                     if ((StepAttacksBB[KING][s1] | s1) & s2)
>                         continue; // Illegal position
> 
>                     else if (!off_A1H8(s1) && off_A1H8(s2) > 0)
>                         continue; // First on diagonal, second above
> 
>                     else if (!off_A1H8(s1) && !off_A1H8(s2))
>                         bothOnDiagonal.push_back(std::make_pair(idx, s2));
> 
>                     else
>                         MapKK[idx][s2] = code++;
>             }
> 
>     // Legal positions with both kings on diagonal are encoded as last ones
>     for (auto p : bothOnDiagonal)
>         MapKK[p.first][p.second] = code++;
> 
>     // Binomial[] stores the Binomial Coefficents using Pascal rule. There
>     // are Binomial[k][n] ways to choose k elements from a set of n elements.
>     Binomial[0][0] = 1;
> 
>     for (int n = 1; n < 64; n++) // Squares
>         for (int k = 0; k < 6 && k <= n; ++k) // Pieces
>             Binomial[k][n] =  (k > 0 ? Binomial[k - 1][n - 1] : 0)
>                             + (k < n ? Binomial[k    ][n - 1] : 0);
> 
>     // MapPawns[s] encodes squares a2-h7 to 0..47. This is the number of possible
>     // available squares when the leading one is in 's'. Moreover the pawn with
>     // highest MapPawns[] is the leading pawn, the one nearest the edge and,
>     // among pawns with same file, the one with lowest rank.
>     int availableSquares = 47; // Available squares when lead pawn is in a2
> 
>     // Init the tables for the encoding of leading pawns group: with 6-men TB we
>     // can have up to 4 leading pawns (KPPPPK).
>     for (int leadPawnsCnt = 1; leadPawnsCnt <= 4; ++leadPawnsCnt)
>         for (File f = FILE_A; f <= FILE_D; ++f)
>         {
>             // Restart the index at every file because TB table is splitted
>             // by file, so we can reuse the same index for different files.
>             int idx = 0;
> 
>             // Sum all possible combinations for a given file, starting with
>             // the leading pawn on rank 2 and increasing the rank.
>             for (Rank r = RANK_2; r <= RANK_7; ++r)
>             {
>                 Square sq = make_square(f, r);
> 
>                 // Compute MapPawns[] at first pass.
>                 // If sq is the leading pawn square, any other pawn cannot be
>                 // below or more toward the edge of sq. There are 47 available
>                 // squares when sq = a2 and reduced by 2 for any rank increase
>                 // due to mirroring: sq == a3 -> no a2, h2, so MapPawns[a3] = 45
>                 if (leadPawnsCnt == 1)
>                 {
>                     MapPawns[sq] = availableSquares--;
>                     MapPawns[sq ^ 7] = availableSquares--; // Horizontal flip
>                 }
>                 LeadPawnIdx[leadPawnsCnt][sq] = idx;
>                 idx += Binomial[leadPawnsCnt - 1][MapPawns[sq]];
>             }
>             // After a file is traversed, store the cumulated per-file index
>             LeadPawnsSize[leadPawnsCnt][f] = idx;
>         }
> 
>     for (PieceType p1 = PAWN; p1 < KING; ++p1) {
>         EntryTable.insert({KING, p1, KING});
> 
>         for (PieceType p2 = PAWN; p2 <= p1; ++p2) {
>             EntryTable.insert({KING, p1, p2, KING});
>             EntryTable.insert({KING, p1, KING, p2});
> 
>             for (PieceType p3 = PAWN; p3 < KING; ++p3)
>                 EntryTable.insert({KING, p1, p2, KING, p3});
> 
>             for (PieceType p3 = PAWN; p3 <= p2; ++p3) {
>                 EntryTable.insert({KING, p1, p2, p3, KING});
> 
>                 for (PieceType p4 = PAWN; p4 <= p3; ++p4)
>                     EntryTable.insert({KING, p1, p2, p3, p4, KING});
> 
>                 for (PieceType p4 = PAWN; p4 < KING; ++p4)
>                     EntryTable.insert({KING, p1, p2, p3, KING, p4});
>             }
> 
>             for (PieceType p3 = PAWN; p3 <= p1; ++p3)
>                 for (PieceType p4 = PAWN; p4 <= (p1 == p3 ? p2 : p3); ++p4)
>                     EntryTable.insert({KING, p1, p2, KING, p3, p4});
544,550d1382
<       } else {
<         v = -Tablebases::probe_dtz(pos, success) - 1;
<       }
<       pos.undo_move(move);
<       if (*success == 0) return 0;
<       if (v < best)
<         best = v;
552,553c1384,1385
<     return best;
<   }
---
> 
>     sync_cout << "info string Found " << EntryTable.size() << " tablebases" << sync_endl;
556,558c1388,1400
< static int wdl_to_dtz[] = {
<   -1, -101, 0, 101, 1
< };
---
> // Probe the WDL table for a particular position.
> // If *result != FAIL, the probe was successful.
> // The return value is from the point of view of the side to move:
> // -2 : loss
> // -1 : loss, but draw under 50-move rule
> //  0 : draw
> //  1 : win, but draw under 50-move rule
> //  2 : win
> WDLScore Tablebases::probe_wdl(Position& pos, ProbeState* result) {
> 
>     *result = OK;
>     return search(pos, result);
> }
561c1403
< // If *success != 0, the probe was successful.
---
> // If *result != FAIL, the probe was successful.
585,589c1427
< //
< int Tablebases::probe_dtz(Position& pos, int *success)
< {
<   *success = 1;
<   int v = probe_dtz_no_ep(pos, success);
---
> int Tablebases::probe_dtz(Position& pos, ProbeState* result) {
591,593c1429,1430
<   if (pos.ep_square() == SQ_NONE)
<     return v;
<   if (*success == 0) return 0;
---
>     *result = OK;
>     WDLScore wdl = search<true>(pos, result);
595,596c1432,1433
<   // Now handle en passant.
<   int v1 = -3;
---
>     if (*result == FAIL || wdl == WDLDraw) // DTZ tables don't store draws
>         return 0;
598,652c1435,1440
<   ExtMove stack[192];
<   ExtMove *moves, *end;
<   StateInfo st;
< 
<   if (!pos.checkers())
<     end = generate<CAPTURES>(pos, stack);
<   else
<     end = generate<EVASIONS>(pos, stack);
<   CheckInfo ci(pos);
< 
<   for (moves = stack; moves < end; moves++) {
<     Move capture = moves->move;
<     if (type_of(capture) != ENPASSANT
<                 || !pos.legal(capture, ci.pinned))
<       continue;
<     pos.do_move(capture, st, ci, pos.gives_check(capture, ci));
<     int v0 = -probe_ab(pos, -2, 2, success);
<     pos.undo_move(capture);
<     if (*success == 0) return 0;
<     if (v0 > v1) v1 = v0;
<   }
<   if (v1 > -3) {
<     v1 = wdl_to_dtz[v1 + 2];
<     if (v < -100) {
<       if (v1 >= 0)
<         v = v1;
<     } else if (v < 0) {
<       if (v1 >= 0 || v1 < 100)
<         v = v1;
<     } else if (v > 100) {
<       if (v1 > 0)
<         v = v1;
<     } else if (v > 0) {
<       if (v1 == 1)
<         v = v1;
<     } else if (v1 >= 0) {
<       v = v1;
<     } else {
<       for (moves = stack; moves < end; moves++) {
<         Move move = moves->move;
<         if (type_of(move) == ENPASSANT) continue;
<         if (pos.legal(move, ci.pinned)) break;
<       }
<       if (moves == end && !pos.checkers()) {
<         end = generate<QUIETS>(pos, end);
<         for (; moves < end; moves++) {
<           Move move = moves->move;
<           if (pos.legal(move, ci.pinned))
<             break;
<         }
<       }
<       if (moves == end)
<         v = v1;
<     }
<   }
---
>     // DTZ stores a 'don't care' value in this case, or even a plain wrong
>     // one as in case the best move is a losing ep, so it cannot be probed.
>     if (*result == ZEROING_BEST_MOVE)
>         return dtz_before_zeroing(wdl);
> 
>     int dtz = probe_table<DTZEntry>(pos, result, wdl);
654c1442,1484
<   return v;
---
>     if (*result == FAIL)
>         return 0;
> 
>     if (*result != CHANGE_STM)
>         return (dtz + 100 * (wdl == WDLBlessedLoss || wdl == WDLCursedWin)) * sign_of(wdl);
> 
>     // DTZ stores results for the other side, so we need to do a 1-ply search and
>     // find the winning move that minimizes DTZ.
>     StateInfo st;
>     int minDTZ = 0xFFFF;
> 
>     for (const Move& move : MoveList<LEGAL>(pos))
>     {
>         bool zeroing = pos.capture(move) || type_of(pos.moved_piece(move)) == PAWN;
> 
>         pos.do_move(move, st);
> 
>         // For zeroing moves we want the dtz of the move _before_ doing it,
>         // otherwise we will get the dtz of the next move sequence. Search the
>         // position after the move to get the score sign (because even in a
>         // winning position we could make a losing capture or going for a draw).
>         dtz = zeroing ? -dtz_before_zeroing(search(pos, result))
>                       : -probe_dtz(pos, result);
> 
>         pos.undo_move(move);
> 
>         if (*result == FAIL)
>             return 0;
> 
>         // Convert result from 1-ply search. Zeroing moves are already accounted
>         // by dtz_before_zeroing() that returns the DTZ of the previous move.
>         if (!zeroing)
>             dtz += sign_of(dtz);
> 
>         // Skip the draws and if we are winning only pick positive dtz
>         if (dtz < minDTZ && sign_of(dtz) == sign_of(wdl))
>             minDTZ = dtz;
>     }
> 
>     // Special handle a mate position, when there are no legal moves, in this
>     // case return value is somewhat arbitrary, so stick to the original TB code
>     // that returns -1 in this case.
>     return minDTZ == 0xFFFF ? -1 : minDTZ;
661,674c1491,1492
<   while (1) {
<     int i = 4, e = std::min(st->rule50, st->pliesFromNull);
<     if (e < i)
<       return 0;
<     StateInfo *stp = st->previous->previous;
<     do {
<       stp = stp->previous->previous;
<       if (stp->key == st->key)
<         return 1;
<       i += 2;
<     } while (i <= e);
<     st = st->previous;
<   }
< }
---
>     while (1) {
>         int i = 4, e = std::min(st->rule50, st->pliesFromNull);
676,682c1494,1510
< static Value wdl_to_Value[5] = {
<   -VALUE_MATE + MAX_PLY + 1,
<   VALUE_DRAW - 2,
<   VALUE_DRAW,
<   VALUE_DRAW + 2,
<   VALUE_MATE - MAX_PLY - 1
< };
---
>         if (e < i)
>             return 0;
> 
>         StateInfo *stp = st->previous->previous;
> 
>         do {
>             stp = stp->previous->previous;
> 
>             if (stp->key == st->key)
>                 return 1;
> 
>             i += 2;
>         } while (i <= e);
> 
>         st = st->previous;
>     }
> }
690c1518
< bool Tablebases::root_probe(Position& pos, Search::RootMoveVector& rootMoves, Value& score)
---
> bool Tablebases::root_probe(Position& pos, Search::RootMoves& rootMoves, Value& score)
692c1520,1521
<   int success;
---
>     ProbeState result;
>     int dtz = probe_dtz(pos, &result);
694,695c1523,1524
<   int dtz = probe_dtz(pos, &success);
<   if (!success) return false;
---
>     if (result == FAIL)
>         return false;
697,698c1526
<   StateInfo st;
<   CheckInfo ci(pos);
---
>     StateInfo st;
700,723c1528,1555
<   // Probe each move.
<   for (size_t i = 0; i < rootMoves.size(); i++) {
<     Move move = rootMoves[i].pv[0];
<     pos.do_move(move, st, ci, pos.gives_check(move, ci));
<     int v = 0;
<     if (pos.checkers() && dtz > 0) {
<       ExtMove s[192];
<       if (generate<LEGAL>(pos, s) == s)
<         v = 1;
<     }
<     if (!v) {
<       if (st.rule50 != 0) {
<         v = -Tablebases::probe_dtz(pos, &success);
<         if (v > 0) v++;
<         else if (v < 0) v--;
<       } else {
<         v = -Tablebases::probe_wdl(pos, &success);
<         v = wdl_to_dtz[v + 2];
<       }
<     }
<     pos.undo_move(move);
<     if (!success) return false;
<     rootMoves[i].score = (Value)v;
<   }
---
>     // Probe each move
>     for (size_t i = 0; i < rootMoves.size(); ++i) {
>         Move move = rootMoves[i].pv[0];
>         pos.do_move(move, st);
>         int v = 0;
> 
>         if (pos.checkers() && dtz > 0) {
>             ExtMove s[MAX_MOVES];
> 
>             if (generate<LEGAL>(pos, s) == s)
>                 v = 1;
>         }
> 
>         if (!v) {
>             if (st.rule50 != 0) {
>                 v = -probe_dtz(pos, &result);
> 
>                 if (v > 0)
>                     ++v;
>                 else if (v < 0)
>                     --v;
>             } else {
>                 v = -probe_wdl(pos, &result);
>                 v = dtz_before_zeroing(WDLScore(v));
>             }
>         }
> 
>         pos.undo_move(move);
725,784c1557,1560
<   // Obtain 50-move counter for the root position.
<   // In Stockfish there seems to be no clean way, so we do it like this:
<   int cnt50 = st.previous->rule50;
< 
<   // Use 50-move counter to determine whether the root position is
<   // won, lost or drawn.
<   int wdl = 0;
<   if (dtz > 0)
<     wdl = (dtz + cnt50 <= 100) ? 2 : 1;
<   else if (dtz < 0)
<     wdl = (-dtz + cnt50 <= 100) ? -2 : -1;
< 
<   // Determine the score to report to the user.
<   score = wdl_to_Value[wdl + 2];
<   // If the position is winning or losing, but too few moves left, adjust the
<   // score to show how close it is to winning or losing.
<   // NOTE: int(PawnValueEg) is used as scaling factor in score_to_uci().
<   if (wdl == 1 && dtz <= 100)
<     score = (Value)(((200 - dtz - cnt50) * int(PawnValueEg)) / 200);
<   else if (wdl == -1 && dtz >= -100)
<     score = -(Value)(((200 + dtz - cnt50) * int(PawnValueEg)) / 200);
< 
<   // Now be a bit smart about filtering out moves.
<   size_t j = 0;
<   if (dtz > 0) { // winning (or 50-move rule draw)
<     int best = 0xffff;
<     for (size_t i = 0; i < rootMoves.size(); i++) {
<       int v = rootMoves[i].score;
<       if (v > 0 && v < best)
<         best = v;
<     }
<     int max = best;
<     // If the current phase has not seen repetitions, then try all moves
<     // that stay safely within the 50-move budget, if there are any.
<     if (!has_repeated(st.previous) && best + cnt50 <= 99)
<       max = 99 - cnt50;
<     for (size_t i = 0; i < rootMoves.size(); i++) {
<       int v = rootMoves[i].score;
<       if (v > 0 && v <= max)
<         rootMoves[j++] = rootMoves[i];
<     }
<   } else if (dtz < 0) { // losing (or 50-move rule draw)
<     int best = 0;
<     for (size_t i = 0; i < rootMoves.size(); i++) {
<       int v = rootMoves[i].score;
<       if (v < best)
<         best = v;
<     }
<     // Try all moves, unless we approach or have a 50-move rule draw.
<     if (-best * 2 + cnt50 < 100)
<       return true;
<     for (size_t i = 0; i < rootMoves.size(); i++) {
<       if (rootMoves[i].score == best)
<         rootMoves[j++] = rootMoves[i];
<     }
<   } else { // drawing
<     // Try all moves that preserve the draw.
<     for (size_t i = 0; i < rootMoves.size(); i++) {
<       if (rootMoves[i].score == 0)
<         rootMoves[j++] = rootMoves[i];
---
>         if (result == FAIL)
>             return false;
> 
>         rootMoves[i].score = (Value)v;
786,787d1561
<   }
<   rootMoves.resize(j, Search::RootMove(MOVE_NONE));
789c1563,1641
<   return true;
---
>     // Obtain 50-move counter for the root position.
>     // In Stockfish there seems to be no clean way, so we do it like this:
>     int cnt50 = st.previous->rule50;
> 
>     // Use 50-move counter to determine whether the root position is
>     // won, lost or drawn.
>     WDLScore wdl = WDLDraw;
> 
>     if (dtz > 0)
>         wdl = (dtz + cnt50 <= 100) ? WDLWin : WDLCursedWin;
>     else if (dtz < 0)
>         wdl = (-dtz + cnt50 <= 100) ? WDLLoss : WDLBlessedLoss;
> 
>     // Determine the score to report to the user.
>     score = WDL_to_value[wdl + 2];
> 
>     // If the position is winning or losing, but too few moves left, adjust the
>     // score to show how close it is to winning or losing.
>     // NOTE: int(PawnValueEg) is used as scaling factor in score_to_uci().
>     if (wdl == WDLCursedWin && dtz <= 100)
>         score = (Value)(((200 - dtz - cnt50) * int(PawnValueEg)) / 200);
>     else if (wdl == WDLBlessedLoss && dtz >= -100)
>         score = -(Value)(((200 + dtz - cnt50) * int(PawnValueEg)) / 200);
> 
>     // Now be a bit smart about filtering out moves.
>     size_t j = 0;
> 
>     if (dtz > 0) { // winning (or 50-move rule draw)
>         int best = 0xffff;
> 
>         for (size_t i = 0; i < rootMoves.size(); ++i) {
>             int v = rootMoves[i].score;
> 
>             if (v > 0 && v < best)
>                 best = v;
>         }
> 
>         int max = best;
> 
>         // If the current phase has not seen repetitions, then try all moves
>         // that stay safely within the 50-move budget, if there are any.
>         if (!has_repeated(st.previous) && best + cnt50 <= 99)
>             max = 99 - cnt50;
> 
>         for (size_t i = 0; i < rootMoves.size(); ++i) {
>             int v = rootMoves[i].score;
> 
>             if (v > 0 && v <= max)
>                 rootMoves[j++] = rootMoves[i];
>         }
>     } else if (dtz < 0) { // losing (or 50-move rule draw)
>         int best = 0;
> 
>         for (size_t i = 0; i < rootMoves.size(); ++i) {
>             int v = rootMoves[i].score;
> 
>             if (v < best)
>                 best = v;
>         }
> 
>         // Try all moves, unless we approach or have a 50-move rule draw.
>         if (-best * 2 + cnt50 < 100)
>             return true;
> 
>         for (size_t i = 0; i < rootMoves.size(); ++i) {
>             if (rootMoves[i].score == best)
>                 rootMoves[j++] = rootMoves[i];
>         }
>     } else { // drawing
>         // Try all moves that preserve the draw.
>         for (size_t i = 0; i < rootMoves.size(); ++i) {
>             if (rootMoves[i].score == 0)
>                 rootMoves[j++] = rootMoves[i];
>         }
>     }
> 
>     rootMoves.resize(j, Search::RootMove(MOVE_NONE));
> 
>     return true;
797c1649
< bool Tablebases::root_probe_wdl(Position& pos, Search::RootMoveVector& rootMoves, Value& score)
---
> bool Tablebases::root_probe_wdl(Position& pos, Search::RootMoves& rootMoves, Value& score)
799c1651
<   int success;
---
>     ProbeState result;
801,820c1653
<   int wdl = Tablebases::probe_wdl(pos, &success);
<   if (!success) return false;
<   score = wdl_to_Value[wdl + 2];
< 
<   StateInfo st;
<   CheckInfo ci(pos);
< 
<   int best = -2;
< 
<   // Probe each move.
<   for (size_t i = 0; i < rootMoves.size(); i++) {
<     Move move = rootMoves[i].pv[0];
<     pos.do_move(move, st, ci, pos.gives_check(move, ci));
<     int v = -Tablebases::probe_wdl(pos, &success);
<     pos.undo_move(move);
<     if (!success) return false;
<     rootMoves[i].score = (Value)v;
<     if (v > best)
<       best = v;
<   }
---
>     WDLScore wdl = Tablebases::probe_wdl(pos, &result);
822,827c1655,1656
<   size_t j = 0;
<   for (size_t i = 0; i < rootMoves.size(); i++) {
<     if (rootMoves[i].score == best)
<       rootMoves[j++] = rootMoves[i];
<   }
<   rootMoves.resize(j, Search::RootMove(MOVE_NONE));
---
>     if (result == FAIL)
>         return false;
829,830c1658,1662
<   return true;
< }
---
>     score = WDL_to_value[wdl + 2];
> 
>     StateInfo st;
> 
>     int best = WDLLoss;
831a1664,1690
>     // Probe each move
>     for (size_t i = 0; i < rootMoves.size(); ++i) {
>         Move move = rootMoves[i].pv[0];
>         pos.do_move(move, st);
>         WDLScore v = -Tablebases::probe_wdl(pos, &result);
>         pos.undo_move(move);
> 
>         if (result == FAIL)
>             return false;
> 
>         rootMoves[i].score = (Value)v;
> 
>         if (v > best)
>             best = v;
>     }
> 
>     size_t j = 0;
> 
>     for (size_t i = 0; i < rootMoves.size(); ++i) {
>         if (rootMoves[i].score == best)
>             rootMoves[j++] = rootMoves[i];
>     }
> 
>     rootMoves.resize(j, Search::RootMove(MOVE_NONE));
> 
>     return true;
> }
0a1,19
> /*
>   Stockfish, a UCI chess playing engine derived from Glaurung 2.1
>   Copyright (c) 2013 Ronald de Man
>   Copyright (C) 2016-2017 Marco Costalba, Lucas Braesch
> 
>   Stockfish is free software: you can redistribute it and/or modify
>   it under the terms of the GNU General Public License as published by
>   the Free Software Foundation, either version 3 of the License, or
>   (at your option) any later version.
> 
>   Stockfish is distributed in the hope that it will be useful,
>   but WITHOUT ANY WARRANTY; without even the implied warranty of
>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>   GNU General Public License for more details.
> 
>   You should have received a copy of the GNU General Public License
>   along with this program.  If not, see <http://www.gnu.org/licenses/>.
> */
> 
3a23,24
> #include <ostream>
> 
7a29,46
> enum WDLScore {
>     WDLLoss        = -2, // Loss
>     WDLBlessedLoss = -1, // Loss, but draw under 50-move rule
>     WDLDraw        =  0, // Draw
>     WDLCursedWin   =  1, // Win, but draw under 50-move rule
>     WDLWin         =  2, // Win
> 
>     WDLScoreNone  = -1000
> };
> 
> // Possible states after a probing operation
> enum ProbeState {
>     FAIL              =  0, // Probe failed (missing file table)
>     OK                =  1, // Probe succesful
>     CHANGE_STM        = -1, // DTZ should check the other side
>     ZEROING_BEST_MOVE =  2  // Best move zeroes DTZ (capture or pawn move)
> };
> 
10,14c49,75
< void init(const std::string& path);
< int probe_wdl(Position& pos, int *success);
< int probe_dtz(Position& pos, int *success);
< bool root_probe(Position& pos, Search::RootMoveVector& rootMoves, Value& score);
< bool root_probe_wdl(Position& pos, Search::RootMoveVector& rootMoves, Value& score);
---
> void init(const std::string& paths);
> WDLScore probe_wdl(Position& pos, ProbeState* result);
> int probe_dtz(Position& pos, ProbeState* result);
> bool root_probe(Position& pos, Search::RootMoves& rootMoves, Value& score);
> bool root_probe_wdl(Position& pos, Search::RootMoves& rootMoves, Value& score);
> void filter_root_moves(Position& pos, Search::RootMoves& rootMoves);
> 
> inline std::ostream& operator<<(std::ostream& os, const WDLScore v) {
> 
>     os << (v == WDLLoss        ? "Loss" :
>            v == WDLBlessedLoss ? "Blessed loss" :
>            v == WDLDraw        ? "Draw" :
>            v == WDLCursedWin   ? "Cursed win" :
>            v == WDLWin         ? "Win" : "None");
> 
>     return os;
> }
> 
> inline std::ostream& operator<<(std::ostream& os, const ProbeState v) {
> 
>     os << (v == FAIL              ? "Failed" :
>            v == OK                ? "Success" :
>            v == CHANGE_STM        ? "Probed opponent side" :
>            v == ZEROING_BEST_MOVE ? "Best move zeroes DTZ" : "None");
> 
>     return os;
> }
****************************************************************
uci
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
20d20
< #include <iomanip>
30c30
< #include "tt.h"
---
> #include "timeman.h"
31a32
> #include "syzygy/tbprobe.h"
42,45c43,46
<   // Keep a track of the position keys along the setup moves (from the start position
<   // to the position just before the search starts). This is needed by the repetition
<   // draw detection code.
<   Search::StateStackPtr SetupStates;
---
>   // A list to keep track of the position states along the setup moves (from the
>   // start position to the position just before the search starts). Needed by
>   // 'draw by repetition' detection.
>   StateListPtr States(new std::deque<StateInfo>(1));
71,72c72,73
<     pos.set(fen, Options["UCI_Chess960"], Threads.main());
<     SetupStates = Search::StateStackPtr(new std::stack<StateInfo>());
---
>     States = StateListPtr(new std::deque<StateInfo>(1));
>     pos.set(fen, Options["UCI_Chess960"], &States->back(), Threads.main());
77,78c78,79
<         SetupStates->push(StateInfo());
<         pos.do_move(m, SetupStates->top());
---
>         States->push_back(StateInfo());
>         pos.do_move(m, States->back());
94c95
<         name += string(" ", !name.empty()) + token;
---
>         name += string(" ", name.empty() ? 0 : 1) + token;
98c99
<         value += string(" ", !value.empty()) + token;
---
>         value += string(" ", value.empty() ? 0 : 1) + token;
108c109
<   // the thinking time and other parameters from the input string, and starts
---
>   // the thinking time and other parameters from the input string, then starts
111c112
<   void go(const Position& pos, istringstream& is) {
---
>   void go(Position& pos, istringstream& is) {
115a117,118
>     limits.startTime = now(); // As early as possible!
> 
117d119
<     {
131,133c133,134
<         else if (token == "infinite")  limits.infinite = true;
<         else if (token == "ponder")    limits.ponder = true;
<     }
---
>         else if (token == "infinite")  limits.infinite = 1;
>         else if (token == "ponder")    limits.ponder = 1;
135c136
<     Threads.start_thinking(pos, limits, SetupStates);
---
>     Threads.start_thinking(pos, States, limits);
141,144c142,146
< /// Wait for a command from the user, parse this text string as an UCI command,
< /// and call the appropriate functions. Also intercepts EOF from stdin to ensure
< /// that we exit gracefully if the GUI dies unexpectedly. In addition to the UCI
< /// commands, the function also supports a few debug commands.
---
> /// UCI::loop() waits for a command from stdin, parses it and calls the appropriate
> /// function. Also intercepts EOF from stdin to ensure gracefully exiting if the
> /// GUI dies unexpectedly. When called with some command line arguments, e.g. to
> /// run 'bench', once the command is executed the function returns immediately.
> /// In addition to the UCI ones, also some additional debug commands are supported.
148c150
<   Position pos(StartFEN, false, Threads.main()); // The root position
---
>   Position pos;
150a153,154
>   pos.set(StartFEN, false, &States->back(), Threads.main());
> 
155c159
<       if (argc == 1 && !getline(cin, cmd)) // Block here waiting for input
---
>       if (argc == 1 && !getline(cin, cmd)) // Block here waiting for input or EOF
163c167,174
<       if (token == "quit" || token == "stop" || token == "ponderhit")
---
>       // The GUI sends 'ponderhit' to tell us to ponder on the same move the
>       // opponent has played. In case Signals.stopOnPonderhit is set we are
>       // waiting for 'ponderhit' to stop the search (for instance because we
>       // already ran out of time), otherwise we should continue searching but
>       // switching from pondering to normal search.
>       if (    token == "quit"
>           ||  token == "stop"
>           || (token == "ponderhit" && Search::Signals.stopOnPonderhit))
165,187c176,177
<           // The GUI sends 'ponderhit' to tell us to ponder on the same move the
<           // opponent has played. In case Signals.stopOnPonderhit is set we are
<           // waiting for 'ponderhit' to stop the search (for instance because we
<           // already ran out of time), otherwise we should continue searching but
<           // switch from pondering to normal search.
<           if (token != "ponderhit" || Search::Signals.stopOnPonderhit)
<           {
<               Search::Signals.stop = true;
<               Threads.main()->notify_one(); // Could be sleeping
<           }
<           else
<               Search::Limits.ponder = false;
<       }
<       else if (token == "perft")
<       {
<           int depth;
<           stringstream ss;
< 
<           is >> depth;
<           ss << Options["Hash"]    << " "
<              << Options["Threads"] << " " << depth << " current " << token;
< 
<           benchmark(pos, ss);
---
>           Search::Signals.stop = true;
>           Threads.main()->start_searching(true); // Could be sleeping
189,194c179,180
<       else if (token == "key")
<           sync_cout << hex << uppercase << setfill('0')
<                     << "position key: "   << setw(16) << pos.key()
<                     << "\nmaterial key: " << setw(16) << pos.material_key()
<                     << "\npawn key:     " << setw(16) << pos.pawn_key()
<                     << dec << nouppercase << setfill(' ') << sync_endl;
---
>       else if (token == "ponderhit")
>           Search::Limits.ponder = 0; // Switch to normal search
201c187,193
<       else if (token == "ucinewgame") TT.clear();
---
>       else if (token == "ucinewgame")
>       {
>           Search::clear();
>           Tablebases::init(Options["SyzygyPath"]);
>           Time.availableNodes = 0;
>       }
>       else if (token == "isready")    sync_cout << "readyok" << sync_endl;
204a197,198
> 
>       // Additional custom non-UCI commands, useful for debugging
208d201
<       else if (token == "isready")    sync_cout << "readyok" << sync_endl;
209a203,213
>       else if (token == "perft")
>       {
>           int depth;
>           stringstream ss;
> 
>           is >> depth;
>           ss << Options["Hash"]    << " "
>              << Options["Threads"] << " " << depth << " current perft";
> 
>           benchmark(pos, ss);
>       }
215c219
<   Threads.wait_for_think_finished(); // Cannot quit whilst the search is running
---
>   Threads.main()->wait_for_search_finished();
219,220c223,224
< /// Convert a Value to a string suitable for use with the UCI protocol
< /// specifications:
---
> /// UCI::value() converts a Value to a string suitable for use with the UCI
> /// protocol specification:
222,224c226,228
< /// cp <x>     The score from the engine's point of view in centipawns.
< /// mate <y>   Mate in y moves, not plies. If the engine is getting mated
< ///            use negative values for y.
---
> /// cp <x>    The score from the engine's point of view in centipawns.
> /// mate <y>  Mate in y moves, not plies. If the engine is getting mated
> ///           use negative values for y.
226c230
< string UCI::value(Value v, Value alpha, Value beta) {
---
> string UCI::value(Value v) {
235,236d238
<   ss << (v >= beta ? " lowerbound" : v <= alpha ? " upperbound" : "");
< 
241c243
< /// Convert a Square to a string in algebraic notation (g1, a7, etc.)
---
> /// UCI::square() converts a Square to a string in algebraic notation (g1, a7, etc.)
244,246c246
< 
<   char sq[] = { char('a' + file_of(s)), char('1' + rank_of(s)), 0 };
<   return sq;
---
>   return std::string{ char('a' + file_of(s)), char('1' + rank_of(s)) };
250,253c250,253
< /// Convert a Move to a string in pure coordinate notation (g1f3, a7a8q). The
< /// only special case is castling moves, where we print in the e1g1 notation in
< /// normal chess mode, and in e1h1 notation in chess960 mode. Internally
< /// castling moves are always encoded as "king captures rook".
---
> /// UCI::move() converts a Move to a string in coordinate notation (g1f3, a7a8q).
> /// The only special case is castling, where we print in the e1g1 notation in
> /// normal chess mode, and in e1h1 notation in chess960 mode. Internally all
> /// castling moves are always encoded as 'king captures rook'.
278,279c278,279
< /// Convert a string representing a move in pure coordinate notation to the
< /// corresponding legal Move, if any.
---
> /// UCI::to_move() converts a string representing a move in coordinate notation
> /// (g1f3, a7a8q) to the corresponding legal Move, if any.
286,288c286,288
<   for (MoveList<LEGAL> it(pos); *it; ++it)
<       if (str == UCI::move(*it, pos.is_chess960()))
<           return *it;
---
>   for (const auto& m : MoveList<LEGAL>(pos))
>       if (str == UCI::move(m, pos.is_chess960()))
>           return m;
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
20,21c21,22
< #ifndef UCIOPTION_H_INCLUDED
< #define UCIOPTION_H_INCLUDED
---
> #ifndef UCI_H_INCLUDED
> #define UCI_H_INCLUDED
48,51c49,52
<   Option(OnChange = NULL);
<   Option(bool v, OnChange = NULL);
<   Option(const char* v, OnChange = NULL);
<   Option(int v, int min, int max, OnChange = NULL);
---
>   Option(OnChange = nullptr);
>   Option(bool v, OnChange = nullptr);
>   Option(const char* v, OnChange = nullptr);
>   Option(int v, int minv, int maxv, OnChange = nullptr);
53,54c54,55
<   Option& operator=(const std::string& v);
<   void operator<<(const Option& o);
---
>   Option& operator=(const std::string&);
>   void operator<<(const Option&);
69,70c70
< 
< std::string value(Value v, Value alpha = -VALUE_INFINITE, Value beta = VALUE_INFINITE);
---
> std::string value(Value v);
72a73
> std::string pv(const Position& pos, Depth depth, Value alpha, Value beta);
79c80
< #endif // #ifndef UCIOPTION_H_INCLUDED
---
> #endif // #ifndef UCI_H_INCLUDED
****************************************************************
tt
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
20c21
< #include <cstring>
---
> #include <cstring>   // For std::memset
31c32
< /// of clusters and each cluster consists of TTClusterSize number of TTEntry.
---
> /// of clusters and each cluster consists of ClusterSize number of TTEntry.
35c36
<   size_t newClusterCount = size_t(1) << msb((mbSize * 1024 * 1024) / sizeof(TTCluster));
---
>   size_t newClusterCount = size_t(1) << msb((mbSize * 1024 * 1024) / sizeof(Cluster));
43c44
<   mem = calloc(clusterCount * sizeof(TTCluster) + CACHE_LINE_SIZE - 1, 1);
---
>   mem = calloc(clusterCount * sizeof(Cluster) + CacheLineSize - 1, 1);
52c53
<   table = (TTCluster*)((uintptr_t(mem) + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1));
---
>   table = (Cluster*)((uintptr_t(mem) + CacheLineSize - 1) & ~(CacheLineSize - 1));
62c63
<   std::memset(table, 0, clusterCount * sizeof(TTCluster));
---
>   std::memset(table, 0, clusterCount * sizeof(Cluster));
69,71c70,72
< /// to be replaced later. A TTEntry t1 is considered to be more valuable than a
< /// TTEntry t2 if t1 is from the current search and t2 is from a previous search,
< /// or if the depth of t1 is bigger than the depth of t2.
---
> /// to be replaced later. The replace value of an entry is calculated as its depth
> /// minus 8 times its relative age. TTEntry t1 is considered more valuable than
> /// TTEntry t2 if its replace value is greater than that of t2.
78c79
<   for (unsigned i = 0; i < TTClusterSize; ++i)
---
>   for (int i = 0; i < ClusterSize; ++i)
81c82
<           if (tte[i].key16)
---
>           if ((tte[i].genBound8 & 0xFC) != generation8 && tte[i].key16)
89,92c90,96
<   for (unsigned i = 1; i < TTClusterSize; ++i)
<       if (  ((  tte[i].genBound8 & 0xFC) == generation8 || tte[i].bound() == BOUND_EXACT)
<           - ((replace->genBound8 & 0xFC) == generation8)
<           - (tte[i].depth8 < replace->depth8) < 0)
---
>   for (int i = 1; i < ClusterSize; ++i)
>       // Due to our packed storage format for generation and its cyclic
>       // nature we add 259 (256 is the modulus plus 3 to keep the lowest
>       // two bound bits from affecting the result) to calculate the entry
>       // age correctly even after generation8 overflows into the next cycle.
>       if (  replace->depth8 - ((259 + generation8 - replace->genBound8) & 0xFC) * 2
>           >   tte[i].depth8 - ((259 + generation8 -   tte[i].genBound8) & 0xFC) * 2)
95a100,116
> }
> 
> 
> /// TranspositionTable::hashfull() returns an approximation of the hashtable
> /// occupation during a search. The hash is x permill full, as per UCI protocol.
> 
> int TranspositionTable::hashfull() const {
> 
>   int cnt = 0;
>   for (int i = 0; i < 1000 / ClusterSize; i++)
>   {
>       const TTEntry* tte = &table[i].entry[0];
>       for (int j = 0; j < ClusterSize; j++)
>           if ((tte[j].genBound8 & 0xFC) == generation8)
>               cnt++;
>   }
>   return cnt;
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
26c27
< /// The TTEntry is the 10 bytes transposition table entry, defined as below:
---
> /// TTEntry struct is the 10 bytes transposition table entry, defined as below:
38,42c39,43
<   Move  move()  const      { return (Move )move16; }
<   Value value() const      { return (Value)value16; }
<   Value eval_value() const { return (Value)evalValue; }
<   Depth depth() const      { return (Depth)depth8; }
<   Bound bound() const      { return (Bound)(genBound8 & 0x3); }
---
>   Move  move()  const { return (Move )move16; }
>   Value value() const { return (Value)value16; }
>   Value eval()  const { return (Value)eval16; }
>   Depth depth() const { return (Depth)(depth8 * int(ONE_PLY)); }
>   Bound bound() const { return (Bound)(genBound8 & 0x3); }
46c47,50
<     if (m || (k >> 48) != key16) // Preserve any existing move for the same position
---
>     assert(d / ONE_PLY * ONE_PLY == d);
> 
>     // Preserve any existing move for the same position
>     if (m || (k >> 48) != key16)
49,53c53,64
<     key16      = (uint16_t)(k >> 48);
<     value16    = (int16_t)v;
<     evalValue  = (int16_t)ev;
<     genBound8  = (uint8_t)(g | b);
<     depth8     = (int8_t)d;
---
>     // Don't overwrite more valuable entries
>     if (  (k >> 48) != key16
>         || d / ONE_PLY > depth8 - 4
>      /* || g != (genBound8 & 0xFC) // Matching non-zero keys are already refreshed by probe() */
>         || b == BOUND_EXACT)
>     {
>         key16     = (uint16_t)(k >> 48);
>         value16   = (int16_t)v;
>         eval16    = (int16_t)ev;
>         genBound8 = (uint8_t)(g | b);
>         depth8    = (int8_t)(d / ONE_PLY);
>     }
62c73
<   int16_t  evalValue;
---
>   int16_t  eval16;
67,77d77
< /// TTCluster is a 32 bytes cluster of TT entries consisting of:
< ///
< /// 3 x TTEntry (3 x 10 bytes)
< /// padding     (2 bytes)
< 
< static const unsigned TTClusterSize = 3;
< 
< struct TTCluster {
<   TTEntry entry[TTClusterSize];
<   char padding[2];
< };
80c80
< /// cluster consists of TTClusterSize number of TTEntry. Each non-empty entry
---
> /// cluster consists of ClusterSize number of TTEntry. Each non-empty entry
82,83c82,84
< /// not be bigger than a cache line size. In case it is less, it should be padded
< /// to guarantee always aligned accesses.
---
> /// divide the size of a cache line size, to ensure that clusters never cross
> /// cache lines. This ensures best cache performance, as the cacheline is
> /// prefetched, as soon as possible.
86a88,97
>   static const int CacheLineSize = 64;
>   static const int ClusterSize = 3;
> 
>   struct Cluster {
>     TTEntry entry[ClusterSize];
>     char padding[2]; // Align to a divisor of the cache line size
>   };
> 
>   static_assert(CacheLineSize % sizeof(Cluster) == 0, "Cluster size incorrect");
> 
92c103
<   TTEntry* first_entry(const Key key) const;
---
>   int hashfull() const;
95a107,111
>   // The lowest order bits of the key are used to get the index of the cluster
>   TTEntry* first_entry(const Key key) const {
>     return &table[(size_t)key & (clusterCount - 1)].entry[0];
>   }
> 
98c114
<   TTCluster* table;
---
>   Cluster* table;
104,113d119
< 
< 
< /// TranspositionTable::first_entry() returns a pointer to the first entry of
< /// a cluster given a position. The lowest order bits of the key are used to
< /// get the index of the cluster inside the table.
< 
< inline TTEntry* TranspositionTable::first_entry(const Key key) const {
< 
<   return &table[(size_t)key & (clusterCount - 1)].entry[0];
< }
****************************************************************
timeman
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
27a29,30
> TimeManagement Time; // Our global time management object
> 
33,38c36,37
<   const double MaxRatio   = 7.0;  // When in trouble, we can step over reserved time with this ratio
<   const double StealRatio = 0.33; // However we must not steal time from remaining moves over this ratio
< 
<   const double xscale     = 9.3;
<   const double xshift     = 59.8;
<   const double skewfactor = 0.172;
---
>   const double MaxRatio   = 7.09; // When in trouble, we can step over reserved time with this ratio
>   const double StealRatio = 0.35; // However we must not steal time from remaining moves over this ratio
44c43
<   // Data was extracted from CCRL game database with some simple filtering criteria.
---
>   // Data was extracted from the CCRL game database with some simple filtering criteria.
48c47,51
<     return pow((1 + exp((ply - xshift) / xscale)), -skewfactor) + DBL_MIN; // Ensure non-zero
---
>     const double XScale = 7.64;
>     const double XShift = 58.4;
>     const double Skew   = 0.183;
> 
>     return pow((1 + exp((ply - XShift) / XScale)), -Skew) + DBL_MIN; // Ensure non-zero
52,53c55,56
<   int remaining(int myTime, int movesToGo, int currentPly, int slowMover)
<   {
---
>   int remaining(int myTime, int movesToGo, int ply, int slowMover) {
> 
57c60
<     double thisMoveImportance = (move_importance(currentPly) * slowMover) / 100;
---
>     double moveImportance = (move_importance(ply) * slowMover) / 100;
61c64
<         otherMovesImportance += move_importance(currentPly + 2 * i);
---
>         otherMovesImportance += move_importance(ply + 2 * i);
63,64c66,67
<     double ratio1 = (TMaxRatio * thisMoveImportance) / (TMaxRatio * thisMoveImportance + otherMovesImportance);
<     double ratio2 = (thisMoveImportance + TStealRatio * otherMovesImportance) / (thisMoveImportance + otherMovesImportance);
---
>     double ratio1 = (TMaxRatio * moveImportance) / (TMaxRatio * moveImportance + otherMovesImportance);
>     double ratio2 = (moveImportance + TStealRatio * otherMovesImportance) / (moveImportance + otherMovesImportance);
66c69
<     return int(myTime * std::min(ratio1, ratio2));
---
>     return int(myTime * std::min(ratio1, ratio2)); // Intel C++ asks for an explicit cast
72,87c75,82
< void TimeManager::init(const Search::LimitsType& limits, int currentPly, Color us)
< {
<   /* We support four different kinds of time controls:
< 
<       increment == 0 && movesToGo == 0 means: x basetime  [sudden death!]
<       increment == 0 && movesToGo != 0 means: x moves in y minutes
<       increment >  0 && movesToGo == 0 means: x basetime + z increment
<       increment >  0 && movesToGo != 0 means: x moves in y minutes + z increment
< 
<     Time management is adjusted by following parameters:
< 
<       emergencyMoveHorizon: Be prepared to always play at least this many moves
<       emergencyBaseTime   : Always attempt to keep at least this much time (in ms) at clock
<       emergencyMoveTime   : Plus attempt to keep at least this much time for each remaining emergency move
<       minThinkingTime     : No matter what, use at least this much thinking before doing the move
<   */
---
> /// init() is called at the beginning of the search and calculates the allowed
> /// thinking time out of the time control and current game ply. We support four
> /// different kinds of time controls, passed in 'limits':
> ///
> ///  inc == 0 && movestogo == 0 means: x basetime  [sudden death!]
> ///  inc == 0 && movestogo != 0 means: x moves in y minutes
> ///  inc >  0 && movestogo == 0 means: x basetime + z increment
> ///  inc >  0 && movestogo != 0 means: x moves in y minutes + z increment
89c84
<   int hypMTG, hypMyTime, t1, t2;
---
> void TimeManagement::init(Search::LimitsType& limits, Color us, int ply) {
91,92d85
<   // Read uci parameters
<   int moveOverhead    = Options["Move Overhead"];
93a87
>   int moveOverhead    = Options["Move Overhead"];
94a89
>   int npmsec          = Options["nodestime"];
96,102c91,114
<   // Initialize unstablePvFactor to 1 and search times to maximum values
<   unstablePvFactor = 1;
<   optimumSearchTime = maximumSearchTime = std::max(limits.time[us], minThinkingTime);
< 
<   // We calculate optimum time usage for different hypothetical "moves to go"-values and choose the
<   // minimum of calculated search time values. Usually the greatest hypMTG gives the minimum values.
<   for (hypMTG = 1; hypMTG <= (limits.movestogo ? std::min(limits.movestogo, MoveHorizon) : MoveHorizon); ++hypMTG)
---
>   // If we have to play in 'nodes as time' mode, then convert from time
>   // to nodes, and use resulting values in time management formulas.
>   // WARNING: Given npms (nodes per millisecond) must be much lower then
>   // the real engine speed to avoid time losses.
>   if (npmsec)
>   {
>       if (!availableNodes) // Only once at game start
>           availableNodes = npmsec * limits.time[us]; // Time is in msec
> 
>       // Convert from millisecs to nodes
>       limits.time[us] = (int)availableNodes;
>       limits.inc[us] *= npmsec;
>       limits.npmsec = npmsec;
>   }
> 
>   startTime = limits.startTime;
>   optimumTime = maximumTime = std::max(limits.time[us], minThinkingTime);
> 
>   const int MaxMTG = limits.movestogo ? std::min(limits.movestogo, MoveHorizon) : MoveHorizon;
> 
>   // We calculate optimum time usage for different hypothetical "moves to go"-values
>   // and choose the minimum of calculated search time values. Usually the greatest
>   // hypMTG gives the minimum values.
>   for (int hypMTG = 1; hypMTG <= MaxMTG; ++hypMTG)
105,107c117,119
<       hypMyTime =  limits.time[us]
<                  + limits.inc[us] * (hypMTG - 1)
<                  - moveOverhead * (2 + std::min(hypMTG, 40));
---
>       int hypMyTime =  limits.time[us]
>                      + limits.inc[us] * (hypMTG - 1)
>                      - moveOverhead * (2 + std::min(hypMTG, 40));
111,112c123,124
<       t1 = minThinkingTime + remaining<OptimumTime>(hypMyTime, hypMTG, currentPly, slowMover);
<       t2 = minThinkingTime + remaining<MaxTime>(hypMyTime, hypMTG, currentPly, slowMover);
---
>       int t1 = minThinkingTime + remaining<OptimumTime>(hypMyTime, hypMTG, ply, slowMover);
>       int t2 = minThinkingTime + remaining<MaxTime    >(hypMyTime, hypMTG, ply, slowMover);
114,115c126,127
<       optimumSearchTime = std::min(optimumSearchTime, t1);
<       maximumSearchTime = std::min(maximumSearchTime, t2);
---
>       optimumTime = std::min(t1, optimumTime);
>       maximumTime = std::min(t2, maximumTime);
119,122c131
<       optimumSearchTime += optimumSearchTime / 4;
< 
<   // Make sure that maxSearchTime is not over absoluteMaxSearchTime
<   optimumSearchTime = std::min(optimumSearchTime, maximumSearchTime);
---
>       optimumTime += optimumTime / 4;
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23,24c24,26
< /// The TimeManager class computes the optimal time to think depending on the
< /// maximum available time, the game move number and other parameters.
---
> #include "misc.h"
> #include "search.h"
> #include "thread.h"
26c28,31
< class TimeManager {
---
> /// The TimeManagement class computes the optimal time to think depending on
> /// the maximum available time, the game move number and other parameters.
> 
> class TimeManagement {
28,31c33,38
<   void init(const Search::LimitsType& limits, int currentPly, Color us);
<   void pv_instability(double bestMoveChanges) { unstablePvFactor = 1 + bestMoveChanges; }
<   int available_time() const { return int(optimumSearchTime * unstablePvFactor * 0.71); }
<   int maximum_time() const { return maximumSearchTime; }
---
>   void init(Search::LimitsType& limits, Color us, int ply);
>   int optimum() const { return optimumTime; }
>   int maximum() const { return maximumTime; }
>   int elapsed() const { return int(Search::Limits.npmsec ? Threads.nodes_searched() : now() - startTime); }
> 
>   int64_t availableNodes; // When in 'nodes as time' mode
34,36c41,43
<   int optimumSearchTime;
<   int maximumSearchTime;
<   double unstablePvFactor;
---
>   TimePoint startTime;
>   int optimumTime;
>   int maximumTime;
37a45,46
> 
> extern TimeManagement Time;
****************************************************************
thread
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
27,28c28
< 
< using namespace Search;
---
> #include "syzygy/tbprobe.h"
32,39c32,33
< extern void check_time();
< 
< namespace {
< 
<  // start_routine() is the C function which is called when a new thread
<  // is launched. It is a wrapper to the virtual function idle_loop().
< 
<  extern "C" { long start_routine(ThreadBase* th) { th->idle_loop(); return 0; } }
---
> /// Thread constructor launches the thread and then waits until it goes to sleep
> /// in idle_loop().
40a35
> Thread::Thread() {
42,57c37,40
<  // Helpers to launch a thread after creation and joining before delete. Must be
<  // outside Thread c'tor and d'tor because the object will be fully initialized
<  // when start_routine (and hence virtual idle_loop) is called and when joining.
< 
<  template<typename T> T* new_thread() {
<    T* th = new T();
<    thread_create(th->handle, start_routine, th); // Will go to sleep
<    return th;
<  }
< 
<  void delete_thread(ThreadBase* th) {
<    th->exit = true; // Search must be already finished
<    th->notify_one();
<    thread_join(th->handle); // Wait for thread termination
<    delete th;
<  }
---
>   resetCalls = exit = false;
>   maxPly = callsCnt = 0;
>   tbHits = 0;
>   idx = Threads.size(); // Start from 0
58a42,45
>   std::unique_lock<Mutex> lk(mutex);
>   searching = true;
>   nativeThread = std::thread(&Thread::idle_loop, this);
>   sleepCondition.wait(lk, [&]{ return !searching; });
62c49
< // notify_one() wakes up the thread when there is some work to do
---
> /// Thread destructor waits for thread termination before returning
64c51
< void ThreadBase::notify_one() {
---
> Thread::~Thread() {
66a54
>   exit = true;
68a57
>   nativeThread.join();
72c61,62
< // wait_for() set the thread to sleep until 'condition' turns true
---
> /// Thread::wait_for_search_finished() waits on sleep condition
> /// until not searching
74c64
< void ThreadBase::wait_for(volatile const bool& condition) {
---
> void Thread::wait_for_search_finished() {
76,78c66,67
<   mutex.lock();
<   while (!condition) sleepCondition.wait(mutex);
<   mutex.unlock();
---
>   std::unique_lock<Mutex> lk(mutex);
>   sleepCondition.wait(lk, [&]{ return !searching; });
82,83c71
< // Thread c'tor just inits data and does not launch any execution thread.
< // Such a thread will only be started when c'tor returns.
---
> /// Thread::wait() waits on sleep condition until condition is true
85c73
< Thread::Thread() /* : splitPoints() */ { // Value-initialization bug in MSVC
---
> void Thread::wait(std::atomic_bool& condition) {
87,91c75,76
<   searching = false;
<   maxPly = splitPointsSize = 0;
<   activeSplitPoint = NULL;
<   activePosition = NULL;
<   idx = Threads.size(); // Starts from 0
---
>   std::unique_lock<Mutex> lk(mutex);
>   sleepCondition.wait(lk, [&]{ return bool(condition); });
95,105c80
< // cutoff_occurred() checks whether a beta cutoff has occurred in the
< // current active split point, or in some ancestor of the split point.
< 
< bool Thread::cutoff_occurred() const {
< 
<   for (SplitPoint* sp = activeSplitPoint; sp; sp = sp->parentSplitPoint)
<       if (sp->cutoff)
<           return true;
< 
<   return false;
< }
---
> /// Thread::start_searching() wakes up the thread that will start the search
106a82
> void Thread::start_searching(bool resume) {
108,113c84
< // Thread::available_to() checks whether the thread is available to help the
< // thread 'master' at a split point. An obvious requirement is that thread must
< // be idle. With more than two threads, this is not sufficient: If the thread is
< // the master of some split point, it is only available as a slave to the slaves
< // which are busy searching the split point at the top of slave's split point
< // stack (the "helpful master concept" in YBWC terminology).
---
>   std::unique_lock<Mutex> lk(mutex);
115,122c86,87
< bool Thread::available_to(const Thread* master) const {
< 
<   if (searching)
<       return false;
< 
<   // Make a local copy to be sure it doesn't become zero under our feet while
<   // testing next condition and so leading to an out of bounds access.
<   const int size = splitPointsSize;
---
>   if (!resume)
>       searching = true;
124,126c89
<   // No split points means that the thread is available as a slave for any
<   // other thread otherwise apply the "helpful master" concept if possible.
<   return !size || splitPoints[size - 1].slavesMask.test(master->idx);
---
>   sleepCondition.notify_one();
130,140c93
< // TimerThread::idle_loop() is where the timer thread waits msec milliseconds
< // and then calls check_time(). If msec is 0 thread sleeps until it's woken up.
< 
< void TimerThread::idle_loop() {
< 
<   while (!exit)
<   {
<       mutex.lock();
< 
<       if (!exit)
<           sleepCondition.wait_for(mutex, run ? Resolution : INT_MAX);
---
> /// Thread::idle_loop() is where the thread is parked when it has no work to do
142c95
<       mutex.unlock();
---
> void Thread::idle_loop() {
144,147c97
<       if (run)
<           check_time();
<   }
< }
---
>   WinProcGroup::bindThisThread(idx);
149,155c99
< 
< // MainThread::idle_loop() is where the main thread is parked waiting to be started
< // when there is a new search. The main thread will launch all the slave threads.
< 
< void MainThread::idle_loop() {
< 
<   while (true)
---
>   while (!exit)
157c101
<       mutex.lock();
---
>       std::unique_lock<Mutex> lk(mutex);
159c103
<       thinking = false;
---
>       searching = false;
161c105
<       while (!thinking && !exit)
---
>       while (!searching && !exit)
163,164c107,108
<           Threads.sleepCondition.notify_one(); // Wake up the UI thread if needed
<           sleepCondition.wait(mutex);
---
>           sleepCondition.notify_one(); // Wake up any waiting thread
>           sleepCondition.wait(lk);
167,170c111
<       mutex.unlock();
< 
<       if (exit)
<           return;
---
>       lk.unlock();
172,178c113,114
<       searching = true;
< 
<       Search::think();
< 
<       assert(searching);
< 
<       searching = false;
---
>       if (!exit)
>           search();
183,186c119,122
< // init() is called at startup to create and launch requested threads, that will
< // go immediately to sleep. We cannot use a c'tor because Threads is a static
< // object and we need a fully initialized engine at this point due to allocation
< // of Endgames in Thread c'tor.
---
> /// ThreadPool::init() creates and launches requested threads that will go
> /// immediately to sleep. We cannot use a constructor because Threads is a
> /// static object and we need a fully initialized engine at this point due to
> /// allocation of Endgames in the Thread constructor.
190,191c126
<   timer = new_thread<TimerThread>();
<   push_back(new_thread<MainThread>());
---
>   push_back(new MainThread());
196,197c131,133
< // exit() cleanly terminates the threads before the program exits. Cannot be done in
< // d'tor because we have to terminate the threads before to free ThreadPool object.
---
> /// ThreadPool::exit() terminates threads before the program exits. Cannot be
> /// done in destructor because threads must be terminated before deleting any
> /// static objects while still in main().
201,204c137,138
<   delete_thread(timer); // As first because check_time() accesses threads data
< 
<   for (iterator it = begin(); it != end(); ++it)
<       delete_thread(*it);
---
>   while (size())
>       delete back(), pop_back();
208,212c142,144
< // read_uci_options() updates internal threads parameters from the corresponding
< // UCI options and creates/destroys threads to match the requested number. Thread
< // objects are dynamically allocated to avoid creating all possible threads
< // in advance (which include pawns and material tables), even if only a few
< // are to be used.
---
> /// ThreadPool::read_uci_options() updates internal threads parameters from the
> /// corresponding UCI options and creates/destroys threads to match requested
> /// number. Thread objects are dynamically allocated.
216,217c148
<   minimumSplitDepth = Options["Min Split Depth"] * ONE_PLY;
<   size_t requested  = Options["Threads"];
---
>   size_t requested = Options["Threads"];
221,224d151
<   // If zero (default) then set best minimum split depth automatically
<   if (!minimumSplitDepth)
<       minimumSplitDepth = requested < 8 ? 4 * ONE_PLY : 7 * ONE_PLY;
< 
226c153
<       push_back(new_thread<Thread>());
---
>       push_back(new Thread());
229,232c156
<   {
<       delete_thread(back());
<       pop_back();
<   }
---
>       delete back(), pop_back();
236,237c160
< // available_slave() tries to find an idle thread which is available as a slave
< // for the thread 'master'.
---
> /// ThreadPool::nodes_searched() returns the number of nodes searched
239c162
< Thread* ThreadPool::available_slave(const Thread* master) const {
---
> uint64_t ThreadPool::nodes_searched() const {
241,297c164,168
<   for (const_iterator it = begin(); it != end(); ++it)
<       if ((*it)->available_to(master))
<           return *it;
< 
<   return NULL;
< }
< 
< 
< // split() does the actual work of distributing the work at a node between
< // several available threads. If it does not succeed in splitting the node
< // (because no idle threads are available), the function immediately returns.
< // If splitting is possible, a SplitPoint object is initialized with all the
< // data that must be copied to the helper threads and then helper threads are
< // told that they have been assigned work. This will cause them to instantly
< // leave their idle loops and call search(). When all threads have returned from
< // search() then split() returns.
< 
< void Thread::split(Position& pos, Stack* ss, Value alpha, Value beta, Value* bestValue,
<                    Move* bestMove, Depth depth, int moveCount,
<                    MovePicker* movePicker, int nodeType, bool cutNode) {
< 
<   assert(pos.pos_is_ok());
<   assert(-VALUE_INFINITE < *bestValue && *bestValue <= alpha && alpha < beta && beta <= VALUE_INFINITE);
<   assert(depth >= Threads.minimumSplitDepth);
<   assert(searching);
<   assert(splitPointsSize < MAX_SPLITPOINTS_PER_THREAD);
< 
<   // Pick the next available split point from the split point stack
<   SplitPoint& sp = splitPoints[splitPointsSize];
< 
<   sp.masterThread = this;
<   sp.parentSplitPoint = activeSplitPoint;
<   sp.slavesMask = 0, sp.slavesMask.set(idx);
<   sp.depth = depth;
<   sp.bestValue = *bestValue;
<   sp.bestMove = *bestMove;
<   sp.alpha = alpha;
<   sp.beta = beta;
<   sp.nodeType = nodeType;
<   sp.cutNode = cutNode;
<   sp.movePicker = movePicker;
<   sp.moveCount = moveCount;
<   sp.pos = &pos;
<   sp.nodes = 0;
<   sp.cutoff = false;
<   sp.ss = ss;
< 
<   // Try to allocate available threads and ask them to start searching setting
<   // 'searching' flag. This must be done under lock protection to avoid concurrent
<   // allocation of the same slave by another master.
<   Threads.mutex.lock();
<   sp.mutex.lock();
< 
<   sp.allSlavesSearching = true; // Must be set under lock protection
<   ++splitPointsSize;
<   activeSplitPoint = &sp;
<   activePosition = NULL;
---
>   uint64_t nodes = 0;
>   for (Thread* th : *this)
>       nodes += th->rootPos.nodes_searched();
>   return nodes;
> }
299,305d169
<   for (Thread* slave; (slave = Threads.available_slave(this)) != NULL; )
<   {
<       sp.slavesMask.set(slave->idx);
<       slave->activeSplitPoint = &sp;
<       slave->searching = true; // Slave leaves idle_loop()
<       slave->notify_one(); // Could be sleeping
<   }
307,326c171
<   // Everything is set up. The master thread enters the idle loop, from which
<   // it will instantly launch a search, because its 'searching' flag is set.
<   // The thread will return from the idle loop when all slaves have finished
<   // their work at this split point.
<   sp.mutex.unlock();
<   Threads.mutex.unlock();
< 
<   Thread::idle_loop(); // Force a call to base class idle_loop()
< 
<   // In the helpful master concept, a master can help only a sub-tree of its
<   // split point and because everything is finished here, it's not possible
<   // for the master to be booked.
<   assert(!searching);
<   assert(!activePosition);
< 
<   // We have returned from the idle loop, which means that all threads are
<   // finished. Note that setting 'searching' and decreasing splitPointsSize is
<   // done under lock protection to avoid a race with Thread::available_to().
<   Threads.mutex.lock();
<   sp.mutex.lock();
---
> /// ThreadPool::tb_hits() returns the number of TB hits
328,334c173
<   searching = true;
<   --splitPointsSize;
<   activeSplitPoint = sp.parentSplitPoint;
<   activePosition = &pos;
<   pos.set_nodes_searched(pos.nodes_searched() + sp.nodes);
<   *bestMove = sp.bestMove;
<   *bestValue = sp.bestValue;
---
> uint64_t ThreadPool::tb_hits() const {
336,337c175,178
<   sp.mutex.unlock();
<   Threads.mutex.unlock();
---
>   uint64_t hits = 0;
>   for (Thread* th : *this)
>       hits += th->tbHits;
>   return hits;
340d180
< // wait_for_think_finished() waits for main thread to go to sleep then returns
342c182,183
< void ThreadPool::wait_for_think_finished() {
---
> /// ThreadPool::start_thinking() wakes up the main thread sleeping in idle_loop()
> /// and starts a new search, then returns immediately.
344,348c185,186
<   MainThread* th = main();
<   th->mutex.lock();
<   while (th->thinking) sleepCondition.wait(th->mutex);
<   th->mutex.unlock();
< }
---
> void ThreadPool::start_thinking(Position& pos, StateListPtr& states,
>                                 const Search::LimitsType& limits) {
349a188
>   main()->wait_for_search_finished();
351,352c190,192
< // start_thinking() wakes up the main thread sleeping in MainThread::idle_loop()
< // so to start a new search, then returns immediately.
---
>   Search::Signals.stopOnPonderhit = Search::Signals.stop = false;
>   Search::Limits = limits;
>   Search::RootMoves rootMoves;
354c194,200
< void ThreadPool::start_thinking(const Position& pos, const LimitsType& limits, StateStackPtr& states) {
---
>   for (const auto& m : MoveList<LEGAL>(pos))
>       if (   limits.searchmoves.empty()
>           || std::count(limits.searchmoves.begin(), limits.searchmoves.end(), m))
>           rootMoves.push_back(Search::RootMove(m));
> 
>   if (!rootMoves.empty())
>       Tablebases::filter_root_moves(pos, rootMoves);
356c202,204
<   wait_for_think_finished();
---
>   // After ownership transfer 'states' becomes empty, so if we stop the search
>   // and call 'go' again without setting a new position states.get() == NULL.
>   assert(states.get() || setupStates.get());
358c206,207
<   SearchTime = Time::now(); // As early as possible
---
>   if (states.get())
>       setupStates = std::move(states); // Ownership transfer, states is now empty
360,361c209
<   Signals.stopOnPonderhit = Signals.firstRootMove = false;
<   Signals.stop = Signals.failedLowAtRoot = false;
---
>   StateInfo tmp = setupStates->back();
363,366c211
<   RootMoves.clear();
<   RootPos = pos;
<   Limits = limits;
<   if (states.get()) // If we don't set a new position, preserve current state
---
>   for (Thread* th : Threads)
368,369c213,217
<       SetupStates = states; // Ownership transfer here
<       assert(!states.get());
---
>       th->maxPly = 0;
>       th->tbHits = 0;
>       th->rootDepth = DEPTH_ZERO;
>       th->rootMoves = rootMoves;
>       th->rootPos.set(pos.fen(), pos.is_chess960(), &setupStates->back(), th);
372,375c220
<   for (MoveList<LEGAL> it(pos); *it; ++it)
<       if (   limits.searchmoves.empty()
<           || std::count(limits.searchmoves.begin(), limits.searchmoves.end(), *it))
<           RootMoves.push_back(RootMove(*it));
---
>   setupStates->back() = tmp; // Restore st->previous, cleared by Position::set()
377,378c222
<   main()->thinking = true;
<   main()->notify_one(); // Starts main thread
---
>   main()->start_searching();
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
22a24
> #include <atomic>
23a26,28
> #include <condition_variable>
> #include <mutex>
> #include <thread>
30a36
> #include "thread_win32.h"
32,33d37
< const int MAX_THREADS = 128;
< const int MAX_SPLITPOINTS_PER_THREAD = 8;
35,37c39,42
< struct Mutex {
<   Mutex() { lock_init(l); }
<  ~Mutex() { lock_destroy(l); }
---
> /// Thread struct keeps together all the thread-related stuff. We also use
> /// per-thread pawn and material hash tables so that once we get a pointer to an
> /// entry its life time is unlimited and we don't have to care about someone
> /// changing the entry under our feet.
39,99c44
<   void lock() { lock_grab(l); }
<   void unlock() { lock_release(l); }
< 
< private:
<   friend struct ConditionVariable;
< 
<   Lock l;
< };
< 
< struct ConditionVariable {
<   ConditionVariable() { cond_init(c); }
<  ~ConditionVariable() { cond_destroy(c); }
< 
<   void wait(Mutex& m) { cond_wait(c, m.l); }
<   void wait_for(Mutex& m, int ms) { timed_wait(c, m.l, ms); }
<   void notify_one() { cond_signal(c); }
< 
< private:
<   WaitCondition c;
< };
< 
< struct Thread;
< 
< struct SplitPoint {
< 
<   // Const data after split point has been setup
<   const Position* pos;
<   Search::Stack* ss;
<   Thread* masterThread;
<   Depth depth;
<   Value beta;
<   int nodeType;
<   bool cutNode;
< 
<   // Const pointers to shared data
<   MovePicker* movePicker;
<   SplitPoint* parentSplitPoint;
< 
<   // Shared data
<   Mutex mutex;
<   std::bitset<MAX_THREADS> slavesMask;
<   volatile bool allSlavesSearching;
<   volatile uint64_t nodes;
<   volatile Value alpha;
<   volatile Value bestValue;
<   volatile Move bestMove;
<   volatile int moveCount;
<   volatile bool cutoff;
< };
< 
< 
< /// ThreadBase struct is the base of the hierarchy from where we derive all the
< /// specialized thread classes.
< 
< struct ThreadBase {
< 
<   ThreadBase() : handle(NativeHandle()), exit(false) {}
<   virtual ~ThreadBase() {}
<   virtual void idle_loop() = 0;
<   void notify_one();
<   void wait_for(volatile const bool& b);
---
> class Thread {
100a46
>   std::thread nativeThread;
103,113c49
<   NativeHandle handle;
<   volatile bool exit;
< };
< 
< 
< /// Thread struct keeps together all the thread related stuff like locks, state
< /// and especially split points. We also use per-thread pawn and material hash
< /// tables so that once we get a pointer to an entry its life time is unlimited
< /// and we don't have to care about someone changing the entry under our feet.
< 
< struct Thread : public ThreadBase {
---
>   bool exit, searching;
114a51
> public:
116,118c53,58
<   virtual void idle_loop();
<   bool cutoff_occurred() const;
<   bool available_to(const Thread* master) const;
---
>   virtual ~Thread();
>   virtual void search();
>   void idle_loop();
>   void start_searching(bool resume = false);
>   void wait_for_search_finished();
>   void wait(std::atomic_bool& condition);
120,123c60
<   void split(Position& pos, Search::Stack* ss, Value alpha, Value beta, Value* bestValue, Move* bestMove,
<              Depth depth, int moveCount, MovePicker* movePicker, int nodeType, bool cutNode);
< 
<   SplitPoint splitPoints[MAX_SPLITPOINTS_PER_THREAD];
---
>   Pawns::Table pawnsTable;
126,132c63,74
<   Pawns::Table pawnsTable;
<   Position* activePosition;
<   size_t idx;
<   int maxPly;
<   SplitPoint* volatile activeSplitPoint;
<   volatile int splitPointsSize;
<   volatile bool searching;
---
>   size_t idx, PVIdx;
>   int maxPly, callsCnt;
>   uint64_t tbHits;
> 
>   Position rootPos;
>   Search::RootMoves rootMoves;
>   Depth rootDepth;
>   Depth completedDepth;
>   std::atomic_bool resetCalls;
>   MoveStats counterMoves;
>   HistoryStats history;
>   CounterMoveHistoryStats counterMoveHistory;
136,137c78
< /// MainThread and TimerThread are derived classes used to characterize the two
< /// special threads: the main one and the recurring timer.
---
> /// MainThread is a derived class with a specific overload for the main thread
140,143c81
<   MainThread() : thinking(true) {} // Avoid a race with start_thinking()
<   virtual void idle_loop();
<   volatile bool thinking;
< };
---
>   virtual void search();
145,149c83,85
< struct TimerThread : public ThreadBase {
<   TimerThread() : run(false) {}
<   virtual void idle_loop();
<   bool run;
<   static const int Resolution = 5; // msec between two check_time() calls
---
>   bool easyMovePlayed, failedLow;
>   double bestMoveChanges;
>   Value previousScore;
153,155c89,91
< /// ThreadPool struct handles all the threads related stuff like init, starting,
< /// parking and, most importantly, launching a slave thread at a split point.
< /// All the access to shared thread data is done through this class.
---
> /// ThreadPool struct handles all the threads-related stuff like init, starting,
> /// parking and, most importantly, launching a thread. All the access to threads
> /// data is done through this class.
159,160c95,96
<   void init(); // No c'tor and d'tor, threads rely on globals that should
<   void exit(); // be initialized and are valid during the whole thread lifetime.
---
>   void init(); // No constructor and destructor, threads rely on globals that should
>   void exit(); // be initialized and valid during the whole thread lifetime.
162c98,99
<   MainThread* main() { return static_cast<MainThread*>((*this)[0]); }
---
>   MainThread* main() { return static_cast<MainThread*>(at(0)); }
>   void start_thinking(Position&, StateListPtr&, const Search::LimitsType&);
164,166c101,102
<   Thread* available_slave(const Thread* master) const;
<   void wait_for_think_finished();
<   void start_thinking(const Position&, const Search::LimitsType&, Search::StateStackPtr&);
---
>   uint64_t nodes_searched() const;
>   uint64_t tb_hits() const;
168,171c104,105
<   Depth minimumSplitDepth;
<   Mutex mutex;
<   ConditionVariable sleepCondition;
<   TimerThread* timer;
---
> private:
>   StateListPtr setupStates;
****************************************************************
search
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23c24
< #include <cstring>
---
> #include <cstring>   // For std::memset
30a32
> #include "position.h"
40c42
<   volatile SignalsType Signals;
---
>   SignalsType Signals;
42,45d43
<   RootMoveVector RootMoves;
<   Position RootPos;
<   Time::point SearchTime;
<   StateStackPtr SetupStates;
51d48
<   uint64_t Hits;
66,67c63,64
<   // Different node types, used as template parameter
<   enum NodeType { Root, PV, NonPV };
---
>   // Different node types, used as a template parameter
>   enum NodeType { NonPV, PV };
69,70c66,68
<   // Dynamic razoring margin based on depth
<   inline Value razor_margin(Depth d) { return Value(512 + 32 * d); }
---
>   // Razoring and futility margin based on depth
>   const int razor_margin[4] = { 483, 570, 603, 554 };
>   Value futility_margin(Depth d) { return Value(150 * d / ONE_PLY); }
72c70
<   // Futility lookup tables (initialized at startup) and their access functions
---
>   // Futility and reductions lookup tables, initialized at startup
73a72
>   int Reductions[2][2][64][64];  // [pv][improving][depth][moveNumber]
75,76c74,75
<   inline Value futility_margin(Depth d) {
<     return Value(200 * d);
---
>   template <bool PvNode> Depth reduction(bool i, Depth d, int mn) {
>     return Reductions[PvNode][i][std::min(d / ONE_PLY, 63)][std::min(mn, 63)] * ONE_PLY;
79,83c78,81
<   // Reduction lookup tables (initialized at startup) and their access function
<   int8_t Reductions[2][2][64][64]; // [pv][improving][depth][moveNumber]
< 
<   template <bool PvNode> inline Depth reduction(bool i, Depth d, int mn) {
<     return (Depth) Reductions[PvNode][i][std::min(int(d), 63)][std::min(mn, 63)];
---
>   // History and stats update bonus, based on depth
>   Value stat_bonus(Depth depth) {
>     int d = depth / ONE_PLY ;
>     return Value(d * d + 2 * d - 2);
86,92c84,90
<   size_t PVIdx;
<   TimeManager TimeMgr;
<   double BestMoveChanges;
<   Value DrawValue[COLOR_NB];
<   HistoryStats History;
<   GainsStats Gains;
<   MovesStats Countermoves, Followupmoves;
---
>   // Skill structure is used to implement strength limit
>   struct Skill {
>     Skill(int l) : level(l) {}
>     bool enabled() const { return level < 20; }
>     bool time_to_pick(Depth depth) const { return depth / ONE_PLY == 1 + level; }
>     Move best_move(size_t multiPV) { return best ? best : pick_best(multiPV); }
>     Move pick_best(size_t multiPV);
94,95c92,94
<   template <NodeType NT, bool SpNode>
<   Value search(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode);
---
>     int level;
>     Move best = MOVE_NONE;
>   };
97,98c96,98
<   template <NodeType NT, bool InCheck>
<   Value qsearch(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth);
---
>   // EasyMoveManager structure is used to detect an 'easy move'. When the PV is
>   // stable across multiple search iterations, we can quickly return the best move.
>   struct EasyMoveManager {
100,105c100,104
<   void id_loop(Position& pos);
<   Value value_to_tt(Value v, int ply);
<   Value value_from_tt(Value v, int ply);
<   void update_pv(Move* pv, Move move, Move* childPv);
<   void update_stats(const Position& pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt);
<   string uci_pv(const Position& pos, Depth depth, Value alpha, Value beta);
---
>     void clear() {
>       stableCnt = 0;
>       expectedPosKey = 0;
>       pv[0] = pv[1] = pv[2] = MOVE_NONE;
>     }
107,114c106,107
<   struct Skill {
<     Skill(int l, size_t rootSize) : level(l),
<                                     candidates(l < 20 ? std::min(4, (int)rootSize) : 0),
<                                     best(MOVE_NONE) {}
<    ~Skill() {
<       if (candidates) // Swap best PV line with the sub-optimal one
<           std::swap(RootMoves[0], *std::find(RootMoves.begin(),
<                     RootMoves.end(), best ? best : pick_move()));
---
>     Move get(Key key) const {
>       return expectedPosKey == key ? pv[2] : MOVE_NONE;
117,119c110
<     size_t candidates_size() const { return candidates; }
<     bool time_to_pick(Depth depth) const { return depth / ONE_PLY == 1 + level; }
<     Move pick_move();
---
>     void update(Position& pos, const std::vector<Move>& newPv) {
121,123c112,159
<     int level;
<     size_t candidates;
<     Move best;
---
>       assert(newPv.size() >= 3);
> 
>       // Keep track of how many times in a row the 3rd ply remains stable
>       stableCnt = (newPv[2] == pv[2]) ? stableCnt + 1 : 0;
> 
>       if (!std::equal(newPv.begin(), newPv.begin() + 3, pv))
>       {
>           std::copy(newPv.begin(), newPv.begin() + 3, pv);
> 
>           StateInfo st[2];
>           pos.do_move(newPv[0], st[0]);
>           pos.do_move(newPv[1], st[1]);
>           expectedPosKey = pos.key();
>           pos.undo_move(newPv[1]);
>           pos.undo_move(newPv[0]);
>       }
>     }
> 
>     int stableCnt;
>     Key expectedPosKey;
>     Move pv[3];
>   };
> 
>   // Set of rows with half bits set to 1 and half to 0. It is used to allocate
>   // the search depths across the threads.
>   typedef std::vector<int> Row;
> 
>   const Row HalfDensity[] = {
>     {0, 1},
>     {1, 0},
>     {0, 0, 1, 1},
>     {0, 1, 1, 0},
>     {1, 1, 0, 0},
>     {1, 0, 0, 1},
>     {0, 0, 0, 1, 1, 1},
>     {0, 0, 1, 1, 1, 0},
>     {0, 1, 1, 1, 0, 0},
>     {1, 1, 1, 0, 0, 0},
>     {1, 1, 0, 0, 0, 1},
>     {1, 0, 0, 0, 1, 1},
>     {0, 0, 0, 0, 1, 1, 1, 1},
>     {0, 0, 0, 1, 1, 1, 1, 0},
>     {0, 0, 1, 1, 1, 1, 0 ,0},
>     {0, 1, 1, 1, 1, 0, 0 ,0},
>     {1, 1, 1, 1, 0, 0, 0 ,0},
>     {1, 1, 1, 0, 0, 0, 0 ,1},
>     {1, 1, 0, 0, 0, 0, 1 ,1},
>     {1, 0, 0, 0, 0, 1, 1 ,1},
125a162,179
>   const size_t HalfDensitySize = std::extent<decltype(HalfDensity)>::value;
> 
>   EasyMoveManager EasyMove;
>   Value DrawValue[COLOR_NB];
> 
>   template <NodeType NT>
>   Value search(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode, bool skipEarlyPruning);
> 
>   template <NodeType NT, bool InCheck>
>   Value qsearch(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth = DEPTH_ZERO);
> 
>   Value value_to_tt(Value v, int ply);
>   Value value_from_tt(Value v, int ply);
>   void update_pv(Move* pv, Move move, Move* childPv);
>   void update_cm_stats(Stack* ss, Piece pc, Square s, Value bonus);
>   void update_stats(const Position& pos, Stack* ss, Move move, Move* quiets, int quietsCnt, Value bonus);
>   void check_time();
> 
133,141c187,191
<   // Init reductions array
<   for (int d = 1; d < 64; ++d)
<       for (int mc = 1; mc < 64; ++mc)
<       {
<           double    pvRed = 0.00 + log(double(d)) * log(double(mc)) / 3.00;
<           double nonPVRed = 0.33 + log(double(d)) * log(double(mc)) / 2.25;
< 
<           Reductions[1][1][d][mc] = int8_t(   pvRed >= 1.0 ?    pvRed + 0.5: 0);
<           Reductions[0][1][d][mc] = int8_t(nonPVRed >= 1.0 ? nonPVRed + 0.5: 0);
---
>   for (int imp = 0; imp <= 1; ++imp)
>       for (int d = 1; d < 64; ++d)
>           for (int mc = 1; mc < 64; ++mc)
>           {
>               double r = log(d) * log(mc) / 2;
143,144c193,194
<           Reductions[1][0][d][mc] = Reductions[1][1][d][mc];
<           Reductions[0][0][d][mc] = Reductions[0][1][d][mc];
---
>               Reductions[NonPV][imp][d][mc] = int(std::round(r));
>               Reductions[PV][imp][d][mc] = std::max(Reductions[NonPV][imp][d][mc] - 1, 0);
146,149c196,199
<           // Increase reduction when eval is not improving
<           if (Reductions[0][0][d][mc] >= 2)
<               Reductions[0][0][d][mc] += 1;
<       }
---
>               // Increase reduction for non-PV nodes when eval is not improving
>               if (!imp && Reductions[NonPV][imp][d][mc] >= 2)
>                 Reductions[NonPV][imp][d][mc]++;
>           }
151d200
<   // Init futility move count array
159a209,226
> /// Search::clear() resets search state to zero, to obtain reproducible results
> 
> void Search::clear() {
> 
>   TT.clear();
> 
>   for (Thread* th : Threads)
>   {
>       th->counterMoves.clear();
>       th->history.clear();
>       th->counterMoveHistory.clear();
>       th->resetCalls = true;
>   }
> 
>   Threads.main()->previousScore = VALUE_INFINITE;
> }
> 
> 
161c228
< /// up to the given depth are generated and counted and the sum returned.
---
> /// up to the given depth are generated and counted, and the sum is returned.
167d233
<   CheckInfo ci(pos);
170c236
<   for (MoveList<LEGAL> it(pos); *it; ++it)
---
>   for (const auto& m : MoveList<LEGAL>(pos))
176c242
<           pos.do_move(*it, st, ci, pos.gives_check(*it, ci));
---
>           pos.do_move(m, st);
179c245
<           pos.undo_move(*it);
---
>           pos.undo_move(m);
182c248
<           sync_cout << UCI::move(*it, pos.is_chess960()) << ": " << cnt << sync_endl;
---
>           sync_cout << UCI::move(m, pos.is_chess960()) << ": " << cnt << sync_endl;
187c253
< template uint64_t Search::perft<true>(Position& pos, Depth depth);
---
> template uint64_t Search::perft<true>(Position&, Depth);
190,192c256,257
< /// Search::think() is the external interface to Stockfish's search, and is
< /// called by the main thread when the program receives the UCI 'go' command. It
< /// searches from RootPos and at the end prints the "bestmove" to output.
---
> /// MainThread::search() is called by the main thread when the program receives
> /// the UCI 'go' command. It searches from the root position and outputs the "bestmove".
194c259
< void Search::think() {
---
> void MainThread::search() {
196c261,262
<   TimeMgr.init(Limits, RootPos.game_ply(), RootPos.side_to_move());
---
>   Color us = rootPos.side_to_move();
>   Time.init(Limits, us, rootPos.game_ply());
199,206c265,266
<   DrawValue[ RootPos.side_to_move()] = VALUE_DRAW - Value(contempt);
<   DrawValue[~RootPos.side_to_move()] = VALUE_DRAW + Value(contempt);
< 
<   TB::Hits = 0;
<   TB::RootInTB = false;
<   TB::UseRule50 = Options["Syzygy50MoveRule"];
<   TB::ProbeDepth = Options["SyzygyProbeDepth"] * ONE_PLY;
<   TB::Cardinality = Options["SyzygyProbeLimit"];
---
>   DrawValue[ us] = VALUE_DRAW - Value(contempt);
>   DrawValue[~us] = VALUE_DRAW + Value(contempt);
208,209c268
<   // Skip TB probing when no TB found: !TBLargest -> !TB::Cardinality
<   if (TB::Cardinality > TB::MaxCardinality)
---
>   if (rootMoves.empty())
211,217c270
<       TB::Cardinality = TB::MaxCardinality;
<       TB::ProbeDepth = DEPTH_ZERO;
<   }
< 
<   if (RootMoves.empty())
<   {
<       RootMoves.push_back(MOVE_NONE);
---
>       rootMoves.push_back(RootMove(MOVE_NONE));
219c272
<                 << UCI::value(RootPos.checkers() ? -VALUE_MATE : VALUE_DRAW)
---
>                 << UCI::value(rootPos.checkers() ? -VALUE_MATE : VALUE_DRAW)
224,229c277,279
<       if (TB::Cardinality >=  RootPos.count<ALL_PIECES>(WHITE)
<                             + RootPos.count<ALL_PIECES>(BLACK))
<       {
<           // If the current root position is in the tablebases then RootMoves
<           // contains only moves that preserve the draw or win.
<           TB::RootInTB = Tablebases::root_probe(RootPos, RootMoves, TB::Score);
---
>       for (Thread* th : Threads)
>           if (th != this)
>               th->start_searching();
231,263c281
<           if (TB::RootInTB)
<               TB::Cardinality = 0; // Do not probe tablebases during the search
< 
<           else // If DTZ tables are missing, use WDL tables as a fallback
<           {
<               // Filter out moves that do not preserve a draw or win
<               TB::RootInTB = Tablebases::root_probe_wdl(RootPos, RootMoves, TB::Score);
< 
<               // Only probe during search if winning
<               if (TB::Score <= VALUE_DRAW)
<                   TB::Cardinality = 0;
<           }
< 
<           if (TB::RootInTB)
<           {
<               TB::Hits = RootMoves.size();
< 
<               if (!TB::UseRule50)
<                   TB::Score =  TB::Score > VALUE_DRAW ?  VALUE_MATE - MAX_PLY - 1
<                              : TB::Score < VALUE_DRAW ? -VALUE_MATE + MAX_PLY + 1
<                                                       :  VALUE_DRAW;
<           }
<       }
< 
<       for (size_t i = 0; i < Threads.size(); ++i)
<           Threads[i]->maxPly = 0;
< 
<       Threads.timer->run = true;
<       Threads.timer->notify_one(); // Wake up the recurring timer
< 
<       id_loop(RootPos); // Let's start searching !
< 
<       Threads.timer->run = false;
---
>       Thread::search(); // Let's start searching!
265a284,288
>   // When playing in 'nodes as time' mode, subtract the searched nodes from
>   // the available ones before exiting.
>   if (Limits.npmsec)
>       Time.availableNodes += Limits.inc[us] - Threads.nodes_searched();
> 
274c297,323
<       RootPos.this_thread()->wait_for(Signals.stop);
---
>       wait(Signals.stop);
>   }
> 
>   // Stop the threads if not already stopped
>   Signals.stop = true;
> 
>   // Wait until all threads have finished
>   for (Thread* th : Threads)
>       if (th != this)
>           th->wait_for_search_finished();
> 
>   // Check if there are threads with a better score than main thread
>   Thread* bestThread = this;
>   if (   !this->easyMovePlayed
>       &&  Options["MultiPV"] == 1
>       && !Limits.depth
>       && !Skill(Options["Skill Level"]).enabled()
>       &&  rootMoves[0].pv[0] != MOVE_NONE)
>   {
>       for (Thread* th : Threads)
>       {
>           Depth depthDiff = th->completedDepth - bestThread->completedDepth;
>           Value scoreDiff = th->rootMoves[0].score - bestThread->rootMoves[0].score;
> 
>           if (scoreDiff > 0 && depthDiff >= 0)
>               bestThread = th;
>       }
277c326,330
<   sync_cout << "bestmove " << UCI::move(RootMoves[0].pv[0], RootPos.is_chess960());
---
>   previousScore = bestThread->rootMoves[0].score;
> 
>   // Send new PV when needed
>   if (bestThread != this)
>       sync_cout << UCI::pv(bestThread->rootPos, bestThread->completedDepth, -VALUE_INFINITE, VALUE_INFINITE) << sync_endl;
279,280c332,335
<   if (RootMoves[0].pv.size() > 1)
<       std::cout << " ponder " << UCI::move(RootMoves[0].pv[1], RootPos.is_chess960());
---
>   sync_cout << "bestmove " << UCI::move(bestThread->rootMoves[0].pv[0], rootPos.is_chess960());
> 
>   if (bestThread->rootMoves[0].pv.size() > 1 || bestThread->rootMoves[0].extract_ponder_from_tt(rootPos))
>       std::cout << " ponder " << UCI::move(bestThread->rootMoves[0].pv[1], rootPos.is_chess960());
286c341,343
< namespace {
---
> // Thread::search() is the main iterative deepening loop. It calls search()
> // repeatedly with increasing depth until the allocated thinking time has been
> // consumed, the user stops the search, or the maximum search depth is reached.
288,290c345
<   // id_loop() is the main iterative deepening loop. It calls search() repeatedly
<   // with increasing depth until the allocated thinking time has been consumed,
<   // user stops the search, or the maximum search depth is reached.
---
> void Thread::search() {
292c347,350
<   void id_loop(Position& pos) {
---
>   Stack stack[MAX_PLY+7], *ss = stack+4; // To allow referencing (ss-4) and (ss+2)
>   Value bestValue, alpha, beta, delta;
>   Move easyMove = MOVE_NONE;
>   MainThread* mainThread = (this == Threads.main() ? Threads.main() : nullptr);
294,296c352
<     Stack stack[MAX_PLY+4], *ss = stack+2; // To allow referencing (ss-2) and (ss+2)
<     Depth depth;
<     Value bestValue, alpha, beta, delta;
---
>   std::memset(ss-4, 0, 7 * sizeof(Stack));
298c354,356
<     std::memset(ss-2, 0, 5 * sizeof(Stack));
---
>   bestValue = delta = alpha = -VALUE_INFINITE;
>   beta = VALUE_INFINITE;
>   completedDepth = DEPTH_ZERO;
300,303c358,389
<     depth = DEPTH_ZERO;
<     BestMoveChanges = 0;
<     bestValue = delta = alpha = -VALUE_INFINITE;
<     beta = VALUE_INFINITE;
---
>   if (mainThread)
>   {
>       easyMove = EasyMove.get(rootPos.key());
>       EasyMove.clear();
>       mainThread->easyMovePlayed = mainThread->failedLow = false;
>       mainThread->bestMoveChanges = 0;
>       TT.new_search();
>   }
> 
>   size_t multiPV = Options["MultiPV"];
>   Skill skill(Options["Skill Level"]);
> 
>   // When playing with strength handicap enable MultiPV search that we will
>   // use behind the scenes to retrieve a set of possible moves.
>   if (skill.enabled())
>       multiPV = std::max(multiPV, (size_t)4);
> 
>   multiPV = std::min(multiPV, rootMoves.size());
> 
>   // Iterative deepening loop until requested to stop or the target depth is reached
>   while (   (rootDepth += ONE_PLY) < DEPTH_MAX
>          && !Signals.stop
>          && (!Limits.depth || Threads.main()->rootDepth / ONE_PLY <= Limits.depth))
>   {
>       // Set up the new depths for the helper threads skipping on average every
>       // 2nd ply (using a half-density matrix).
>       if (!mainThread)
>       {
>           const Row& row = HalfDensity[(idx - 1) % HalfDensitySize];
>           if (row[(rootDepth / ONE_PLY + rootPos.game_ply()) % row.size()])
>              continue;
>       }
305,309c391,398
<     TT.new_search();
<     History.clear();
<     Gains.clear();
<     Countermoves.clear();
<     Followupmoves.clear();
---
>       // Age out PV variability metric
>       if (mainThread)
>           mainThread->bestMoveChanges *= 0.505, mainThread->failedLow = false;
> 
>       // Save the last iteration's scores before first PV line is searched and
>       // all the move scores except the (new) PV are set to -VALUE_INFINITE.
>       for (RootMove& rm : rootMoves)
>           rm.previousScore = rm.score;
311,312c400,409
<     size_t multiPV = Options["MultiPV"];
<     Skill skill(Options["Skill Level"], RootMoves.size());
---
>       // MultiPV loop. We perform a full root search for each PV line
>       for (PVIdx = 0; PVIdx < multiPV && !Signals.stop; ++PVIdx)
>       {
>           // Reset aspiration window starting size
>           if (rootDepth >= 5 * ONE_PLY)
>           {
>               delta = Value(18);
>               alpha = std::max(rootMoves[PVIdx].previousScore - delta,-VALUE_INFINITE);
>               beta  = std::min(rootMoves[PVIdx].previousScore + delta, VALUE_INFINITE);
>           }
314,316c411,416
<     // Do we have to play with skill handicap? In this case enable MultiPV search
<     // that we will use behind the scenes to retrieve a set of possible moves.
<     multiPV = std::max(multiPV, skill.candidates_size());
---
>           // Start with a small aspiration window and, in the case of a fail
>           // high/low, re-search with a bigger window until we're not failing
>           // high/low anymore.
>           while (true)
>           {
>               bestValue = ::search<PV>(rootPos, ss, alpha, beta, rootDepth, false, false);
318,322c418,430
<     // Iterative deepening loop until requested to stop or target depth reached
<     while (++depth < DEPTH_MAX && !Signals.stop && (!Limits.depth || depth <= Limits.depth))
<     {
<         // Age out PV variability metric
<         BestMoveChanges *= 0.5;
---
>               // Bring the best move to the front. It is critical that sorting
>               // is done with a stable algorithm because all the values but the
>               // first and eventually the new best one are set to -VALUE_INFINITE
>               // and we want to keep the same order for all the moves except the
>               // new PV that goes to the front. Note that in case of MultiPV
>               // search the already searched PV lines are preserved.
>               std::stable_sort(rootMoves.begin() + PVIdx, rootMoves.end());
> 
>               // If search has been stopped, break immediately. Sorting and
>               // writing PV back to TT is safe because RootMoves is still
>               // valid, although it refers to the previous iteration.
>               if (Signals.stop)
>                   break;
324,327c432,445
<         // Save the last iteration's scores before first PV line is searched and
<         // all the move scores except the (new) PV are set to -VALUE_INFINITE.
<         for (size_t i = 0; i < RootMoves.size(); ++i)
<             RootMoves[i].previousScore = RootMoves[i].score;
---
>               // When failing high/low give some update (without cluttering
>               // the UI) before a re-search.
>               if (   mainThread
>                   && multiPV == 1
>                   && (bestValue <= alpha || bestValue >= beta)
>                   && Time.elapsed() > 3000)
>                   sync_cout << UCI::pv(rootPos, rootDepth, alpha, beta) << sync_endl;
> 
>               // In case of failing low/high increase aspiration window and
>               // re-search, otherwise exit the loop.
>               if (bestValue <= alpha)
>               {
>                   beta = (alpha + beta) / 2;
>                   alpha = std::max(bestValue - delta, -VALUE_INFINITE);
329,338c447,459
<         // MultiPV loop. We perform a full root search for each PV line
<         for (PVIdx = 0; PVIdx < std::min(multiPV, RootMoves.size()) && !Signals.stop; ++PVIdx)
<         {
<             // Reset aspiration window starting size
<             if (depth >= 5 * ONE_PLY)
<             {
<                 delta = Value(16);
<                 alpha = std::max(RootMoves[PVIdx].previousScore - delta,-VALUE_INFINITE);
<                 beta  = std::min(RootMoves[PVIdx].previousScore + delta, VALUE_INFINITE);
<             }
---
>                   if (mainThread)
>                   {
>                       mainThread->failedLow = true;
>                       Signals.stopOnPonderhit = false;
>                   }
>               }
>               else if (bestValue >= beta)
>               {
>                   alpha = (alpha + beta) / 2;
>                   beta = std::min(bestValue + delta, VALUE_INFINITE);
>               }
>               else
>                   break;
340,345c461
<             // Start with a small aspiration window and, in the case of a fail
<             // high/low, re-search with a bigger window until we're not failing
<             // high/low anymore.
<             while (true)
<             {
<                 bestValue = search<Root, false>(pos, ss, alpha, beta, depth, false);
---
>               delta += delta / 4 + 5;
347,388c463,464
<                 // Bring the best move to the front. It is critical that sorting
<                 // is done with a stable algorithm because all the values but the
<                 // first and eventually the new best one are set to -VALUE_INFINITE
<                 // and we want to keep the same order for all the moves except the
<                 // new PV that goes to the front. Note that in case of MultiPV
<                 // search the already searched PV lines are preserved.
<                 std::stable_sort(RootMoves.begin() + PVIdx, RootMoves.end());
< 
<                 // Write PV back to transposition table in case the relevant
<                 // entries have been overwritten during the search.
<                 for (size_t i = 0; i <= PVIdx; ++i)
<                     RootMoves[i].insert_pv_in_tt(pos);
< 
<                 // If search has been stopped break immediately. Sorting and
<                 // writing PV back to TT is safe because RootMoves is still
<                 // valid, although it refers to previous iteration.
<                 if (Signals.stop)
<                     break;
< 
<                 // When failing high/low give some update (without cluttering
<                 // the UI) before a re-search.
<                 if (  (bestValue <= alpha || bestValue >= beta)
<                     && Time::now() - SearchTime > 3000)
<                     sync_cout << uci_pv(pos, depth, alpha, beta) << sync_endl;
< 
<                 // In case of failing low/high increase aspiration window and
<                 // re-search, otherwise exit the loop.
<                 if (bestValue <= alpha)
<                 {
<                     beta = (alpha + beta) / 2;
<                     alpha = std::max(bestValue - delta, -VALUE_INFINITE);
< 
<                     Signals.failedLowAtRoot = true;
<                     Signals.stopOnPonderhit = false;
<                 }
<                 else if (bestValue >= beta)
<                 {
<                     alpha = (alpha + beta) / 2;
<                     beta = std::min(bestValue + delta, VALUE_INFINITE);
<                 }
<                 else
<                     break;
---
>               assert(alpha >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
>           }
390c466,467
<                 delta += delta / 2;
---
>           // Sort the PV lines searched so far and update the GUI
>           std::stable_sort(rootMoves.begin(), rootMoves.begin() + PVIdx + 1);
392,393c469,470
<                 assert(alpha >= -VALUE_INFINITE && beta <= VALUE_INFINITE);
<             }
---
>           if (!mainThread)
>               continue;
395,396c472,474
<             // Sort the PV lines searched so far and update the GUI
<             std::stable_sort(RootMoves.begin(), RootMoves.begin() + PVIdx + 1);
---
>           if (Signals.stop || PVIdx + 1 == multiPV || Time.elapsed() > 3000)
>               sync_cout << UCI::pv(rootPos, rootDepth, alpha, beta) << sync_endl;
>       }
398,405c476,477
<             if (Signals.stop)
<                 sync_cout << "info nodes " << RootPos.nodes_searched()
<                           << " time " << Time::now() - SearchTime << sync_endl;
< 
<             else if (   PVIdx + 1 == std::min(multiPV, RootMoves.size())
<                      || Time::now() - SearchTime > 3000)
<                 sync_cout << uci_pv(pos, depth, alpha, beta) << sync_endl;
<         }
---
>       if (!Signals.stop)
>           completedDepth = rootDepth;
407,415c479,480
<         // If skill levels are enabled and time is up, pick a sub-optimal best move
<         if (skill.candidates_size() && skill.time_to_pick(depth))
<             skill.pick_move();
< 
<         // Have we found a "mate in x"?
<         if (   Limits.mate
<             && bestValue >= VALUE_MATE_IN_MAX_PLY
<             && VALUE_MATE - bestValue <= 2 * Limits.mate)
<             Signals.stop = true;
---
>       if (!mainThread)
>           continue;
417,437c482,527
<         // Do we have time for the next iteration? Can we stop searching now?
<         if (Limits.use_time_management() && !Signals.stop && !Signals.stopOnPonderhit)
<         {
<             // Take some extra time if the best move has changed
<             if (depth > 4 * ONE_PLY && multiPV == 1)
<                 TimeMgr.pv_instability(BestMoveChanges);
< 
<             // Stop the search if only one legal move is available or all
<             // of the available time has been used.
<             if (   RootMoves.size() == 1
<                 || Time::now() - SearchTime > TimeMgr.available_time())
<             {
<                 // If we are allowed to ponder do not stop the search now but
<                 // keep pondering until the GUI sends "ponderhit" or "stop".
<                 if (Limits.ponder)
<                     Signals.stopOnPonderhit = true;
<                 else
<                     Signals.stop = true;
<             }
<         }
<     }
---
>       // If skill level is enabled and time is up, pick a sub-optimal best move
>       if (skill.enabled() && skill.time_to_pick(rootDepth))
>           skill.pick_best(multiPV);
> 
>       // Have we found a "mate in x"?
>       if (   Limits.mate
>           && bestValue >= VALUE_MATE_IN_MAX_PLY
>           && VALUE_MATE - bestValue <= 2 * Limits.mate)
>           Signals.stop = true;
> 
>       // Do we have time for the next iteration? Can we stop searching now?
>       if (Limits.use_time_management())
>       {
>           if (!Signals.stop && !Signals.stopOnPonderhit)
>           {
>               // Stop the search if only one legal move is available, or if all
>               // of the available time has been used, or if we matched an easyMove
>               // from the previous search and just did a fast verification.
>               const int F[] = { mainThread->failedLow,
>                                 bestValue - mainThread->previousScore };
> 
>               int improvingFactor = std::max(229, std::min(715, 357 + 119 * F[0] - 6 * F[1]));
>               double unstablePvFactor = 1 + mainThread->bestMoveChanges;
> 
>               bool doEasyMove =   rootMoves[0].pv[0] == easyMove
>                                && mainThread->bestMoveChanges < 0.03
>                                && Time.elapsed() > Time.optimum() * 5 / 42;
> 
>               if (   rootMoves.size() == 1
>                   || Time.elapsed() > Time.optimum() * unstablePvFactor * improvingFactor / 628
>                   || (mainThread->easyMovePlayed = doEasyMove, doEasyMove))
>               {
>                   // If we are allowed to ponder do not stop the search now but
>                   // keep pondering until the GUI sends "ponderhit" or "stop".
>                   if (Limits.ponder)
>                       Signals.stopOnPonderhit = true;
>                   else
>                       Signals.stop = true;
>               }
>           }
> 
>           if (rootMoves[0].pv.size() >= 3)
>               EasyMove.update(rootPos, rootMoves[0].pv);
>           else
>               EasyMove.clear();
>       }
439a530,531
>   if (!mainThread)
>       return;
441,446c533,545
<   // search<>() is the main search function for both PV and non-PV nodes and for
<   // normal and SplitPoint nodes. When called just after a split point the search
<   // is simpler because we have already probed the hash table, done a null move
<   // search, and searched the first move before splitting, so we don't have to
<   // repeat all this work again. We also don't need to store anything to the hash
<   // table here: This is taken care of after we return from the split point.
---
>   // Clear any candidate easy move that wasn't stable for the last search
>   // iterations; the second condition prevents consecutive fast moves.
>   if (EasyMove.stableCnt < 6 || mainThread->easyMovePlayed)
>       EasyMove.clear();
> 
>   // If skill level is enabled, swap best PV line with the sub-optimal one
>   if (skill.enabled())
>       std::swap(rootMoves[0], *std::find(rootMoves.begin(),
>                 rootMoves.end(), skill.best_move(multiPV)));
> }
> 
> 
> namespace {
448,449c547
<   template <NodeType NT, bool SpNode>
<   Value search(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode) {
---
>   // search<>() is the main search function for both PV and non-PV nodes
451,452c549,553
<     const bool RootNode = NT == Root;
<     const bool PvNode   = NT == PV || NT == Root;
---
>   template <NodeType NT>
>   Value search(Position& pos, Stack* ss, Value alpha, Value beta, Depth depth, bool cutNode, bool skipEarlyPruning) {
> 
>     const bool PvNode = NT == PV;
>     const bool rootNode = PvNode && (ss-1)->ply == 0;
456c557,559
<     assert(depth > DEPTH_ZERO);
---
>     assert(DEPTH_ZERO < depth && depth < DEPTH_MAX);
>     assert(!(PvNode && cutNode));
>     assert(depth / ONE_PLY * ONE_PLY == depth);
461d563
<     SplitPoint* splitPoint;
464,465c566,567
<     Depth extension, newDepth, predictedDepth;
<     Value bestValue, value, ttValue, eval, nullValue, futilityValue;
---
>     Depth extension, newDepth;
>     Value bestValue, value, ttValue, eval, nullValue;
467c569,570
<     bool captureOrPromotion, dangerous, doFullDepthSearch;
---
>     bool captureOrPromotion, doFullDepthSearch, moveCountPruning;
>     Piece moved_piece;
472a576,579
>     moveCount = quietCount =  ss->moveCount = 0;
>     ss->history = VALUE_ZERO;
>     bestValue = -VALUE_INFINITE;
>     ss->ply = (ss-1)->ply + 1;
474c581,582
<     if (SpNode)
---
>     // Check for the available remaining time
>     if (thisThread->resetCalls.load(std::memory_order_relaxed))
476,482c584,589
<         splitPoint = ss->splitPoint;
<         bestMove   = splitPoint->bestMove;
<         bestValue  = splitPoint->bestValue;
<         tte = NULL;
<         ttHit = false;
<         ttMove = excludedMove = MOVE_NONE;
<         ttValue = VALUE_NONE;
---
>         thisThread->resetCalls = false;
>         // At low node count increase the checking rate to about 0.1% of nodes
>         // otherwise use a default value.
>         thisThread->callsCnt = Limits.nodes ? std::min((int64_t)4096, Limits.nodes / 1024)
>                                             : 4096;
>     }
484c591,594
<         assert(splitPoint->bestValue > -VALUE_INFINITE && splitPoint->moveCount > 0);
---
>     if (--thisThread->callsCnt <= 0)
>     {
>         for (Thread* th : Threads)
>             th->resetCalls = true;
486c596
<         goto moves_loop;
---
>         check_time();
489,492d598
<     moveCount = quietCount = 0;
<     bestValue = -VALUE_INFINITE;
<     ss->ply = (ss-1)->ply + 1;
< 
497c603
<     if (!RootNode)
---
>     if (!rootNode)
500,501c606,608
<         if (Signals.stop || pos.is_draw() || ss->ply >= MAX_PLY)
<             return ss->ply >= MAX_PLY && !inCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
---
>         if (Signals.stop.load(std::memory_order_relaxed) || pos.is_draw(ss->ply) || ss->ply >= MAX_PLY)
>             return ss->ply >= MAX_PLY && !inCheck ? evaluate(pos)
>                                                   : DrawValue[pos.side_to_move()];
517,518c624,625
<     ss->currentMove = ss->ttMove = (ss+1)->excludedMove = bestMove = MOVE_NONE;
<     (ss+1)->skipEarlyPruning = false; (ss+1)->reduction = DEPTH_ZERO;
---
>     ss->currentMove = (ss+1)->excludedMove = bestMove = MOVE_NONE;
>     ss->counterMoves = nullptr;
519a627
>     Square prevSq = to_sq((ss-1)->currentMove);
521,523c629,631
<     // Step 4. Transposition table lookup
<     // We don't want the score of a partial search to overwrite a previous full search
<     // TT value, so we use a different position key in case of an excluded move.
---
>     // Step 4. Transposition table lookup. We don't want the score of a partial
>     // search to overwrite a previous full search TT value, so we use a different
>     // position key in case of an excluded move.
525c633
<     posKey = excludedMove ? pos.exclusion_key() : pos.key();
---
>     posKey = pos.key() ^ Key(excludedMove);
527d634
<     ss->ttMove = ttMove = RootNode ? RootMoves[PVIdx].pv[0] : ttHit ? tte->move() : MOVE_NONE;
528a636,637
>     ttMove =  rootNode ? thisThread->rootMoves[thisThread->PVIdx].pv[0]
>             : ttHit    ? tte->move() : MOVE_NONE;
530c639
<     // At non-PV nodes we check for a fail high/low. We don't probe at PV nodes
---
>     // At non-PV nodes we check for an early TT cutoff
534c643
<         && ttValue != VALUE_NONE // Only in case of TT access race
---
>         && ttValue != VALUE_NONE // Possible in case of TT access race
538,542c647,653
<         ss->currentMove = ttMove; // Can be MOVE_NONE
< 
<         // If ttMove is quiet, update killers, history, counter move and followup move on TT hit
<         if (ttValue >= beta && ttMove && !pos.capture_or_promotion(ttMove) && !inCheck)
<             update_stats(pos, ss, ttMove, depth, NULL, 0);
---
>         // If ttMove is quiet, update move sorting heuristics on TT hit
>         if (ttMove)
>         {
>             if (ttValue >= beta)
>             {
>                 if (!pos.capture_or_promotion(ttMove))
>                     update_stats(pos, ss, ttMove, nullptr, 0, stat_bonus(depth));
543a655,666
>                 // Extra penalty for a quiet TT move in previous ply when it gets refuted
>                 if ((ss-1)->moveCount == 1 && !pos.captured_piece())
>                     update_cm_stats(ss-1, pos.piece_on(prevSq), prevSq, -stat_bonus(depth + ONE_PLY));
>             }
>             // Penalty for a quiet ttMove that fails low
>             else if (!pos.capture_or_promotion(ttMove))
>             {
>                 Value penalty = -stat_bonus(depth + ONE_PLY);
>                 thisThread->history.update(pos.side_to_move(), ttMove, penalty);
>                 update_cm_stats(ss, pos.moved_piece(ttMove), to_sq(ttMove), penalty);
>             }
>         }
548c671
<     if (!RootNode && TB::Cardinality)
---
>     if (!rootNode && TB::Cardinality)
550c673
<         int piecesCnt = pos.count<ALL_PIECES>(WHITE) + pos.count<ALL_PIECES>(BLACK);
---
>         int piecesCount = pos.count<ALL_PIECES>(WHITE) + pos.count<ALL_PIECES>(BLACK);
552,554c675,678
<         if (    piecesCnt <= TB::Cardinality
<             && (piecesCnt <  TB::Cardinality || depth >= TB::ProbeDepth)
<             &&  pos.rule50_count() == 0)
---
>         if (    piecesCount <= TB::Cardinality
>             && (piecesCount <  TB::Cardinality || depth >= TB::ProbeDepth)
>             &&  pos.rule50_count() == 0
>             && !pos.can_castle(ANY_CASTLING))
556c680,681
<             int found, v = Tablebases::probe_wdl(pos, &found);
---
>             TB::ProbeState err;
>             TB::WDLScore v = Tablebases::probe_wdl(pos, &err);
558c683
<             if (found)
---
>             if (err != TB::ProbeState::FAIL)
560c685
<                 TB::Hits++;
---
>                 thisThread->tbHits++;
577c702
<     // Step 5. Evaluate the position statically and update parent's gain statistics
---
>     // Step 5. Evaluate the position statically
587c712
<         if ((ss->staticEval = eval = tte->eval_value()) == VALUE_NONE)
---
>         if ((ss->staticEval = eval = tte->eval()) == VALUE_NONE)
598c723,724
<         (ss-1)->currentMove != MOVE_NULL ? evaluate(pos) : -(ss-1)->staticEval + 2 * Eval::Tempo;
---
>         (ss-1)->currentMove != MOVE_NULL ? evaluate(pos)
>                                          : -(ss-1)->staticEval + 2 * Eval::Tempo;
600c726,727
<         tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE, ss->staticEval, TT.generation());
---
>         tte->save(posKey, VALUE_NONE, BOUND_NONE, DEPTH_NONE, MOVE_NONE,
>                   ss->staticEval, TT.generation());
603c730
<     if (ss->skipEarlyPruning)
---
>     if (skipEarlyPruning)
606,616d732
<     if (   !pos.captured_piece_type()
<         &&  ss->staticEval != VALUE_NONE
<         && (ss-1)->staticEval != VALUE_NONE
<         && (move = (ss-1)->currentMove) != MOVE_NULL
<         &&  move != MOVE_NONE
<         &&  type_of(move) == NORMAL)
<     {
<         Square to = to_sq(move);
<         Gains.update(pos.piece_on(to), to, -(ss-1)->staticEval - ss->staticEval);
<     }
< 
620d735
<         &&  eval + razor_margin(depth) <= alpha
622c737
<         && !pos.pawn_on_7th(pos.side_to_move()))
---
>         &&  eval + razor_margin[depth / ONE_PLY] <= alpha)
624,626c739,740
<         if (   depth <= ONE_PLY
<             && eval + razor_margin(3 * ONE_PLY) <= alpha)
<             return qsearch<NonPV, false>(pos, ss, alpha, beta, DEPTH_ZERO);
---
>         if (depth <= ONE_PLY)
>             return qsearch<NonPV, false>(pos, ss, alpha, alpha+1);
628,629c742,743
<         Value ralpha = alpha - razor_margin(depth);
<         Value v = qsearch<NonPV, false>(pos, ss, ralpha, ralpha+1, DEPTH_ZERO);
---
>         Value ralpha = alpha - razor_margin[depth / ONE_PLY];
>         Value v = qsearch<NonPV, false>(pos, ss, ralpha, ralpha+1);
635c749
<     if (   !PvNode
---
>     if (   !rootNode
640c754
<         return eval - futility_margin(depth);
---
>         return eval;
644d757
<         &&  depth >= 2 * ONE_PLY
645a759
>         && (ss->staticEval >= beta - 35 * (depth / ONE_PLY - 6) || depth >= 13 * ONE_PLY)
648a763
>         ss->counterMoves = nullptr;
653c768
<         Depth R = (3 + depth / 4 + std::min((eval - beta) / PawnValueMg, 3)) * ONE_PLY;
---
>         Depth R = ((823 + 67 * depth / ONE_PLY) / 256 + std::min((eval - beta) / PawnValueMg, 3)) * ONE_PLY;
656,659c771,772
<         (ss+1)->skipEarlyPruning = true;
<         nullValue = depth-R < ONE_PLY ? -qsearch<NonPV, false>(pos, ss+1, -beta, -beta+1, DEPTH_ZERO)
<                                       : - search<NonPV, false>(pos, ss+1, -beta, -beta+1, depth-R, !cutNode);
<         (ss+1)->skipEarlyPruning = false;
---
>         nullValue = depth-R < ONE_PLY ? -qsearch<NonPV, false>(pos, ss+1, -beta, -beta+1)
>                                       : - search<NonPV>(pos, ss+1, -beta, -beta+1, depth-R, !cutNode, true);
672,675c785,786
<             ss->skipEarlyPruning = true;
<             Value v = depth-R < ONE_PLY ? qsearch<NonPV, false>(pos, ss, beta-1, beta, DEPTH_ZERO)
<                                         :  search<NonPV, false>(pos, ss, beta-1, beta, depth-R, false);
<             ss->skipEarlyPruning = false;
---
>             Value v = depth-R < ONE_PLY ? qsearch<NonPV, false>(pos, ss, beta-1, beta)
>                                         :  search<NonPV>(pos, ss, beta-1, beta, depth-R, false, true);
683,685c794,795
<     // If we have a very good capture (i.e. SEE > seeValues[captured_piece_type])
<     // and a reduced search returns a value much above beta, we can (almost) safely
<     // prune the previous move.
---
>     // If we have a good enough capture and a reduced search returns a value
>     // much above beta, we can (almost) safely prune the previous move.
697,698c807
<         MovePicker mp(pos, ttMove, History, pos.captured_piece_type());
<         CheckInfo ci(pos);
---
>         MovePicker mp(pos, ttMove, rbeta - ss->staticEval);
700,701c809,810
<         while ((move = mp.next_move<false>()) != MOVE_NONE)
<             if (pos.legal(move, ci.pinned))
---
>         while ((move = mp.next_move()) != MOVE_NONE)
>             if (pos.legal(move))
704,705c813,815
<                 pos.do_move(move, st, ci, pos.gives_check(move, ci));
<                 value = -search<NonPV, false>(pos, ss+1, -rbeta, -rbeta+1, rdepth, !cutNode);
---
>                 ss->counterMoves = &thisThread->counterMoveHistory[pos.moved_piece(move)][to_sq(move)];
>                 pos.do_move(move, st);
>                 value = -search<NonPV>(pos, ss+1, -rbeta, -rbeta+1, rdepth, !cutNode, false);
713c823
<     if (    depth >= (PvNode ? 5 * ONE_PLY : 8 * ONE_PLY)
---
>     if (    depth >= 6 * ONE_PLY
717,720c827,828
<         Depth d = 2 * (depth - 2 * ONE_PLY) - (PvNode ? DEPTH_ZERO : depth / 2);
<         ss->skipEarlyPruning = true;
<         search<PvNode ? PV : NonPV, false>(pos, ss, alpha, beta, d / 2, true);
<         ss->skipEarlyPruning = false;
---
>         Depth d = (3 * depth / (4 * ONE_PLY) - 2) * ONE_PLY;
>         search<NT>(pos, ss, alpha, beta, d, cutNode, true);
726c834
< moves_loop: // When in check and at SpNode search starts from here
---
> moves_loop: // When in check search starts from here
728,734c836,838
<     Square prevMoveSq = to_sq((ss-1)->currentMove);
<     Move countermoves[] = { Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].first,
<                             Countermoves[pos.piece_on(prevMoveSq)][prevMoveSq].second };
< 
<     Square prevOwnMoveSq = to_sq((ss-2)->currentMove);
<     Move followupmoves[] = { Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].first,
<                              Followupmoves[pos.piece_on(prevOwnMoveSq)][prevOwnMoveSq].second };
---
>     const CounterMoveStats* cmh  = (ss-1)->counterMoves;
>     const CounterMoveStats* fmh  = (ss-2)->counterMoves;
>     const CounterMoveStats* fmh2 = (ss-4)->counterMoves;
736,737c840
<     MovePicker mp(pos, ttMove, depth, History, countermoves, followupmoves, ss);
<     CheckInfo ci(pos);
---
>     MovePicker mp(pos, ttMove, depth, ss);
740c843
<                || ss->staticEval == VALUE_NONE
---
>             /* || ss->staticEval == VALUE_NONE Already implicit in the previous condition */
743,744c846
<     singularExtensionNode =   !RootNode
<                            && !SpNode
---
>     singularExtensionNode =   !rootNode
747,748c849
<                        /*  &&  ttValue != VALUE_NONE Already implicit in the next condition */
<                            &&  abs(ttValue) < VALUE_KNOWN_WIN
---
>                            &&  ttValue != VALUE_NONE
755c856
<     while ((move = mp.next_move<SpNode>()) != MOVE_NONE)
---
>     while ((move = mp.next_move()) != MOVE_NONE)
765c866,867
<       if (RootNode && !std::count(RootMoves.begin() + PVIdx, RootMoves.end(), move))
---
>       if (rootNode && !std::count(thisThread->rootMoves.begin() + thisThread->PVIdx,
>                                   thisThread->rootMoves.end(), move))
768,782c870
<       if (SpNode)
<       {
<           // Shared counter cannot be decremented later if the move turns out to be illegal
<           if (!pos.legal(move, ci.pinned))
<               continue;
< 
<           moveCount = ++splitPoint->moveCount;
<           splitPoint->mutex.unlock();
<       }
<       else
<           ++moveCount;
< 
<       if (RootNode)
<       {
<           Signals.firstRootMove = (moveCount == 1);
---
>       ss->moveCount = ++moveCount;
784,788c872,875
<           if (thisThread == Threads.main() && Time::now() - SearchTime > 3000)
<               sync_cout << "info depth " << depth / ONE_PLY
<                         << " currmove " << UCI::move(move, pos.is_chess960())
<                         << " currmovenumber " << moveCount + PVIdx << sync_endl;
<       }
---
>       if (rootNode && thisThread == Threads.main() && Time.elapsed() > 3000)
>           sync_cout << "info depth " << depth / ONE_PLY
>                     << " currmove " << UCI::move(move, pos.is_chess960())
>                     << " currmovenumber " << moveCount + thisThread->PVIdx << sync_endl;
791c878
<           (ss+1)->pv = NULL;
---
>           (ss+1)->pv = nullptr;
794a882
>       moved_piece = pos.moved_piece(move);
796,805c884,895
<       givesCheck =  type_of(move) == NORMAL && !ci.dcCandidates
<                   ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] & to_sq(move)
<                   : pos.gives_check(move, ci);
< 
<       dangerous =   givesCheck
<                  || type_of(move) != NORMAL
<                  || pos.advanced_pawn_push(move);
< 
<       // Step 12. Extend checks
<       if (givesCheck && pos.see_sign(move) >= VALUE_ZERO)
---
>       givesCheck =  type_of(move) == NORMAL && !pos.discovered_check_candidates()
>                   ? pos.check_squares(type_of(pos.piece_on(from_sq(move)))) & to_sq(move)
>                   : pos.gives_check(move);
> 
>       moveCountPruning =   depth < 16 * ONE_PLY
>                         && moveCount >= FutilityMoveCounts[improving][depth / ONE_PLY];
> 
>       // Step 12. Extensions
>       // Extend checks
>       if (    givesCheck
>           && !moveCountPruning
>           &&  pos.see_ge(move, VALUE_ZERO))
816c906
<           &&  pos.legal(move, ci.pinned))
---
>           &&  pos.legal(move))
818c908,909
<           Value rBeta = ttValue - 2 * depth / ONE_PLY;
---
>           Value rBeta = std::max(ttValue - 2 * depth / ONE_PLY, -VALUE_MATE);
>           Depth d = (depth / (2 * ONE_PLY)) * ONE_PLY;
820,822c911
<           ss->skipEarlyPruning = true;
<           value = search<NonPV, false>(pos, ss, rBeta - 1, rBeta, depth / 2, cutNode);
<           ss->skipEarlyPruning = false;
---
>           value = search<NonPV>(pos, ss, rBeta - 1, rBeta, d, cutNode, true);
829c918
<       // Update the current move (this must be done after singular extension search)
---
>       // Calculate new depth for this move
832,837c921,923
<       // Step 13. Pruning at shallow depth (exclude PV nodes)
<       if (   !PvNode
<           && !captureOrPromotion
<           && !inCheck
<           && !dangerous
<           &&  bestValue > VALUE_MATED_IN_MAX_PLY)
---
>       // Step 13. Pruning at shallow depth
>       if (  !rootNode
>           && bestValue > VALUE_MATED_IN_MAX_PLY)
839,852c925,927
<           // Move count based pruning
<           if (   depth < 16 * ONE_PLY
<               && moveCount >= FutilityMoveCounts[improving][depth])
<           {
<               if (SpNode)
<                   splitPoint->mutex.lock();
< 
<               continue;
<           }
< 
<           predictedDepth = newDepth - reduction<PvNode>(improving, depth, moveCount);
< 
<           // Futility pruning: parent node
<           if (predictedDepth < 7 * ONE_PLY)
---
>           if (   !captureOrPromotion
>               && !givesCheck
>               && !pos.advanced_pawn_push(move))
854,855c929,931
<               futilityValue =  ss->staticEval + futility_margin(predictedDepth)
<                              + 128 + Gains[pos.moved_piece(move)][to_sq(move)];
---
>               // Move count based pruning
>               if (moveCountPruning)
>                   continue;
857,859c933,934
<               if (futilityValue <= alpha)
<               {
<                   bestValue = std::max(bestValue, futilityValue);
---
>               // Reduced depth of the next LMR search
>               int lmrDepth = std::max(newDepth - reduction<PvNode>(improving, depth, moveCount), DEPTH_ZERO) / ONE_PLY;
861,866c936,940
<                   if (SpNode)
<                   {
<                       splitPoint->mutex.lock();
<                       if (bestValue > splitPoint->bestValue)
<                           splitPoint->bestValue = bestValue;
<                   }
---
>               // Countermoves based pruning
>               if (   lmrDepth < 3
>                   && (!cmh  || (*cmh )[moved_piece][to_sq(move)] < VALUE_ZERO)
>                   && (!fmh  || (*fmh )[moved_piece][to_sq(move)] < VALUE_ZERO)
>                   && (!fmh2 || (*fmh2)[moved_piece][to_sq(move)] < VALUE_ZERO || (cmh && fmh)))
868,869d941
<               }
<           }
871,875c943,947
<           // Prune moves with negative SEE at low depths
<           if (predictedDepth < 4 * ONE_PLY && pos.see_sign(move) < VALUE_ZERO)
<           {
<               if (SpNode)
<                   splitPoint->mutex.lock();
---
>               // Futility pruning: parent node
>               if (   lmrDepth < 7
>                   && !inCheck
>                   && ss->staticEval + 256 + 200 * lmrDepth <= alpha)
>                   continue;
877c949,952
<               continue;
---
>               // Prune moves with negative SEE
>               if (   lmrDepth < 8
>                   && !pos.see_ge(move, Value(-35 * lmrDepth * lmrDepth)))
>                   continue;
878a954,957
>           else if (    depth < 7 * ONE_PLY
>                    && !extension
>                    && !pos.see_ge(move, -PawnValueEg * (depth / ONE_PLY)))
>                   continue;
882c961
<       prefetch((char*)TT.first_entry(pos.key_after(move)));
---
>       prefetch(TT.first_entry(pos.key_after(move)));
885c964
<       if (!RootNode && !SpNode && !pos.legal(move, ci.pinned))
---
>       if (!rootNode && !pos.legal(move))
887c966
<           moveCount--;
---
>           ss->moveCount = --moveCount;
890a970
>       // Update the current move (this must be done after singular extension search)
892,893c972
<       if (!SpNode && !captureOrPromotion && quietCount < 64)
<           quietsSearched[quietCount++] = move;
---
>       ss->counterMoves = &thisThread->counterMoveHistory[moved_piece][to_sq(move)];
896c975
<       pos.do_move(move, st, ci, givesCheck);
---
>       pos.do_move(move, st, givesCheck);
902,904c981
<           && !captureOrPromotion
<           &&  move != ss->killers[0]
<           &&  move != ss->killers[1])
---
>           && (!captureOrPromotion || moveCountPruning))
906c983
<           ss->reduction = reduction<PvNode>(improving, depth, moveCount);
---
>           Depth r = reduction<PvNode>(improving, depth, moveCount);
908,924c985,1008
<           if (   (!PvNode && cutNode)
<               ||  History[pos.piece_on(to_sq(move))][to_sq(move)] < 0)
<               ss->reduction += ONE_PLY;
< 
<           if (move == countermoves[0] || move == countermoves[1])
<               ss->reduction = std::max(DEPTH_ZERO, ss->reduction - ONE_PLY);
< 
<           // Decrease reduction for moves that escape a capture
<           if (   ss->reduction
<               && type_of(move) == NORMAL
<               && type_of(pos.piece_on(to_sq(move))) != PAWN
<               && pos.see(make_move(to_sq(move), from_sq(move))) < 0)
<               ss->reduction = std::max(DEPTH_ZERO, ss->reduction - ONE_PLY);
< 
<           Depth d = std::max(newDepth - ss->reduction, ONE_PLY);
<           if (SpNode)
<               alpha = splitPoint->alpha;
---
>           if (captureOrPromotion)
>               r -= r ? ONE_PLY : DEPTH_ZERO;
>           else
>           {
>               // Increase reduction for cut nodes
>               if (cutNode)
>                   r += 2 * ONE_PLY;
> 
>               // Decrease reduction for moves that escape a capture. Filter out
>               // castling moves, because they are coded as "king captures rook" and
>               // hence break make_move().
>               else if (   type_of(move) == NORMAL
>                        && !pos.see_ge(make_move(to_sq(move), from_sq(move)),  VALUE_ZERO))
>                   r -= 2 * ONE_PLY;
> 
>               ss->history =  (cmh  ? (*cmh )[moved_piece][to_sq(move)] : VALUE_ZERO)
>                            + (fmh  ? (*fmh )[moved_piece][to_sq(move)] : VALUE_ZERO)
>                            + (fmh2 ? (*fmh2)[moved_piece][to_sq(move)] : VALUE_ZERO)
>                            + thisThread->history.get(~pos.side_to_move(), move)
>                            - 4000; // Correction factor
> 
>               // Decrease/increase reduction by comparing opponent's stat score
>               if (ss->history > VALUE_ZERO && (ss-1)->history < VALUE_ZERO)
>                   r -= ONE_PLY;
926c1010,1011
<           value = -search<NonPV, false>(pos, ss+1, -(alpha+1), -alpha, d, true);
---
>               else if (ss->history < VALUE_ZERO && (ss-1)->history > VALUE_ZERO)
>                   r += ONE_PLY;
928,932c1013,1014
<           // Re-search at intermediate depth if reduction is very high
<           if (value > alpha && ss->reduction >= 4 * ONE_PLY)
<           {
<               Depth d2 = std::max(newDepth - 2 * ONE_PLY, ONE_PLY);
<               value = -search<NonPV, false>(pos, ss+1, -(alpha+1), -alpha, d2, true);
---
>               // Decrease/increase reduction for moves with a good/bad history
>               r = std::max(DEPTH_ZERO, (r / ONE_PLY - ss->history / 20000) * ONE_PLY);
935,936c1017,1021
<           doFullDepthSearch = (value > alpha && ss->reduction != DEPTH_ZERO);
<           ss->reduction = DEPTH_ZERO;
---
>           Depth d = std::max(newDepth - r, ONE_PLY);
> 
>           value = -search<NonPV>(pos, ss+1, -(alpha+1), -alpha, d, true, false);
> 
>           doFullDepthSearch = (value > alpha && d != newDepth);
941c1026
<       // Step 16. Full depth search, when LMR is skipped or fails high
---
>       // Step 16. Full depth search when LMR is skipped or fails high
943,946d1027
<       {
<           if (SpNode)
<               alpha = splitPoint->alpha;
< 
948,951c1029,1031
<                             givesCheck ? -qsearch<NonPV,  true>(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
<                                        : -qsearch<NonPV, false>(pos, ss+1, -(alpha+1), -alpha, DEPTH_ZERO)
<                                        : - search<NonPV, false>(pos, ss+1, -(alpha+1), -alpha, newDepth, !cutNode);
<       }
---
>                             givesCheck ? -qsearch<NonPV,  true>(pos, ss+1, -(alpha+1), -alpha)
>                                        : -qsearch<NonPV, false>(pos, ss+1, -(alpha+1), -alpha)
>                                        : - search<NonPV>(pos, ss+1, -(alpha+1), -alpha, newDepth, !cutNode, false);
955,956c1035,1036
<       // parent node fail low with value <= alpha and to try another move.
<       if (PvNode && (moveCount == 1 || (value > alpha && (RootNode || value < beta))))
---
>       // parent node fail low with value <= alpha and try another move.
>       if (PvNode && (moveCount == 1 || (value > alpha && (rootNode || value < beta))))
962,964c1042,1044
<                             givesCheck ? -qsearch<PV,  true>(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
<                                        : -qsearch<PV, false>(pos, ss+1, -beta, -alpha, DEPTH_ZERO)
<                                        : - search<PV, false>(pos, ss+1, -beta, -alpha, newDepth, false);
---
>                             givesCheck ? -qsearch<PV,  true>(pos, ss+1, -beta, -alpha)
>                                        : -qsearch<PV, false>(pos, ss+1, -beta, -alpha)
>                                        : - search<PV>(pos, ss+1, -beta, -alpha, newDepth, false, false);
972,981c1052,1054
<       // Step 18. Check for new best move
<       if (SpNode)
<       {
<           splitPoint->mutex.lock();
<           bestValue = splitPoint->bestValue;
<           alpha = splitPoint->alpha;
<       }
< 
<       // Finished searching the move. If a stop or a cutoff occurred, the return
<       // value of the search cannot be trusted, and we return immediately without
---
>       // Step 18. Check for a new best move
>       // Finished searching the move. If a stop occurred, the return value of
>       // the search cannot be trusted, and we return immediately without
983c1056
<       if (Signals.stop || thisThread->cutoff_occurred())
---
>       if (Signals.stop.load(std::memory_order_relaxed))
986c1059
<       if (RootNode)
---
>       if (rootNode)
988c1061,1062
<           RootMove& rm = *std::find(RootMoves.begin(), RootMoves.end(), move);
---
>           RootMove& rm = *std::find(thisThread->rootMoves.begin(),
>                                     thisThread->rootMoves.end(), move);
1004,1005c1078,1079
<               if (moveCount > 1)
<                   ++BestMoveChanges;
---
>               if (moveCount > 1 && thisThread == Threads.main())
>                   ++static_cast<MainThread*>(thisThread)->bestMoveChanges;
1016c1090
<           bestValue = SpNode ? splitPoint->bestValue = value : value;
---
>           bestValue = value;
1020c1094
<               bestMove = SpNode ? splitPoint->bestMove = move : move;
---
>               bestMove = move;
1022,1023c1096,1097
<               if (PvNode && !RootNode) // Update pv even in fail-high case
<                   update_pv(SpNode ? splitPoint->ss->pv : ss->pv, move, (ss+1)->pv);
---
>               if (PvNode && !rootNode) // Update pv even in fail-high case
>                   update_pv(ss->pv, move, (ss+1)->pv);
1026c1100
<                   alpha = SpNode ? splitPoint->alpha = value : value;
---
>                   alpha = value;
1030,1033d1103
< 
<                   if (SpNode)
<                       splitPoint->cutoff = true;
< 
1039,1057c1109,1110
<       // Step 19. Check for splitting the search
<       if (   !SpNode
<           &&  Threads.size() >= 2
<           &&  depth >= Threads.minimumSplitDepth
<           &&  (   !thisThread->activeSplitPoint
<                || !thisThread->activeSplitPoint->allSlavesSearching)
<           &&  thisThread->splitPointsSize < MAX_SPLITPOINTS_PER_THREAD)
<       {
<           assert(bestValue > -VALUE_INFINITE && bestValue < beta);
< 
<           thisThread->split(pos, ss, alpha, beta, &bestValue, &bestMove,
<                             depth, moveCount, &mp, NT, cutNode);
< 
<           if (Signals.stop || thisThread->cutoff_occurred())
<               return VALUE_ZERO;
< 
<           if (bestValue >= beta)
<               break;
<       }
---
>       if (!captureOrPromotion && move != bestMove && quietCount < 64)
>           quietsSearched[quietCount++] = move;
1060,1065c1113,1115
<     if (SpNode)
<         return bestValue;
< 
<     // Following condition would detect a stop or a cutoff set only after move
<     // loop has been completed. But in this case bestValue is valid because we
<     // have fully searched our subtree, and we can anyhow save the result in TT.
---
>     // The following condition would detect a stop only after move loop has been
>     // completed. But in this case bestValue is valid because we have fully
>     // searched our subtree, and we can anyhow save the result in TT.
1067c1117
<        if (Signals.stop || thisThread->cutoff_occurred())
---
>        if (Signals.stop)
1073c1123
<     // must be mate or stalemate. If we are in a singular extension search then
---
>     // must be a mate or a stalemate. If we are in a singular extension search then
1074a1125,1127
> 
>     assert(moveCount || !inCheck || excludedMove || !MoveList<LEGAL>(pos).size());
> 
1077a1131,1132
>     else if (bestMove)
>     {
1079,1081c1134,1146
<     // Quiet best move: update killers, history, countermoves and followupmoves
<     else if (bestValue >= beta && !pos.capture_or_promotion(bestMove) && !inCheck)
<         update_stats(pos, ss, bestMove, depth, quietsSearched, quietCount - 1);
---
>         // Quiet best move: update move sorting heuristics
>         if (!pos.capture_or_promotion(bestMove))
>             update_stats(pos, ss, bestMove, quietsSearched, quietCount, stat_bonus(depth));
> 
>         // Extra penalty for a quiet TT move in previous ply when it gets refuted
>         if ((ss-1)->moveCount == 1 && !pos.captured_piece())
>             update_cm_stats(ss-1, pos.piece_on(prevSq), prevSq, -stat_bonus(depth + ONE_PLY));
>     }
>     // Bonus for prior countermove that caused the fail low
>     else if (    depth >= 3 * ONE_PLY
>              && !pos.captured_piece()
>              && is_ok((ss-1)->currentMove))
>         update_cm_stats(ss-1, pos.piece_on(prevSq), prevSq, stat_bonus(depth));
1095,1096c1160
<   // search function when the remaining depth is zero (or, to be more precise,
<   // less than ONE_PLY).
---
>   // search function with depth zero, or recursively with depth less than ONE_PLY.
1103d1166
<     assert(NT == PV || NT == NonPV);
1107a1171
>     assert(depth / ONE_PLY * ONE_PLY == depth);
1129,1130c1193,1195
<     if (pos.is_draw() || ss->ply >= MAX_PLY)
<         return ss->ply >= MAX_PLY && !InCheck ? evaluate(pos) : DrawValue[pos.side_to_move()];
---
>     if (pos.is_draw(ss->ply) || ss->ply >= MAX_PLY)
>         return ss->ply >= MAX_PLY && !InCheck ? evaluate(pos)
>                                               : DrawValue[pos.side_to_move()];
1152,1153d1216
<     {
<         ss->currentMove = ttMove; // Can be MOVE_NONE
1155d1217
<     }
1168c1230
<             if ((ss->staticEval = bestValue = tte->eval_value()) == VALUE_NONE)
---
>             if ((ss->staticEval = bestValue = tte->eval()) == VALUE_NONE)
1178c1240,1241
<             (ss-1)->currentMove != MOVE_NULL ? evaluate(pos) : -(ss-1)->staticEval + 2 * Eval::Tempo;
---
>             (ss-1)->currentMove != MOVE_NULL ? evaluate(pos)
>                                              : -(ss-1)->staticEval + 2 * Eval::Tempo;
1200,1201c1263
<     MovePicker mp(pos, ttMove, depth, History, to_sq((ss-1)->currentMove));
<     CheckInfo ci(pos);
---
>     MovePicker mp(pos, ttMove, depth, to_sq((ss-1)->currentMove));
1204c1266
<     while ((move = mp.next_move<false>()) != MOVE_NONE)
---
>     while ((move = mp.next_move()) != MOVE_NONE)
1208,1210c1270,1272
<       givesCheck =  type_of(move) == NORMAL && !ci.dcCandidates
<                   ? ci.checkSq[type_of(pos.piece_on(from_sq(move)))] & to_sq(move)
<                   : pos.gives_check(move, ci);
---
>       givesCheck =  type_of(move) == NORMAL && !pos.discovered_check_candidates()
>                   ? pos.check_squares(type_of(pos.piece_on(from_sq(move)))) & to_sq(move)
>                   : pos.gives_check(move);
1213,1214c1275
<       if (   !PvNode
<           && !InCheck
---
>       if (   !InCheck
1223c1284
<           if (futilityValue < beta)
---
>           if (futilityValue <= alpha)
1229c1290
<           if (futilityBase < beta && pos.see(move) <= VALUE_ZERO)
---
>           if (futilityBase <= alpha && !pos.see_ge(move, VALUE_ZERO + 1))
1239,1240c1300
<                        && !pos.capture(move)
<                        && !pos.can_castle(pos.side_to_move());
---
>                        && !pos.capture(move);
1243,1244c1303
<       if (   !PvNode
<           && (!InCheck || evasionPrunable)
---
>       if (  (!InCheck || evasionPrunable)
1246c1305
<           &&  pos.see_sign(move) < VALUE_ZERO)
---
>           &&  !pos.see_ge(move, VALUE_ZERO))
1250c1309
<       prefetch((char*)TT.first_entry(pos.key_after(move)));
---
>       prefetch(TT.first_entry(pos.key_after(move)));
1253c1312
<       if (!pos.legal(move, ci.pinned))
---
>       if (!pos.legal(move))
1259c1318
<       pos.do_move(move, st, ci, givesCheck);
---
>       pos.do_move(move, st, givesCheck);
1266c1325
<       // Check for new best move
---
>       // Check for a new best move
1276c1335
<               if (PvNode && value < beta) // Update alpha here! Always alpha < beta
---
>               if (PvNode && value < beta) // Update alpha here!
1341,1342d1399
<   // update_stats() updates killers, history, countermoves and followupmoves stats after a fail-high
<   // of a quiet move.
1344c1401,1423
<   void update_stats(const Position& pos, Stack* ss, Move move, Depth depth, Move* quiets, int quietsCnt) {
---
>   // update_cm_stats() updates countermove and follow-up move history
> 
>   void update_cm_stats(Stack* ss, Piece pc, Square s, Value bonus) {
> 
>     CounterMoveStats* cmh  = (ss-1)->counterMoves;
>     CounterMoveStats* fmh1 = (ss-2)->counterMoves;
>     CounterMoveStats* fmh2 = (ss-4)->counterMoves;
> 
>     if (cmh)
>         cmh->update(pc, s, bonus);
> 
>     if (fmh1)
>         fmh1->update(pc, s, bonus);
> 
>     if (fmh2)
>         fmh2->update(pc, s, bonus);
>   }
> 
> 
>   // update_stats() updates move sorting heuristics when a new quiet best move is found
> 
>   void update_stats(const Position& pos, Stack* ss, Move move,
>                     Move* quiets, int quietsCnt, Value bonus) {
1352,1360c1431,1434
<     // Increase history value of the cut-off move and decrease all the other
<     // played quiet moves.
<     Value bonus = Value((depth / ONE_PLY) * (depth / ONE_PLY));
<     History.update(pos.moved_piece(move), to_sq(move), bonus);
<     for (int i = 0; i < quietsCnt; ++i)
<     {
<         Move m = quiets[i];
<         History.update(pos.moved_piece(m), to_sq(m), -bonus);
<     }
---
>     Color c = pos.side_to_move();
>     Thread* thisThread = pos.this_thread();
>     thisThread->history.update(c, move, bonus);
>     update_cm_stats(ss, pos.moved_piece(move), to_sq(move), bonus);
1362c1436
<     if (is_ok((ss-1)->currentMove))
---
>     if ((ss-1)->counterMoves)
1364,1365c1438,1439
<         Square prevMoveSq = to_sq((ss-1)->currentMove);
<         Countermoves.update(pos.piece_on(prevMoveSq), prevMoveSq, move);
---
>         Square prevSq = to_sq((ss-1)->currentMove);
>         thisThread->counterMoves.update(pos.piece_on(prevSq), prevSq, move);
1368c1442,1443
<     if (is_ok((ss-2)->currentMove) && (ss-1)->currentMove == (ss-1)->ttMove)
---
>     // Decrease all the other played quiet moves
>     for (int i = 0; i < quietsCnt; ++i)
1370,1371c1445,1446
<         Square prevOwnMoveSq = to_sq((ss-2)->currentMove);
<         Followupmoves.update(pos.piece_on(prevOwnMoveSq), prevOwnMoveSq, move);
---
>         thisThread->history.update(c, quiets[i], -bonus);
>         update_cm_stats(ss, pos.moved_piece(quiets[i]), to_sq(quiets[i]), -bonus);
1376,1377c1451,1452
<   // When playing with a strength handicap, choose best move among the first 'candidates'
<   // RootMoves using a statistical rule dependent on 'level'. Idea by Heinz van Saanen.
---
>   // When playing with strength handicap, choose best move among a set of RootMoves
>   // using a statistical rule dependent on 'level'. Idea by Heinz van Saanen.
1379c1454
<   Move Skill::pick_move() {
---
>   Move Skill::pick_best(size_t multiPV) {
1381,1382c1456,1457
<     // PRNG sequence should be non-deterministic, so we seed it with the time at init
<     static PRNG rng(Time::now());
---
>     const RootMoves& rootMoves = Threads.main()->rootMoves;
>     static PRNG rng(now()); // PRNG sequence should be non-deterministic
1385c1460,1461
<     int variance = std::min(RootMoves[0].score - RootMoves[candidates - 1].score, PawnValueMg);
---
>     Value topScore = rootMoves[0].score;
>     int delta = std::min(topScore - rootMoves[multiPV - 1].score, PawnValueMg);
1388,1399d1463
<     best = MOVE_NONE;
< 
<     // Choose best move. For each move score we add two terms both dependent on
<     // weakness. One deterministic and bigger for weaker moves, and one random,
<     // then we choose the move with the resulting highest score.
<     for (size_t i = 0; i < candidates; ++i)
<     {
<         int score = RootMoves[i].score;
< 
<         // Don't allow crazy blunders even at very low skills
<         if (i > 0 && RootMoves[i - 1].score > score + 2 * PawnValueMg)
<             break;
1400a1465,1469
>     // Choose best move. For each move score we add two terms, both dependent on
>     // weakness. One is deterministic and bigger for weaker levels, and one is
>     // random. Then we choose the move with the resulting highest score.
>     for (size_t i = 0; i < multiPV; ++i)
>     {
1402,1403c1471,1472
<         score += (  weakness * int(RootMoves[0].score - score)
<                   + variance * (rng.rand<unsigned>() % weakness)) / 128;
---
>         int push = (  weakness * int(topScore - rootMoves[i].score)
>                     + delta * (rng.rand<unsigned>() % weakness)) / 128;
1405c1474
<         if (score > maxScore)
---
>         if (rootMoves[i].score + push > maxScore)
1407,1408c1476,1477
<             maxScore = score;
<             best = RootMoves[i].pv[0];
---
>             maxScore = rootMoves[i].score + push;
>             best = rootMoves[i].pv[0];
1410a1480
> 
1415,1417c1485,1486
<   // uci_pv() formats PV information according to the UCI protocol. UCI
<   // requires that all (if any) unsearched PV lines are sent using a previous
<   // search score.
---
>   // check_time() is used to print debug info and, more importantly, to detect
>   // when we are out of available time and thus stop the search.
1419c1488
<   string uci_pv(const Position& pos, Depth depth, Value alpha, Value beta) {
---
>   void check_time() {
1421,1424c1490
<     std::stringstream ss;
<     Time::point elapsed = Time::now() - SearchTime + 1;
<     size_t uciPVSize = std::min((size_t)Options["MultiPV"], RootMoves.size());
<     int selDepth = 0;
---
>     static TimePoint lastInfoTime = now();
1426,1428c1492,1493
<     for (size_t i = 0; i < Threads.size(); ++i)
<         if (Threads[i]->maxPly > selDepth)
<             selDepth = Threads[i]->maxPly;
---
>     int elapsed = Time.elapsed();
>     TimePoint tick = Limits.startTime + elapsed;
1430c1495
<     for (size_t i = 0; i < uciPVSize; ++i)
---
>     if (tick - lastInfoTime >= 1000)
1432,1457c1497,1498
<         bool updated = (i <= PVIdx);
< 
<         if (depth == ONE_PLY && !updated)
<             continue;
< 
<         Depth d = updated ? depth : depth - ONE_PLY;
<         Value v = updated ? RootMoves[i].score : RootMoves[i].previousScore;
< 
<         bool tb = TB::RootInTB && abs(v) < VALUE_MATE - MAX_PLY;
<         v = tb ? TB::Score : v;
< 
<         if (ss.rdbuf()->in_avail()) // Not at first line
<             ss << "\n";
< 
<         ss << "info depth " << d / ONE_PLY
<            << " seldepth "  << selDepth
<            << " multipv "   << i + 1
<            << " score "     << ((!tb && i == PVIdx) ? UCI::value(v, alpha, beta) : UCI::value(v))
<            << " nodes "     << pos.nodes_searched()
<            << " nps "       << pos.nodes_searched() * 1000 / elapsed
<            << " tbhits "    << TB::Hits
<            << " time "      << elapsed
<            << " pv";
< 
<         for (size_t j = 0; j < RootMoves[i].pv.size(); ++j)
<             ss << " " << UCI::move(RootMoves[i].pv[j], pos.is_chess960());
---
>         lastInfoTime = tick;
>         dbg_print();
1460c1501,1508
<     return ss.str();
---
>     // An engine may not stop pondering until told so by the GUI
>     if (Limits.ponder)
>         return;
> 
>     if (   (Limits.use_time_management() && elapsed > Time.maximum() - 10)
>         || (Limits.movetime && elapsed >= Limits.movetime)
>         || (Limits.nodes && Threads.nodes_searched() >= (uint64_t)Limits.nodes))
>             Signals.stop = true;
1466,1468c1514,1515
< /// RootMove::insert_pv_in_tt() is called at the end of a search iteration, and
< /// inserts the PV back into the TT. This makes sure the old PV moves are searched
< /// first, even if the old TT entries have been overwritten.
---
> /// UCI::pv() formats PV information according to the UCI protocol. UCI requires
> /// that all (if any) unsearched PV lines are sent using a previous search score.
1470c1517
< void RootMove::insert_pv_in_tt(Position& pos) {
---
> string UCI::pv(const Position& pos, Depth depth, Value alpha, Value beta) {
1472,1473c1519,1525
<   StateInfo state[MAX_PLY], *st = state;
<   size_t idx = 0;
---
>   std::stringstream ss;
>   int elapsed = Time.elapsed() + 1;
>   const RootMoves& rootMoves = pos.this_thread()->rootMoves;
>   size_t PVIdx = pos.this_thread()->PVIdx;
>   size_t multiPV = std::min((size_t)Options["MultiPV"], rootMoves.size());
>   uint64_t nodesSearched = Threads.nodes_searched();
>   uint64_t tbHits = Threads.tb_hits() + (TB::RootInTB ? rootMoves.size() : 0);
1475c1527
<   for ( ; idx < pv.size(); ++idx)
---
>   for (size_t i = 0; i < multiPV; ++i)
1477,1483c1529
<       bool ttHit;
<       TTEntry* tte = TT.probe(pos.key(), ttHit);
< 
<       if (!ttHit || tte->move() != pv[idx]) // Don't overwrite correct entries
<           tte->save(pos.key(), VALUE_NONE, BOUND_NONE, DEPTH_NONE, pv[idx], VALUE_NONE, TT.generation());
< 
<       assert(MoveList<LEGAL>(pos).contains(pv[idx]));
---
>       bool updated = (i <= PVIdx);
1485,1507c1531,1532
<       pos.do_move(pv[idx], *st++);
<   }
< 
<   while (idx) pos.undo_move(pv[--idx]);
< }
< 
< 
< /// Thread::idle_loop() is where the thread is parked when it has no work to do
< 
< void Thread::idle_loop() {
< 
<   // Pointer 'this_sp' is not null only if we are called from split(), and not
<   // at the thread creation. This means we are the split point's master.
<   SplitPoint* this_sp = splitPointsSize ? activeSplitPoint : NULL;
< 
<   assert(!this_sp || (this_sp->masterThread == this && searching));
< 
<   while (!exit)
<   {
<       // If this thread has been assigned work, launch a search
<       while (searching)
<       {
<           Threads.mutex.lock();
---
>       if (depth == ONE_PLY && !updated)
>           continue;
1509,1510c1534,1535
<           assert(activeSplitPoint);
<           SplitPoint* sp = activeSplitPoint;
---
>       Depth d = updated ? depth : depth - ONE_PLY;
>       Value v = updated ? rootMoves[i].score : rootMoves[i].previousScore;
1512c1537,1538
<           Threads.mutex.unlock();
---
>       bool tb = TB::RootInTB && abs(v) < VALUE_MATE - MAX_PLY;
>       v = tb ? TB::Score : v;
1514,1515c1540,1541
<           Stack stack[MAX_PLY+4], *ss = stack+2; // To allow referencing (ss-2) and (ss+2)
<           Position pos(*sp->pos, this);
---
>       if (ss.rdbuf()->in_avail()) // Not at first line
>           ss << "\n";
1517,1518c1543,1547
<           std::memcpy(ss-2, sp->ss-2, 5 * sizeof(Stack));
<           ss->splitPoint = sp;
---
>       ss << "info"
>          << " depth "    << d / ONE_PLY
>          << " seldepth " << pos.this_thread()->maxPly
>          << " multipv "  << i + 1
>          << " score "    << UCI::value(v);
1520c1549,1550
<           sp->mutex.lock();
---
>       if (!tb && i == PVIdx)
>           ss << (v >= beta ? " lowerbound" : v <= alpha ? " upperbound" : "");
1522c1552,1553
<           assert(activePosition == NULL);
---
>       ss << " nodes "    << nodesSearched
>          << " nps "      << nodesSearched * 1000 / elapsed;
1524c1555,1556
<           activePosition = &pos;
---
>       if (elapsed > 1000) // Earlier makes little sense
>           ss << " hashfull " << TT.hashfull();
1526,1527c1558,1560
<           if (sp->nodeType == NonPV)
<               search<NonPV, true>(pos, ss, sp->alpha, sp->beta, sp->depth, sp->cutNode);
---
>       ss << " tbhits "   << tbHits
>          << " time "     << elapsed
>          << " pv";
1529,1530c1562,1564
<           else if (sp->nodeType == PV)
<               search<PV, true>(pos, ss, sp->alpha, sp->beta, sp->depth, sp->cutNode);
---
>       for (Move m : rootMoves[i].pv)
>           ss << " " << UCI::move(m, pos.is_chess960());
>   }
1532,1533c1566,1567
<           else if (sp->nodeType == Root)
<               search<Root, true>(pos, ss, sp->alpha, sp->beta, sp->depth, sp->cutNode);
---
>   return ss.str();
> }
1535,1536d1568
<           else
<               assert(false);
1538c1570,1573
<           assert(searching);
---
> /// RootMove::extract_ponder_from_tt() is called in case we have no ponder move
> /// before exiting the search, for instance, in case we stop the search during a
> /// fail high at root. We try hard to have a ponder move to return to the GUI,
> /// otherwise in case of 'ponder on' we have nothing to think on.
1540,1553c1575
<           searching = false;
<           activePosition = NULL;
<           sp->slavesMask.reset(idx);
<           sp->allSlavesSearching = false;
<           sp->nodes += pos.nodes_searched();
< 
<           // Wake up the master thread so to allow it to return from the idle
<           // loop in case we are the last slave of the split point.
<           if (    this != sp->masterThread
<               &&  sp->slavesMask.none())
<           {
<               assert(!sp->masterThread->searching);
<               sp->masterThread->notify_one();
<           }
---
> bool RootMove::extract_ponder_from_tt(Position& pos) {
1555,1566c1577,1578
<           // After releasing the lock we can't access any SplitPoint related data
<           // in a safe way because it could have been released under our feet by
<           // the sp master.
<           sp->mutex.unlock();
< 
<           // Try to late join to another split point if none of its slaves has
<           // already finished.
<           if (Threads.size() > 2)
<               for (size_t i = 0; i < Threads.size(); ++i)
<               {
<                   const int size = Threads[i]->splitPointsSize; // Local copy
<                   sp = size ? &Threads[i]->splitPoints[size - 1] : NULL;
---
>     StateInfo st;
>     bool ttHit;
1568,1582c1580
<                   if (   sp
<                       && sp->allSlavesSearching
<                       && available_to(Threads[i]))
<                   {
<                       // Recheck the conditions under lock protection
<                       Threads.mutex.lock();
<                       sp->mutex.lock();
< 
<                       if (   sp->allSlavesSearching
<                           && available_to(Threads[i]))
<                       {
<                            sp->slavesMask.set(idx);
<                            activeSplitPoint = sp;
<                            searching = true;
<                       }
---
>     assert(pv.size() == 1);
1584,1585c1582,1583
<                       sp->mutex.unlock();
<                       Threads.mutex.unlock();
---
>     if (!pv[0])
>         return false;
1587,1601c1585,1586
<                       break; // Just a single attempt
<                   }
<               }
<       }
< 
<       // Grab the lock to avoid races with Thread::notify_one()
<       mutex.lock();
< 
<       // If we are master and all slaves have finished then exit idle_loop
<       if (this_sp && this_sp->slavesMask.none())
<       {
<           assert(!searching);
<           mutex.unlock();
<           break;
<       }
---
>     pos.do_move(pv[0], st);
>     TTEntry* tte = TT.probe(pos.key(), ttHit);
1603,1606c1588,1593
<       // If we are not searching, wait for a condition to be signaled instead of
<       // wasting CPU time polling for work.
<       if (!searching && !exit)
<           sleepCondition.wait(mutex);
---
>     if (ttHit)
>     {
>         Move m = tte->move(); // Local copy to be SMP safe
>         if (MoveList<LEGAL>(pos).contains(m))
>             pv.push_back(m);
>     }
1608,1609c1595,1596
<       mutex.unlock();
<   }
---
>     pos.undo_move(pv[0]);
>     return pv.size() > 1;
1611a1599
> void Tablebases::filter_root_moves(Position& pos, Search::RootMoves& rootMoves) {
1613,1620c1601,1604
< /// check_time() is called by the timer thread when the timer triggers. It is
< /// used to print debug info and, more importantly, to detect when we are out of
< /// available time and thus stop the search.
< 
< void check_time() {
< 
<   static Time::point lastInfoTime = Time::now();
<   Time::point elapsed = Time::now() - SearchTime;
---
>     RootInTB = false;
>     UseRule50 = Options["Syzygy50MoveRule"];
>     ProbeDepth = Options["SyzygyProbeDepth"] * ONE_PLY;
>     Cardinality = Options["SyzygyProbeLimit"];
1622,1656c1606,1611
<   if (Time::now() - lastInfoTime >= 1000)
<   {
<       lastInfoTime = Time::now();
<       dbg_print();
<   }
< 
<   // An engine may not stop pondering until told so by the GUI
<   if (Limits.ponder)
<       return;
< 
<   if (Limits.use_time_management())
<   {
<       bool stillAtFirstMove =    Signals.firstRootMove
<                              && !Signals.failedLowAtRoot
<                              &&  elapsed > TimeMgr.available_time() * 75 / 100;
< 
<       if (   stillAtFirstMove
<           || elapsed > TimeMgr.maximum_time() - 2 * TimerThread::Resolution)
<           Signals.stop = true;
<   }
<   else if (Limits.movetime && elapsed >= Limits.movetime)
<       Signals.stop = true;
< 
<   else if (Limits.nodes)
<   {
<       Threads.mutex.lock();
< 
<       int64_t nodes = RootPos.nodes_searched();
< 
<       // Loop across all split points and sum accumulated SplitPoint nodes plus
<       // all the currently active positions nodes.
<       for (size_t i = 0; i < Threads.size(); ++i)
<           for (int j = 0; j < Threads[i]->splitPointsSize; ++j)
<           {
<               SplitPoint& sp = Threads[i]->splitPoints[j];
---
>     // Skip TB probing when no TB found: !TBLargest -> !TB::Cardinality
>     if (Cardinality > MaxCardinality)
>     {
>         Cardinality = MaxCardinality;
>         ProbeDepth = DEPTH_ZERO;
>     }
1658c1613,1614
<               sp.mutex.lock();
---
>     if (Cardinality < popcount(pos.pieces()) || pos.can_castle(ANY_CASTLING))
>         return;
1660c1616,1618
<               nodes += sp.nodes;
---
>     // If the current root position is in the tablebases, then RootMoves
>     // contains only moves that preserve the draw or the win.
>     RootInTB = root_probe(pos, rootMoves, TB::Score);
1662,1664c1620,1621
<               for (size_t idx = 0; idx < Threads.size(); ++idx)
<                   if (sp.slavesMask.test(idx) && Threads[idx]->activePosition)
<                       nodes += Threads[idx]->activePosition->nodes_searched();
---
>     if (RootInTB)
>         Cardinality = 0; // Do not probe tablebases during the search
1666,1667c1623,1626
<               sp.mutex.unlock();
<           }
---
>     else // If DTZ tables are missing, use WDL tables as a fallback
>     {
>         // Filter out moves that do not preserve the draw or the win.
>         RootInTB = root_probe_wdl(pos, rootMoves, TB::Score);
1669c1628,1631
<       Threads.mutex.unlock();
---
>         // Only probe during search if winning
>         if (RootInTB && TB::Score <= VALUE_DRAW)
>             Cardinality = 0;
>     }
1671,1673c1633,1636
<       if (nodes >= Limits.nodes)
<           Signals.stop = true;
<   }
---
>     if (RootInTB && !UseRule50)
>         TB::Score =  TB::Score > VALUE_DRAW ?  VALUE_MATE - MAX_PLY - 1
>                    : TB::Score < VALUE_DRAW ? -VALUE_MATE + MAX_PLY + 1
>                                             :  VALUE_DRAW;
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23,24c24
< #include <memory>
< #include <stack>
---
> #include <atomic>
28c28
< #include "position.h"
---
> #include "movepick.h"
31c31
< struct SplitPoint;
---
> class Position;
35,37c35,37
< /// The Stack struct keeps track of the information we need to remember from
< /// nodes shallower and deeper in the tree during the search. Each search thread
< /// has its own array of Stack objects, indexed by the current ply.
---
> /// Stack struct keeps track of the information we need to remember from nodes
> /// shallower and deeper in the tree during the search. Each search thread has
> /// its own array of Stack objects, indexed by the current ply.
40d39
<   SplitPoint* splitPoint;
41a41
>   CounterMoveStats* counterMoves;
44d43
<   Move ttMove;
47d45
<   Depth reduction;
49c47,48
<   bool skipEarlyPruning;
---
>   Value history;
>   int moveCount;
53,56c52,55
< /// RootMove struct is used for moves at the root of the tree. For each root
< /// move we store a score, a node count, and a PV (really a refutation in the
< /// case of moves which fail low). Score is normally set at -VALUE_INFINITE for
< /// all non-pv moves.
---
> /// RootMove struct is used for moves at the root of the tree. For each root move
> /// we store a score and a PV (really a refutation in the case of moves which
> /// fail low). Score is normally set at -VALUE_INFINITE for all non-pv moves.
> 
59c58
<   RootMove(Move m) : score(-VALUE_INFINITE), previousScore(-VALUE_INFINITE), pv(1, m) {}
---
>   explicit RootMove(Move m) : pv(1, m) {}
61c60
<   bool operator<(const RootMove& m) const { return score > m.score; } // Ascending sort
---
>   bool operator<(const RootMove& m) const { return m.score < score; } // Descending sort
62a62
>   bool extract_ponder_from_tt(Position& pos);
64,67c64,65
<   void insert_pv_in_tt(Position& pos);
< 
<   Value score;
<   Value previousScore;
---
>   Value score = -VALUE_INFINITE;
>   Value previousScore = -VALUE_INFINITE;
71c69,70
< typedef std::vector<RootMove> RootMoveVector;
---
> typedef std::vector<RootMove> RootMoves;
> 
73,75c72,74
< /// The LimitsType struct stores information sent by GUI about available time
< /// to search the current move, maximum depth/time, if we are in analysis mode
< /// or if we have to ponder while it's our opponent's turn to move.
---
> /// LimitsType struct stores information sent by GUI about available time to
> /// search the current move, maximum depth/time, if we are in analysis mode or
> /// if we have to ponder while it's our opponent's turn to move.
79,81c78,84
<   LimitsType() { // Using memset on a std::vector is undefined behavior
<     nodes = time[WHITE] = time[BLACK] = inc[WHITE] = inc[BLACK] = movestogo =
<     depth = movetime = mate = infinite = ponder = 0;
---
>   LimitsType() { // Init explicitly due to broken value-initialization of non POD in MSVC
>     nodes = time[WHITE] = time[BLACK] = inc[WHITE] = inc[BLACK] =
>     npmsec = movestogo = depth = movetime = mate = infinite = ponder = 0;
>   }
> 
>   bool use_time_management() const {
>     return !(mate | movetime | depth | nodes | infinite);
83d85
<   bool use_time_management() const { return !(mate | movetime | depth | nodes | infinite); }
86c88
<   int time[COLOR_NB], inc[COLOR_NB], movestogo, depth, movetime, mate, infinite, ponder;
---
>   int time[COLOR_NB], inc[COLOR_NB], npmsec, movestogo, depth, movetime, mate, infinite, ponder;
87a90
>   TimePoint startTime;
91,92c94,95
< /// The SignalsType struct stores volatile flags updated during the search
< /// typically in an async fashion e.g. to stop the search by the GUI.
---
> /// SignalsType struct stores atomic flags updated during the search, typically
> /// in an async fashion e.g. to stop the search by the GUI.
95c98
<   bool stop, stopOnPonderhit, firstRootMove, failedLowAtRoot;
---
>   std::atomic_bool stop, stopOnPonderhit;
98,100c101
< typedef std::auto_ptr<std::stack<StateInfo> > StateStackPtr;
< 
< extern volatile SignalsType Signals;
---
> extern SignalsType Signals;
102,105d102
< extern RootMoveVector RootMoves;
< extern Position RootPos;
< extern Time::point SearchTime;
< extern StateStackPtr SetupStates;
108,109c105,106
< void think();
< template<bool Root> uint64_t perft(Position& pos, Depth depth);
---
> void clear();
> template<bool Root = true> uint64_t perft(Position& pos, Depth depth);
****************************************************************
position
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
22c23,24
< #include <cstring>
---
> #include <cstddef> // For offsetof()
> #include <cstring> // For std::memset, std::memcmp
26c28
< #include "bitcount.h"
---
> #include "bitboard.h"
30d31
< #include "psqtab.h"
33a35
> #include "syzygy/tbprobe.h"
37,39c39,41
< Value PieceValue[PHASE_NB][PIECE_NB] = {
< { VALUE_ZERO, PawnValueMg, KnightValueMg, BishopValueMg, RookValueMg, QueenValueMg },
< { VALUE_ZERO, PawnValueEg, KnightValueEg, BishopValueEg, RookValueEg, QueenValueEg } };
---
> namespace PSQT {
>   extern Score psq[PIECE_NB][SQUARE_NB];
> }
43c45
<   Key psq[COLOR_NB][PIECE_TYPE_NB][SQUARE_NB];
---
>   Key psq[PIECE_NB][SQUARE_NB];
46,47c48
<   Key side;
<   Key exclusion;
---
>   Key side, noPawns;
50,51d50
< Key Position::exclusion_key() const { return st->key ^ Zobrist::exclusion;}
< 
55d53
< Score psq[COLOR_NB][PIECE_TYPE_NB][SQUARE_NB];
57c55
< // min_attacker() is a helper function used by see() to locate the least
---
> // min_attacker() is a helper function used by see_ge() to locate the least
61,62c59,60
< template<int Pt> FORCE_INLINE
< PieceType min_attacker(const Bitboard* bb, const Square& to, const Bitboard& stmAttackers,
---
> template<int Pt>
> PieceType min_attacker(const Bitboard* bb, Square to, Bitboard stmAttackers,
81,82c79,80
< template<> FORCE_INLINE
< PieceType min_attacker<KING>(const Bitboard*, const Square&, const Bitboard&, Bitboard&, Bitboard&) {
---
> template<>
> PieceType min_attacker<KING>(const Bitboard*, Square, Bitboard, Bitboard&, Bitboard&) {
89,107d86
< /// CheckInfo c'tor
< 
< CheckInfo::CheckInfo(const Position& pos) {
< 
<   Color them = ~pos.side_to_move();
<   ksq = pos.king_square(them);
< 
<   pinned = pos.pinned_pieces(pos.side_to_move());
<   dcCandidates = pos.discovered_check_candidates();
< 
<   checkSq[PAWN]   = pos.attacks_from<PAWN>(ksq, them);
<   checkSq[KNIGHT] = pos.attacks_from<KNIGHT>(ksq);
<   checkSq[BISHOP] = pos.attacks_from<BISHOP>(ksq);
<   checkSq[ROOK]   = pos.attacks_from<ROOK>(ksq);
<   checkSq[QUEEN]  = checkSq[BISHOP] | checkSq[ROOK];
<   checkSq[KING]   = 0;
< }
< 
< 
123c102,103
<      << std::setfill('0') << std::setw(16) << pos.st->key << std::dec << "\nCheckers: ";
---
>      << std::setfill('0') << std::setw(16) << pos.key()
>      << std::setfill(' ') << std::dec << "\nCheckers: ";
127a108,120
>   if (    int(Tablebases::MaxCardinality) >= popcount(pos.pieces())
>       && !pos.can_castle(ANY_CASTLING))
>   {
>       StateInfo st;
>       Position p;
>       p.set(pos.fen(), pos.is_chess960(), &st, pos.this_thread());
>       Tablebases::ProbeState s1, s2;
>       Tablebases::WDLScore wdl = Tablebases::probe_wdl(p, &s1);
>       int dtz = Tablebases::probe_dtz(p, &s2);
>       os << "\nTablebases WDL: " << std::setw(4) << wdl << " (" << s1 << ")"
>          << "\nTablebases DTZ: " << std::setw(4) << dtz << " (" << s2 << ")";
>   }
> 
133,136c126
< /// hash keys and the piece square tables. The latter is a two-step operation:
< /// Firstly, the white halves of the tables are copied from PSQT[] tables.
< /// Secondly, the black halves of the tables are initialized by flipping and
< /// changing the sign of the white scores.
---
> /// hash keys.
142,145c132,134
<   for (Color c = WHITE; c <= BLACK; ++c)
<       for (PieceType pt = PAWN; pt <= KING; ++pt)
<           for (Square s = SQ_A1; s <= SQ_H8; ++s)
<               Zobrist::psq[c][pt][s] = rng.rand<Key>();
---
>   for (Piece pc : Pieces)
>       for (Square s = SQ_A1; s <= SQ_H8; ++s)
>           Zobrist::psq[pc][s] = rng.rand<Key>();
151a141
>       Zobrist::castling[cr] = 0;
161,207c151
<   Zobrist::exclusion  = rng.rand<Key>();
< 
<   for (PieceType pt = PAWN; pt <= KING; ++pt)
<   {
<       PieceValue[MG][make_piece(BLACK, pt)] = PieceValue[MG][pt];
<       PieceValue[EG][make_piece(BLACK, pt)] = PieceValue[EG][pt];
< 
<       Score v = make_score(PieceValue[MG][pt], PieceValue[EG][pt]);
< 
<       for (Square s = SQ_A1; s <= SQ_H8; ++s)
<       {
<          psq[WHITE][pt][ s] =  (v + PSQT[pt][s]);
<          psq[BLACK][pt][~s] = -(v + PSQT[pt][s]);
<       }
<   }
< }
< 
< 
< /// Position::operator=() creates a copy of 'pos'. We want the new born Position
< /// object to not depend on any external data so we detach state pointer from
< /// the source one.
< 
< Position& Position::operator=(const Position& pos) {
< 
<   std::memcpy(this, &pos, sizeof(Position));
<   startState = *st;
<   st = &startState;
<   nodes = 0;
< 
<   assert(pos_is_ok());
< 
<   return *this;
< }
< 
< 
< /// Position::clear() erases the position object to a pristine state, with an
< /// empty board, white to move, and no castling rights.
< 
< void Position::clear() {
< 
<   std::memset(this, 0, sizeof(Position));
<   startState.epSquare = SQ_NONE;
<   st = &startState;
< 
<   for (int i = 0; i < PIECE_TYPE_NB; ++i)
<       for (int j = 0; j < 16; ++j)
<           pieceList[WHITE][i][j] = pieceList[BLACK][i][j] = SQ_NONE;
---
>   Zobrist::noPawns = rng.rand<Key>();
215c159
< void Position::set(const string& fenStr, bool isChess960, Thread* th) {
---
> Position& Position::set(const string& fenStr, bool isChess960, StateInfo* si, Thread* th) {
239,240c183,185
<       is the position "behind" the pawn. This is recorded regardless of whether
<       there is a pawn in position to make an en passant capture.
---
>       is the position "behind" the pawn. This is recorded only if there is a pawn
>       in position to make an en passant capture, and if there really is a pawn
>       that might have advanced two squares.
255c200,204
<   clear();
---
>   std::memset(this, 0, sizeof(Position));
>   std::memset(si, 0, sizeof(StateInfo));
>   std::fill_n(&pieceList[0][0], sizeof(pieceList) / sizeof(Square), SQ_NONE);
>   st = si;
> 
269c218
<           put_piece(sq, color_of(Piece(idx)), type_of(Piece(idx)));
---
>           put_piece(Piece(idx), sq);
287a237
>       Piece rook = make_piece(c, ROOK);
292c242
<           for (rsq = relative_square(c, SQ_H1); type_of(piece_on(rsq)) != ROOK; --rsq) {}
---
>           for (rsq = relative_square(c, SQ_H1); piece_on(rsq) != rook; --rsq) {}
295c245
<           for (rsq = relative_square(c, SQ_A1); type_of(piece_on(rsq)) != ROOK; ++rsq) {}
---
>           for (rsq = relative_square(c, SQ_A1); piece_on(rsq) != rook; ++rsq) {}
312c262,263
<       if (!(attackers_to(st->epSquare) & pieces(sideToMove, PAWN)))
---
>       if (   !(attackers_to(st->epSquare) & pieces(sideToMove, PAWN))
>           || !(pieces(~sideToMove, PAWN) & (st->epSquare + pawn_push(~sideToMove))))
314a266,267
>   else
>       st->epSquare = SQ_NONE;
327a281,282
> 
>   return *this;
336c291
<   Square kfrom = king_square(c);
---
>   Square kfrom = square<KING>(c);
357a313,330
> /// Position::set_check_info() sets king attacks to detect if a move gives check
> 
> void Position::set_check_info(StateInfo* si) const {
> 
>   si->blockersForKing[WHITE] = slider_blockers(pieces(BLACK), square<KING>(WHITE), si->pinnersForKing[WHITE]);
>   si->blockersForKing[BLACK] = slider_blockers(pieces(WHITE), square<KING>(BLACK), si->pinnersForKing[BLACK]);
> 
>   Square ksq = square<KING>(~sideToMove);
> 
>   si->checkSquares[PAWN]   = attacks_from<PAWN>(ksq, ~sideToMove);
>   si->checkSquares[KNIGHT] = attacks_from<KNIGHT>(ksq);
>   si->checkSquares[BISHOP] = attacks_from<BISHOP>(ksq);
>   si->checkSquares[ROOK]   = attacks_from<ROOK>(ksq);
>   si->checkSquares[QUEEN]  = si->checkSquares[BISHOP] | si->checkSquares[ROOK];
>   si->checkSquares[KING]   = 0;
> }
> 
> 
365c338,339
<   si->key = si->pawnKey = si->materialKey = 0;
---
>   si->key = si->materialKey = 0;
>   si->pawnKey = Zobrist::noPawns;
367a342
>   si->checkersBB = attackers_to(square<KING>(sideToMove)) & pieces(~sideToMove);
369c344
<   si->checkersBB = attackers_to(king_square(sideToMove)) & pieces(~sideToMove);
---
>   set_check_info(si);
375,376c350,351
<       si->key ^= Zobrist::psq[color_of(pc)][type_of(pc)][s];
<       si->psq += psq[color_of(pc)][type_of(pc)][s];
---
>       si->key ^= Zobrist::psq[pc][s];
>       si->psq += PSQT::psq[pc][s];
379,380c354,355
<   if (ep_square() != SQ_NONE)
<       si->key ^= Zobrist::enpassant[file_of(ep_square())];
---
>   if (si->epSquare != SQ_NONE)
>       si->key ^= Zobrist::enpassant[file_of(si->epSquare)];
385c360
<   si->key ^= Zobrist::castling[st->castlingRights];
---
>   si->key ^= Zobrist::castling[si->castlingRights];
390c365,374
<       si->pawnKey ^= Zobrist::psq[color_of(piece_on(s))][PAWN][s];
---
>       si->pawnKey ^= Zobrist::psq[piece_on(s)][s];
>   }
> 
>   for (Piece pc : Pieces)
>   {
>       if (type_of(pc) != PAWN && type_of(pc) != KING)
>           si->nonPawnMaterial[color_of(pc)] += pieceCount[pc] * PieceValue[MG][pc];
> 
>       for (int cnt = 0; cnt < pieceCount[pc]; ++cnt)
>           si->materialKey ^= Zobrist::psq[pc][cnt];
391a376,384
> }
> 
> 
> /// Position::set() is an overload to initialize the position object with
> /// the given endgame code string like "KBPKN". It is manily an helper to
> /// get the material key out of an endgame code. Position is not playable,
> /// indeed is even not guaranteed to be legal.
> 
> Position& Position::set(const string& code, Color c, StateInfo* si) {
393,396c386,387
<   for (Color c = WHITE; c <= BLACK; ++c)
<       for (PieceType pt = PAWN; pt <= KING; ++pt)
<           for (int cnt = 0; cnt < pieceCount[c][pt]; ++cnt)
<               si->materialKey ^= Zobrist::psq[c][pt][cnt];
---
>   assert(code.length() > 0 && code.length() < 8);
>   assert(code[0] == 'K');
398,400c389,397
<   for (Color c = WHITE; c <= BLACK; ++c)
<       for (PieceType pt = KNIGHT; pt <= QUEEN; ++pt)
<           si->nonPawnMaterial[c] += pieceCount[c][pt] * PieceValue[MG][pt];
---
>   string sides[] = { code.substr(code.find('K', 1)),      // Weak
>                      code.substr(0, code.find('K', 1)) }; // Strong
> 
>   std::transform(sides[c].begin(), sides[c].end(), sides[c].begin(), tolower);
> 
>   string fenStr =  sides[0] + char(8 - sides[0].length() + '0') + "/8/8/8/8/8/8/"
>                  + sides[1] + char(8 - sides[1].length() + '0') + " w - - 0 10";
> 
>   return set(fenStr, false, si, nullptr);
467,488c464,490
< /// Position::check_blockers() returns a bitboard of all the pieces with color
< /// 'c' that are blocking check on the king with color 'kingColor'. A piece
< /// blocks a check if removing that piece from the board would result in a
< /// position where the king is in check. A check blocking piece can be either a
< /// pinned or a discovered check piece, according if its color 'c' is the same
< /// or the opposite of 'kingColor'.
< 
< Bitboard Position::check_blockers(Color c, Color kingColor) const {
< 
<   Bitboard b, pinners, result = 0;
<   Square ksq = king_square(kingColor);
< 
<   // Pinners are sliders that give check when a pinned piece is removed
<   pinners = (  (pieces(  ROOK, QUEEN) & PseudoAttacks[ROOK  ][ksq])
<              | (pieces(BISHOP, QUEEN) & PseudoAttacks[BISHOP][ksq])) & pieces(~kingColor);
< 
<   while (pinners)
<   {
<       b = between_bb(ksq, pop_lsb(&pinners)) & pieces();
< 
<       if (!more_than_one(b))
<           result |= b & pieces(c);
---
> /// Position::slider_blockers() returns a bitboard of all the pieces (both colors)
> /// that are blocking attacks on the square 's' from 'sliders'. A piece blocks a
> /// slider if removing that piece from the board would result in a position where
> /// square 's' is attacked. For example, a king-attack blocking piece can be either
> /// a pinned or a discovered check piece, according if its color is the opposite
> /// or the same of the color of the slider.
> 
> Bitboard Position::slider_blockers(Bitboard sliders, Square s, Bitboard& pinners) const {
> 
>   Bitboard result = 0;
>   pinners = 0;
> 
>   // Snipers are sliders that attack 's' when a piece is removed
>   Bitboard snipers = (  (PseudoAttacks[ROOK  ][s] & pieces(QUEEN, ROOK))
>                       | (PseudoAttacks[BISHOP][s] & pieces(QUEEN, BISHOP))) & sliders;
> 
>   while (snipers)
>   {
>     Square sniperSq = pop_lsb(&snipers);
>     Bitboard b = between_bb(s, sniperSq) & pieces();
> 
>     if (!more_than_one(b))
>     {
>         result |= b;
>         if (b & pieces(color_of(piece_on(s))))
>             pinners |= sniperSq;
>     }
502c504
<         | (attacks_bb<ROOK>(s, occupied)   & pieces(ROOK, QUEEN))
---
>         | (attacks_bb<ROOK  >(s, occupied) & pieces(ROOK,   QUEEN))
510c512
< bool Position::legal(Move m, Bitboard pinned) const {
---
> bool Position::legal(Move m) const {
513d514
<   assert(pinned == pinned_pieces(sideToMove));
519c520
<   assert(piece_on(king_square(us)) == make_piece(us, KING));
---
>   assert(piece_on(square<KING>(us)) == make_piece(us, KING));
526c527
<       Square ksq = king_square(us);
---
>       Square ksq = square<KING>(us);
548,550c549,550
<   return   !pinned
<         || !(pinned & from)
<         ||  aligned(from, to_sq(m), king_square(us));
---
>   return   !(pinned_pieces(us) & from)
>         ||  aligned(from, to_sq(m), square<KING>(us));
570c570
<   if (promotion_type(m) - 2 != NO_PIECE_TYPE)
---
>   if (promotion_type(m) - KNIGHT != NO_PIECE_TYPE)
591d590
< 
593d591
< 
615c613
<           if (!((between_bb(lsb(checkers()), king_square(us)) | checkers()) & to))
---
>           if (!((between_bb(lsb(checkers()), square<KING>(us)) | checkers()) & to))
630c628
< bool Position::gives_check(Move m, const CheckInfo& ci) const {
---
> bool Position::gives_check(Move m) const {
633d630
<   assert(ci.dcCandidates == discovered_check_candidates());
638d634
<   PieceType pt = type_of(piece_on(from));
641c637
<   if (ci.checkSq[pt] & to)
---
>   if (st->checkSquares[type_of(piece_on(from))] & to)
645,647c641,642
<   if (   unlikely(ci.dcCandidates)
<       && (ci.dcCandidates & from)
<       && !aligned(from, to, ci.ksq))
---
>   if (   (discovered_check_candidates() & from)
>       && !aligned(from, to, square<KING>(~sideToMove)))
656c651
<       return attacks_bb(Piece(promotion_type(m)), to, pieces() ^ from) & ci.ksq;
---
>       return attacks_bb(Piece(promotion_type(m)), to, pieces() ^ from) & square<KING>(~sideToMove);
667,668c662,663
<       return  (attacks_bb<  ROOK>(ci.ksq, b) & pieces(sideToMove, QUEEN, ROOK))
<             | (attacks_bb<BISHOP>(ci.ksq, b) & pieces(sideToMove, QUEEN, BISHOP));
---
>       return  (attacks_bb<  ROOK>(square<KING>(~sideToMove), b) & pieces(sideToMove, QUEEN, ROOK))
>             | (attacks_bb<BISHOP>(square<KING>(~sideToMove), b) & pieces(sideToMove, QUEEN, BISHOP));
677,678c672,673
<       return   (PseudoAttacks[ROOK][rto] & ci.ksq)
<             && (attacks_bb<ROOK>(rto, (pieces() ^ kfrom ^ rfrom) | rto | kto) & ci.ksq);
---
>       return   (PseudoAttacks[ROOK][rto] & square<KING>(~sideToMove))
>             && (attacks_bb<ROOK>(rto, (pieces() ^ kfrom ^ rfrom) | rto | kto) & square<KING>(~sideToMove));
691,697c686
< void Position::do_move(Move m, StateInfo& newSt) {
< 
<   CheckInfo ci(*this);
<   do_move(m, newSt, ci, gives_check(m, ci));
< }
< 
< void Position::do_move(Move m, StateInfo& newSt, const CheckInfo& ci, bool moveIsCheck) {
---
> void Position::do_move(Move m, StateInfo& newSt, bool givesCheck) {
703c692
<   Key k = st->key;
---
>   Key k = st->key ^ Zobrist::side;
708,709c697
<   std::memcpy(&newSt, st, StateCopySize64 * sizeof(uint64_t));
< 
---
>   std::memcpy(&newSt, st, offsetof(StateInfo, key));
713,715d700
<   // Update side to move
<   k ^= Zobrist::side;
< 
727,728c712
<   PieceType pt = type_of(pc);
<   PieceType captured = type_of(m) == ENPASSANT ? PAWN : type_of(piece_on(to));
---
>   Piece captured = type_of(m) == ENPASSANT ? make_piece(them, PAWN) : piece_on(to);
731,732c715,716
<   assert(piece_on(to) == NO_PIECE || color_of(piece_on(to)) == them || type_of(m) == CASTLING);
<   assert(captured != KING);
---
>   assert(captured == NO_PIECE || color_of(captured) == (type_of(m) != CASTLING ? them : us));
>   assert(type_of(captured) != KING);
736a721
>       assert(captured == make_piece(us, ROOK));
739c724
<       do_castling<true>(from, to, rfrom, rto);
---
>       do_castling<true>(us, from, to, rfrom, rto);
741,743c726,728
<       captured = NO_PIECE_TYPE;
<       st->psq += psq[us][ROOK][rto] - psq[us][ROOK][rfrom];
<       k ^= Zobrist::psq[us][ROOK][rfrom] ^ Zobrist::psq[us][ROOK][rto];
---
>       st->psq += PSQT::psq[captured][rto] - PSQT::psq[captured][rfrom];
>       k ^= Zobrist::psq[captured][rfrom] ^ Zobrist::psq[captured][rto];
>       captured = NO_PIECE;
752c737
<       if (captured == PAWN)
---
>       if (type_of(captured) == PAWN)
756c741
<               capsq += pawn_push(them);
---
>               capsq -= pawn_push(us);
758c743
<               assert(pt == PAWN);
---
>               assert(pc == make_piece(us, PAWN));
764c749
<               board[capsq] = NO_PIECE;
---
>               board[capsq] = NO_PIECE; // Not done by remove_piece()
767c752
<           st->pawnKey ^= Zobrist::psq[them][PAWN][capsq];
---
>           st->pawnKey ^= Zobrist::psq[captured][capsq];
773c758
<       remove_piece(capsq, them, captured);
---
>       remove_piece(captured, capsq);
776,778c761,763
<       k ^= Zobrist::psq[them][captured][capsq];
<       st->materialKey ^= Zobrist::psq[them][captured][pieceCount[them][captured]];
<       prefetch((char*)thisThread->materialTable[st->materialKey]);
---
>       k ^= Zobrist::psq[captured][capsq];
>       st->materialKey ^= Zobrist::psq[captured][pieceCount[captured]];
>       prefetch(thisThread->materialTable[st->materialKey]);
781c766
<       st->psq -= psq[them][captured][capsq];
---
>       st->psq -= PSQT::psq[captured][capsq];
788c773
<   k ^= Zobrist::psq[us][pt][from] ^ Zobrist::psq[us][pt][to];
---
>   k ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to];
807c792
<       move_piece(from, to, us, pt);
---
>       move_piece(pc, from, to);
810c795
<   if (pt == PAWN)
---
>   if (type_of(pc) == PAWN)
814c799
<           && (attacks_from<PAWN>(from + pawn_push(us), us) & pieces(them, PAWN)))
---
>           && (attacks_from<PAWN>(to - pawn_push(us), us) & pieces(them, PAWN)))
816c801
<           st->epSquare = Square((from + to) / 2);
---
>           st->epSquare = (from + to) / 2;
822c807
<           PieceType promotion = promotion_type(m);
---
>           Piece promotion = make_piece(us, promotion_type(m));
825c810
<           assert(promotion >= KNIGHT && promotion <= QUEEN);
---
>           assert(type_of(promotion) >= KNIGHT && type_of(promotion) <= QUEEN);
827,828c812,813
<           remove_piece(to, us, PAWN);
<           put_piece(to, us, promotion);
---
>           remove_piece(pc, to);
>           put_piece(promotion, to);
831,834c816,819
<           k ^= Zobrist::psq[us][PAWN][to] ^ Zobrist::psq[us][promotion][to];
<           st->pawnKey ^= Zobrist::psq[us][PAWN][to];
<           st->materialKey ^=  Zobrist::psq[us][promotion][pieceCount[us][promotion]-1]
<                             ^ Zobrist::psq[us][PAWN][pieceCount[us][PAWN]];
---
>           k ^= Zobrist::psq[pc][to] ^ Zobrist::psq[promotion][to];
>           st->pawnKey ^= Zobrist::psq[pc][to];
>           st->materialKey ^=  Zobrist::psq[promotion][pieceCount[promotion]-1]
>                             ^ Zobrist::psq[pc][pieceCount[pc]];
837c822
<           st->psq += psq[us][promotion][to] - psq[us][PAWN][to];
---
>           st->psq += PSQT::psq[promotion][to] - PSQT::psq[pc][to];
844,845c829,830
<       st->pawnKey ^= Zobrist::psq[us][PAWN][from] ^ Zobrist::psq[us][PAWN][to];
<       prefetch((char*)thisThread->pawnsTable[st->pawnKey]);
---
>       st->pawnKey ^= Zobrist::psq[pc][from] ^ Zobrist::psq[pc][to];
>       prefetch(thisThread->pawnsTable[st->pawnKey]);
852c837
<   st->psq += psq[us][pt][to] - psq[us][pt][from];
---
>   st->psq += PSQT::psq[pc][to] - PSQT::psq[pc][from];
855c840
<   st->capturedType = captured;
---
>   st->capturedPiece = captured;
860,883c845,846
<   // Update checkers bitboard: piece must be already moved due to attacks_from()
<   st->checkersBB = 0;
< 
<   if (moveIsCheck)
<   {
<       if (type_of(m) != NORMAL)
<           st->checkersBB = attackers_to(king_square(them)) & pieces(us);
<       else
<       {
<           // Direct checks
<           if (ci.checkSq[pt] & to)
<               st->checkersBB |= to;
< 
<           // Discovered checks
<           if (unlikely(ci.dcCandidates) && (ci.dcCandidates & from))
<           {
<               if (pt != ROOK)
<                   st->checkersBB |= attacks_from<ROOK>(king_square(them)) & pieces(us, QUEEN, ROOK);
< 
<               if (pt != BISHOP)
<                   st->checkersBB |= attacks_from<BISHOP>(king_square(them)) & pieces(us, QUEEN, BISHOP);
<           }
<       }
<   }
---
>   // Calculate checkers bitboard (if move gives check)
>   st->checkersBB = givesCheck ? attackers_to(square<KING>(them)) & pieces(us) : 0;
886a850,852
>   // Update king attacks used for fast check detection
>   set_check_info(st);
> 
903c869
<   PieceType pt = type_of(piece_on(to));
---
>   Piece pc = piece_on(to);
906c872
<   assert(st->capturedType != KING);
---
>   assert(type_of(st->capturedPiece) != KING);
910d875
<       assert(pt == promotion_type(m));
912c877,878
<       assert(promotion_type(m) >= KNIGHT && promotion_type(m) <= QUEEN);
---
>       assert(type_of(pc) == promotion_type(m));
>       assert(type_of(pc) >= KNIGHT && type_of(pc) <= QUEEN);
914,916c880,882
<       remove_piece(to, us, promotion_type(m));
<       put_piece(to, us, PAWN);
<       pt = PAWN;
---
>       remove_piece(pc, to);
>       pc = make_piece(us, PAWN);
>       put_piece(pc, to);
922c888
<       do_castling<false>(from, to, rfrom, rto);
---
>       do_castling<false>(us, from, to, rfrom, rto);
926c892
<       move_piece(to, from, us, pt); // Put the piece back at the source square
---
>       move_piece(pc, to, from); // Put the piece back at the source square
928c894
<       if (st->capturedType)
---
>       if (st->capturedPiece)
936c902
<               assert(pt == PAWN);
---
>               assert(type_of(pc) == PAWN);
939a906
>               assert(st->capturedPiece == make_piece(~us, PAWN));
942c909
<           put_piece(capsq, ~us, st->capturedType); // Restore the captured piece
---
>           put_piece(st->capturedPiece, capsq); // Restore the captured piece
955c922
< /// is a bit tricky, especially in Chess960.
---
> /// is a bit tricky in Chess960 where from/to squares can overlap.
957c924
< void Position::do_castling(Square from, Square& to, Square& rfrom, Square& rto) {
---
> void Position::do_castling(Color us, Square from, Square& to, Square& rfrom, Square& rto) {
961,962c928,929
<   rto = relative_square(sideToMove, kingSide ? SQ_F1 : SQ_D1);
<   to  = relative_square(sideToMove, kingSide ? SQ_G1 : SQ_C1);
---
>   rto = relative_square(us, kingSide ? SQ_F1 : SQ_D1);
>   to = relative_square(us, kingSide ? SQ_G1 : SQ_C1);
965,966c932,933
<   remove_piece(Do ?  from :  to, sideToMove, KING);
<   remove_piece(Do ? rfrom : rto, sideToMove, ROOK);
---
>   remove_piece(make_piece(us, KING), Do ? from : to);
>   remove_piece(make_piece(us, ROOK), Do ? rfrom : rto);
968,969c935,936
<   put_piece(Do ?  to :  from, sideToMove, KING);
<   put_piece(Do ? rto : rfrom, sideToMove, ROOK);
---
>   put_piece(make_piece(us, KING), Do ? to : from);
>   put_piece(make_piece(us, ROOK), Do ? rto : rfrom);
978a946
>   assert(&newSt != st);
980,981c948
<   std::memcpy(&newSt, st, sizeof(StateInfo)); // Fully copy here
< 
---
>   std::memcpy(&newSt, st, sizeof(StateInfo));
992c959
<   prefetch((char*)TT.first_entry(st->key));
---
>   prefetch(TT.first_entry(st->key));
998a966,967
>   set_check_info(st);
> 
1017d985
<   Color us = sideToMove;
1020,1021c988,989
<   PieceType pt = type_of(piece_on(from));
<   PieceType captured = type_of(piece_on(to));
---
>   Piece pc = piece_on(from);
>   Piece captured = piece_on(to);
1025c993
<       k ^= Zobrist::psq[~us][captured][to];
---
>       k ^= Zobrist::psq[captured][to];
1027c995
<   return k ^ Zobrist::psq[us][pt][to] ^ Zobrist::psq[us][pt][from];
---
>   return k ^ Zobrist::psq[pc][to] ^ Zobrist::psq[pc][from];
1031,1032c999,1001
< /// Position::see() is a static exchange evaluator: It tries to estimate the
< /// material gain or loss resulting from a move.
---
> /// Position::see_ge (Static Exchange Evaluation Greater or Equal) tests if the
> /// SEE value of move is greater or equal to the given value. We'll use an
> /// algorithm similar to alpha-beta pruning with a null window.
1034c1003
< Value Position::see_sign(Move m) const {
---
> bool Position::see_ge(Move m, Value v) const {
1038,1063d1006
<   // Early return if SEE cannot be negative because captured piece value
<   // is not less then capturing one. Note that king moves always return
<   // here because king midgame value is set to 0.
<   if (PieceValue[MG][moved_piece(m)] <= PieceValue[MG][piece_on(to_sq(m))])
<       return VALUE_KNOWN_WIN;
< 
<   return see(m);
< }
< 
< Value Position::see(Move m) const {
< 
<   Square from, to;
<   Bitboard occupied, attackers, stmAttackers;
<   Value swapList[32];
<   int slIndex = 1;
<   PieceType captured;
<   Color stm;
< 
<   assert(is_ok(m));
< 
<   from = from_sq(m);
<   to = to_sq(m);
<   swapList[0] = PieceValue[MG][piece_on(to)];
<   stm = color_of(piece_on(from));
<   occupied = pieces() ^ from;
< 
1065,1066c1008,1009
<   // handled correctly. Simply return 0 that is always the correct value
<   // unless in the rare case the rook ends up under attack.
---
>   // handled correctly. Simply assume the SEE value is VALUE_ZERO that is always
>   // correct unless in the rare case the rook ends up under attack.
1068c1011,1017
<       return VALUE_ZERO;
---
>       return VALUE_ZERO >= v;
> 
>   Square from = from_sq(m), to = to_sq(m);
>   PieceType nextVictim = type_of(piece_on(from));
>   Color stm = ~color_of(piece_on(from)); // First consider opponent's move
>   Value balance; // Values of the pieces taken by us minus opponent's ones
>   Bitboard occupied, stmAttackers;
1072,1073c1021,1027
<       occupied ^= to - pawn_push(stm); // Remove the captured pawn
<       swapList[0] = PieceValue[MG][PAWN];
---
>       occupied = SquareBB[to - pawn_push(~stm)]; // Remove the captured pawn
>       balance = PieceValue[MG][PAWN];
>   }
>   else
>   {
>       balance = PieceValue[MG][piece_on(to)];
>       occupied = 0;
1076,1092c1030,1031
<   // Find all attackers to the destination square, with the moving piece
<   // removed, but possibly an X-ray attacker added behind it.
<   attackers = attackers_to(to, occupied) & occupied;
< 
<   // If the opponent has no attackers we are finished
<   stm = ~stm;
<   stmAttackers = attackers & pieces(stm);
<   if (!stmAttackers)
<       return swapList[0];
< 
<   // The destination square is defended, which makes things rather more
<   // difficult to compute. We proceed by building up a "swap list" containing
<   // the material gain or loss at each stop in a sequence of captures to the
<   // destination square, where the sides alternately capture, and always
<   // capture with the least valuable piece. After each capture, we look for
<   // new X-ray attacks from behind the capturing piece.
<   captured = type_of(piece_on(from));
---
>   if (balance < v)
>       return false;
1094,1095c1033,1034
<   do {
<       assert(slIndex < 32);
---
>   if (nextVictim == KING)
>       return true;
1097,1098c1036
<       // Add the new entry to the swap list
<       swapList[slIndex] = -swapList[slIndex - 1] + PieceValue[MG][captured];
---
>   balance -= PieceValue[MG][nextVictim];
1100,1101c1038,1039
<       // Locate and remove the next least valuable attacker
<       captured = min_attacker<PAWN>(byTypeBB, to, stmAttackers, occupied, attackers);
---
>   if (balance >= v)
>       return true;
1103,1107c1041,1042
<       // Stop before processing a king capture
<       if (captured == KING)
<       {
<           if (stmAttackers == attackers)
<               ++slIndex;
---
>   bool relativeStm = true; // True if the opponent is to move
>   occupied ^= pieces() ^ from ^ to;
1109,1110c1044,1046
<           break;
<       }
---
>   // Find all attackers to the destination square, with the moving piece removed,
>   // but possibly an X-ray attacker added behind it.
>   Bitboard attackers = attackers_to(to, occupied) & occupied;
1112c1048,1049
<       stm = ~stm;
---
>   while (true)
>   {
1114d1050
<       ++slIndex;
1116c1052,1064
<   } while (stmAttackers);
---
>       // Don't allow pinned pieces to attack pieces except the king as long all
>       // pinners are on their original square.
>       if (!(st->pinnersForKing[stm] & ~occupied))
>           stmAttackers &= ~st->blockersForKing[stm];
> 
>       if (!stmAttackers)
>           return relativeStm;
> 
>       // Locate and remove the next least valuable attacker
>       nextVictim = min_attacker<PAWN>(byTypeBB, to, stmAttackers, occupied, attackers);
> 
>       if (nextVictim == KING)
>           return relativeStm == bool(attackers & pieces(~stm));
1118,1121c1066,1067
<   // Having built the swap list, we negamax through it to find the best
<   // achievable score from the point of view of the side to move.
<   while (--slIndex)
<       swapList[slIndex - 1] = std::min(-swapList[slIndex], swapList[slIndex - 1]);
---
>       balance += relativeStm ?  PieceValue[MG][nextVictim]
>                              : -PieceValue[MG][nextVictim];
1123c1069,1075
<   return swapList[0];
---
>       relativeStm = !relativeStm;
> 
>       if (relativeStm == (balance >= v))
>           return relativeStm;
> 
>       stm = ~stm;
>   }
1127,1128c1079,1080
< /// Position::is_draw() tests whether the position is drawn by material, 50 moves
< /// rule or repetition. It does not detect stalemates.
---
> /// Position::is_draw() tests whether the position is drawn by 50-move rule
> /// or by repetition. It does not detect stalemates.
1130c1082
< bool Position::is_draw() const {
---
> bool Position::is_draw(int ply) const {
1135,1136c1087,1095
<   StateInfo* stp = st;
<   for (int i = 2, e = std::min(st->rule50, st->pliesFromNull); i <= e; i += 2)
---
>   int end = std::min(st->rule50, st->pliesFromNull);
> 
>   if (end < 4)
>     return false;
> 
>   StateInfo* stp = st->previous->previous;
>   int cnt = 0;
> 
>   for (int i = 4; i <= end; i += 2)
1140,1141c1099,1104
<       if (stp->key == st->key)
<           return true; // Draw at first repetition
---
>       // At root position ply is 1, so return a draw score if a position
>       // repeats once earlier but after or at the root, or repeats twice
>       // strictly before the root.
>       if (   stp->key == st->key
>           && ++cnt + (ply - i > 0) == 2)
>           return true;
1151,1154d1113
< static char toggle_case(char c) {
<   return char(islower(c) ? toupper(c) : tolower(c));
< }
< 
1172c1131,1132
<   std::transform(f.begin(), f.end(), f.begin(), toggle_case);
---
>   std::transform(f.begin(), f.end(), f.begin(),
>                  [](char c) { return char(islower(c) ? toupper(c) : tolower(c)); });
1180c1140
<   set(f, is_chess960(), this_thread());
---
>   set(f, is_chess960(), st, this_thread());
1189c1149
< bool Position::pos_is_ok(int* step) const {
---
> bool Position::pos_is_ok(int* failedStep) const {
1191,1192c1151
<   // Which parts of the position should be verified?
<   const bool all = false;
---
>   const bool Fast = true; // Quick (default) or full check?
1194,1210c1153
<   const bool testBitboards       = all || false;
<   const bool testState           = all || false;
<   const bool testKingCount       = all || false;
<   const bool testKingCapture     = all || false;
<   const bool testPieceCounts     = all || false;
<   const bool testPieceList       = all || false;
<   const bool testCastlingSquares = all || false;
< 
<   if (step)
<       *step = 1;
< 
<   if (   (sideToMove != WHITE && sideToMove != BLACK)
<       || piece_on(king_square(WHITE)) != W_KING
<       || piece_on(king_square(BLACK)) != B_KING
<       || (   ep_square() != SQ_NONE
<           && relative_rank(sideToMove, ep_square()) != RANK_6))
<       return false;
---
>   enum { Default, King, Bitboards, State, Lists, Castling };
1212c1155
<   if (step && ++*step, testBitboards)
---
>   for (int step = Default; step <= (Fast ? Default : Castling); step++)
1214,1216c1157,1158
<       // The intersection of the white and black pieces must be empty
<       if (pieces(WHITE) & pieces(BLACK))
<           return false;
---
>       if (failedStep)
>           *failedStep = step;
1218,1221c1160,1166
<       // The union of the white and black pieces must be equal to all
<       // occupied squares
<       if ((pieces(WHITE) | pieces(BLACK)) != pieces())
<           return false;
---
>       if (step == Default)
>           if (   (sideToMove != WHITE && sideToMove != BLACK)
>               || piece_on(square<KING>(WHITE)) != W_KING
>               || piece_on(square<KING>(BLACK)) != B_KING
>               || (   ep_square() != SQ_NONE
>                   && relative_rank(sideToMove, ep_square()) != RANK_6))
>               return false;
1223,1228c1168,1172
<       // Separate piece type bitboards must have empty intersections
<       for (PieceType p1 = PAWN; p1 <= KING; ++p1)
<           for (PieceType p2 = PAWN; p2 <= KING; ++p2)
<               if (p1 != p2 && (pieces(p1) & pieces(p2)))
<                   return false;
<   }
---
>       if (step == King)
>           if (   std::count(board, board + SQUARE_NB, W_KING) != 1
>               || std::count(board, board + SQUARE_NB, B_KING) != 1
>               || attackers_to(square<KING>(~sideToMove)) & pieces(sideToMove))
>               return false;
1230,1242c1174,1178
<   if (step && ++*step, testState)
<   {
<       StateInfo si;
<       set_state(&si);
<       if (   st->key != si.key
<           || st->pawnKey != si.pawnKey
<           || st->materialKey != si.materialKey
<           || st->nonPawnMaterial[WHITE] != si.nonPawnMaterial[WHITE]
<           || st->nonPawnMaterial[BLACK] != si.nonPawnMaterial[BLACK]
<           || st->psq != si.psq
<           || st->checkersBB != si.checkersBB)
<           return false;
<   }
---
>       if (step == Bitboards)
>       {
>           if (  (pieces(WHITE) & pieces(BLACK))
>               ||(pieces(WHITE) | pieces(BLACK)) != pieces())
>               return false;
1244,1247c1180,1184
<   if (step && ++*step, testKingCount)
<       if (   std::count(board, board + SQUARE_NB, W_KING) != 1
<           || std::count(board, board + SQUARE_NB, B_KING) != 1)
<           return false;
---
>           for (PieceType p1 = PAWN; p1 <= KING; ++p1)
>               for (PieceType p2 = PAWN; p2 <= KING; ++p2)
>                   if (p1 != p2 && (pieces(p1) & pieces(p2)))
>                       return false;
>       }
1249,1251c1186,1192
<   if (step && ++*step, testKingCapture)
<       if (attackers_to(king_square(~sideToMove)) & pieces(sideToMove))
<           return false;
---
>       if (step == State)
>       {
>           StateInfo si = *st;
>           set_state(&si);
>           if (std::memcmp(&si, st, sizeof(StateInfo)))
>               return false;
>       }
1253,1256c1194,1197
<   if (step && ++*step, testPieceCounts)
<       for (Color c = WHITE; c <= BLACK; ++c)
<           for (PieceType pt = PAWN; pt <= KING; ++pt)
<               if (pieceCount[c][pt] != popcount<Full>(pieces(c, pt)))
---
>       if (step == Lists)
>           for (Piece pc : Pieces)
>           {
>               if (pieceCount[pc] != popcount(pieces(color_of(pc), type_of(pc))))
1259,1264c1200,1201
<   if (step && ++*step, testPieceList)
<       for (Color c = WHITE; c <= BLACK; ++c)
<           for (PieceType pt = PAWN; pt <= KING; ++pt)
<               for (int i = 0; i < pieceCount[c][pt];  ++i)
<                   if (   board[pieceList[c][pt][i]] != make_piece(c, pt)
<                       || index[pieceList[c][pt][i]] != i)
---
>               for (int i = 0; i < pieceCount[pc]; ++i)
>                   if (board[pieceList[pc][i]] != pc || index[pieceList[pc][i]] != i)
1266,1277d1202
< 
<   if (step && ++*step, testCastlingSquares)
<       for (Color c = WHITE; c <= BLACK; ++c)
<           for (CastlingSide s = KING_SIDE; s <= QUEEN_SIDE; s = CastlingSide(s + 1))
<           {
<               if (!can_castle(c | s))
<                   continue;
< 
<               if (  (castlingRightsMask[king_square(c)] & (c | s)) != (c | s)
<                   || piece_on(castlingRookSquare[c | s]) != make_piece(c, ROOK)
<                   || castlingRightsMask[castlingRookSquare[c | s]] != (c | s))
<                   return false;
1278a1204,1217
> 
>       if (step == Castling)
>           for (Color c = WHITE; c <= BLACK; ++c)
>               for (CastlingSide s = KING_SIDE; s <= QUEEN_SIDE; s = CastlingSide(s + 1))
>               {
>                   if (!can_castle(c | s))
>                       continue;
> 
>                   if (   piece_on(castlingRookSquare[c | s]) != make_piece(c, ROOK)
>                       || castlingRightsMask[castlingRookSquare[c | s]] != (c | s)
>                       ||(castlingRightsMask[square<KING>(c)] & (c | s)) != (c | s))
>                       return false;
>               }
>   }
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
24c25,27
< #include <cstddef>
---
> #include <deque>
> #include <memory> // For std::unique_ptr
> #include <string>
30,49c33,35
< /// The checkInfo struct is initialized at c'tor time and keeps info used
< /// to detect if a move gives check.
< class Position;
< struct Thread;
< 
< struct CheckInfo {
< 
<   explicit CheckInfo(const Position&);
< 
<   Bitboard dcCandidates;
<   Bitboard pinned;
<   Bitboard checkSq[PIECE_TYPE_NB];
<   Square ksq;
< };
< 
< 
< /// The StateInfo struct stores information needed to restore a Position
< /// object to its previous state when we retract a move. Whenever a move
< /// is made on the board (by calling Position::do_move), a StateInfo
< /// object must be passed as a parameter.
---
> /// StateInfo struct stores information needed to restore a Position object to
> /// its previous state when we retract a move. Whenever a move is made on the
> /// board (by calling Position::do_move), a StateInfo object must be passed.
52,55c38,46
<   Key pawnKey, materialKey;
<   Value nonPawnMaterial[COLOR_NB];
<   int castlingRights, rule50, pliesFromNull;
<   Score psq;
---
> 
>   // Copied when making a move
>   Key    pawnKey;
>   Key    materialKey;
>   Value  nonPawnMaterial[COLOR_NB];
>   int    castlingRights;
>   int    rule50;
>   int    pliesFromNull;
>   Score  psq;
58,60c49,52
<   Key key;
<   Bitboard checkersBB;
<   PieceType capturedType;
---
>   // Not copied when making a move (will be recomputed anyhow)
>   Key        key;
>   Bitboard   checkersBB;
>   Piece      capturedPiece;
61a54,56
>   Bitboard   blockersForKing[COLOR_NB];
>   Bitboard   pinnersForKing[COLOR_NB];
>   Bitboard   checkSquares[PIECE_TYPE_NB];
63a59,60
> // In a std::deque references to elements are unaffected upon resizing
> typedef std::unique_ptr<std::deque<StateInfo>> StateListPtr;
65,67d61
< /// When making a move the current StateInfo up to 'key' excluded is copied to
< /// the new one. Here we calculate the quad words (64bits) needed to be copied.
< const size_t StateCopySize64 = offsetof(StateInfo, key) / sizeof(uint64_t) + 1;
69,73c63,67
< 
< /// The Position class stores the information regarding the board representation
< /// like pieces, side to move, hash keys, castling info, etc. The most important
< /// methods are do_move() and undo_move(), used by the search to update node info
< /// when traversing the search tree.
---
> /// Position class stores information regarding the board representation as
> /// pieces, side to move, hash keys, castling info, etc. Important methods are
> /// do_move() and undo_move(), used by the search to update node info when
> /// traversing the search tree.
> class Thread;
76,78d69
< 
<   friend std::ostream& operator<<(std::ostream&, const Position&);
< 
80,83d70
<   Position() {}
<   Position(const Position& pos, Thread* th) { *this = pos; thisThread = th; }
<   Position(const std::string& f, bool c960, Thread* th) { set(f, c960, th); }
<   Position& operator=(const Position&);
85a73,76
>   Position() = default;
>   Position(const Position&) = delete;
>   Position& operator=(const Position&) = delete;
> 
87c78,79
<   void set(const std::string& fenStr, bool isChess960, Thread* th);
---
>   Position& set(const std::string& fenStr, bool isChess960, StateInfo* si, Thread* th);
>   Position& set(const std::string& code, Color c, StateInfo* si);
98d89
<   Square king_square(Color c) const;
102c93,94
<   template<PieceType Pt> const Square* list(Color c) const;
---
>   template<PieceType Pt> const Square* squares(Color c) const;
>   template<PieceType Pt> Square square(Color c) const;
113a106
>   Bitboard check_squares(PieceType pt) const;
120a114
>   Bitboard slider_blockers(Bitboard sliders, Square s, Bitboard& pinners) const;
123c117
<   bool legal(Move m, Bitboard pinned) const;
---
>   bool legal(Move m) const;
127c121
<   bool gives_check(Move m, const CheckInfo& ci) const;
---
>   bool gives_check(Move m) const;
130c124
<   PieceType captured_piece_type() const;
---
>   Piece captured_piece() const;
134,135d127
<   bool pawn_on_7th(Color c) const;
<   bool bishop_pair(Color c) const;
139,140c131,132
<   void do_move(Move m, StateInfo& st);
<   void do_move(Move m, StateInfo& st, const CheckInfo& ci, bool moveIsCheck);
---
>   void do_move(Move m, StateInfo& newSt);
>   void do_move(Move m, StateInfo& newSt, bool givesCheck);
142c134
<   void do_null_move(StateInfo& st);
---
>   void do_null_move(StateInfo& newSt);
145,147c137,138
<   // Static exchange evaluation
<   Value see(Move m) const;
<   Value see_sign(Move m) const;
---
>   // Static Exchange Evaluation
>   bool see_ge(Move m, Value value) const;
152,153d142
<   Key exclusion_key() const;
<   Key pawn_key() const;
155,158c144
< 
<   // Incremental piece-square evaluation
<   Score psq_score() const;
<   Value non_pawn_material(Color c) const;
---
>   Key pawn_key() const;
167,168c153
<   void set_nodes_searched(uint64_t n);
<   bool is_draw() const;
---
>   bool is_draw(int ply) const;
169a155,156
>   Score psq_score() const;
>   Value non_pawn_material(Color c) const;
172c159
<   bool pos_is_ok(int* step = NULL) const;
---
>   bool pos_is_ok(int* failedStep = nullptr) const;
177d163
<   void clear();
179a166
>   void set_check_info(StateInfo* si) const;
181,185c168,171
<   // Helper functions
<   Bitboard check_blockers(Color c, Color kingColor) const;
<   void put_piece(Square s, Color c, PieceType pt);
<   void remove_piece(Square s, Color c, PieceType pt);
<   void move_piece(Square from, Square to, Color c, PieceType pt);
---
>   // Other helpers
>   void put_piece(Piece pc, Square s);
>   void remove_piece(Piece pc, Square s);
>   void move_piece(Piece pc, Square from, Square to);
187c173
<   void do_castling(Square from, Square& to, Square& rfrom, Square& rto);
---
>   void do_castling(Color us, Square from, Square& to, Square& rfrom, Square& rto);
189c175
<   // Board and pieces
---
>   // Data members
193,194c179,180
<   int pieceCount[COLOR_NB][PIECE_TYPE_NB];
<   Square pieceList[COLOR_NB][PIECE_TYPE_NB][16];
---
>   int pieceCount[PIECE_NB];
>   Square pieceList[PIECE_NB][16];
196,197d181
< 
<   // Other info
201d184
<   StateInfo startState;
210,211c193,196
< inline uint64_t Position::nodes_searched() const {
<   return nodes;
---
> extern std::ostream& operator<<(std::ostream& os, const Position& pos);
> 
> inline Color Position::side_to_move() const {
>   return sideToMove;
214,215c199,200
< inline void Position::set_nodes_searched(uint64_t n) {
<   nodes = n;
---
> inline bool Position::empty(Square s) const {
>   return board[s] == NO_PIECE;
226,233d210
< inline bool Position::empty(Square s) const {
<   return board[s] == NO_PIECE;
< }
< 
< inline Color Position::side_to_move() const {
<   return sideToMove;
< }
< 
259c236
<   return pieceCount[c][Pt];
---
>   return pieceCount[make_piece(c, Pt)];
262,263c239,240
< template<PieceType Pt> inline const Square* Position::list(Color c) const {
<   return pieceList[c][Pt];
---
> template<PieceType Pt> inline const Square* Position::squares(Color c) const {
>   return pieceList[make_piece(c, Pt)];
266,267c243,245
< inline Square Position::ep_square() const {
<   return st->epSquare;
---
> template<PieceType Pt> inline Square Position::square(Color c) const {
>   assert(pieceCount[make_piece(c, Pt)] == 1);
>   return pieceList[make_piece(c, Pt)][0];
270,271c248,249
< inline Square Position::king_square(Color c) const {
<   return pieceList[c][KING][0];
---
> inline Square Position::ep_square() const {
>   return st->epSquare;
292d269
< 
316c293
<   return check_blockers(sideToMove, ~sideToMove);
---
>   return st->blockersForKing[~sideToMove] & pieces(sideToMove);
320c297,301
<   return check_blockers(c, c);
---
>   return st->blockersForKing[c] & pieces(c);
> }
> 
> inline Bitboard Position::check_squares(PieceType pt) const {
>   return st->checkSquares[pt];
360,370c341,342
< inline bool Position::opposite_bishops() const {
< 
<   return   pieceCount[WHITE][BISHOP] == 1
<         && pieceCount[BLACK][BISHOP] == 1
<         && opposite_colors(pieceList[WHITE][BISHOP][0], pieceList[BLACK][BISHOP][0]);
< }
< 
< inline bool Position::bishop_pair(Color c) const {
< 
<   return   pieceCount[c][BISHOP] >= 2
<         && opposite_colors(pieceList[c][BISHOP][0], pieceList[c][BISHOP][1]);
---
> inline uint64_t Position::nodes_searched() const {
>   return nodes;
373,374c345,348
< inline bool Position::pawn_on_7th(Color c) const {
<   return pieces(c, PAWN) & rank_bb(relative_rank(c, RANK_7));
---
> inline bool Position::opposite_bishops() const {
>   return   pieceCount[W_BISHOP] == 1
>         && pieceCount[B_BISHOP] == 1
>         && opposite_colors(square<BISHOP>(WHITE), square<BISHOP>(BLACK));
382d355
< 
388,389d360
< 
<   // Note that castling is encoded as "king captures the rook"
390a362
>   // Castling is encoded as "king captures rook"
394,395c366,367
< inline PieceType Position::captured_piece_type() const {
<   return st->capturedType;
---
> inline Piece Position::captured_piece() const {
>   return st->capturedPiece;
402c374
< inline void Position::put_piece(Square s, Color c, PieceType pt) {
---
> inline void Position::put_piece(Piece pc, Square s) {
404c376
<   board[s] = make_piece(c, pt);
---
>   board[s] = pc;
406,410c378,382
<   byTypeBB[pt] |= s;
<   byColorBB[c] |= s;
<   index[s] = pieceCount[c][pt]++;
<   pieceList[c][pt][index[s]] = s;
<   pieceCount[c][ALL_PIECES]++;
---
>   byTypeBB[type_of(pc)] |= s;
>   byColorBB[color_of(pc)] |= s;
>   index[s] = pieceCount[pc]++;
>   pieceList[pc][index[s]] = s;
>   pieceCount[make_piece(color_of(pc), ALL_PIECES)]++;
413c385,400
< inline void Position::move_piece(Square from, Square to, Color c, PieceType pt) {
---
> inline void Position::remove_piece(Piece pc, Square s) {
> 
>   // WARNING: This is not a reversible operation. If we remove a piece in
>   // do_move() and then replace it in undo_move() we will put it at the end of
>   // the list and not in its original place, it means index[] and pieceList[]
>   // are not invariant to a do_move() + undo_move() sequence.
>   byTypeBB[ALL_PIECES] ^= s;
>   byTypeBB[type_of(pc)] ^= s;
>   byColorBB[color_of(pc)] ^= s;
>   /* board[s] = NO_PIECE;  Not needed, overwritten by the capturing one */
>   Square lastSquare = pieceList[pc][--pieceCount[pc]];
>   index[lastSquare] = index[s];
>   pieceList[pc][index[lastSquare]] = lastSquare;
>   pieceList[pc][pieceCount[pc]] = SQ_NONE;
>   pieceCount[make_piece(color_of(pc), ALL_PIECES)]--;
> }
415,416c402,405
<   // index[from] is not updated and becomes stale. This works as long
<   // as index[] is accessed just by known occupied squares.
---
> inline void Position::move_piece(Piece pc, Square from, Square to) {
> 
>   // index[from] is not updated and becomes stale. This works as long as index[]
>   // is accessed just by known occupied squares.
419,420c408,409
<   byTypeBB[pt] ^= from_to_bb;
<   byColorBB[c] ^= from_to_bb;
---
>   byTypeBB[type_of(pc)] ^= from_to_bb;
>   byColorBB[color_of(pc)] ^= from_to_bb;
422c411
<   board[to] = make_piece(c, pt);
---
>   board[to] = pc;
424c413
<   pieceList[c][pt][index[to]] = to;
---
>   pieceList[pc][index[to]] = to;
427,441c416,417
< inline void Position::remove_piece(Square s, Color c, PieceType pt) {
< 
<   // WARNING: This is not a reversible operation. If we remove a piece in
<   // do_move() and then replace it in undo_move() we will put it at the end of
<   // the list and not in its original place, it means index[] and pieceList[]
<   // are not guaranteed to be invariant to a do_move() + undo_move() sequence.
<   byTypeBB[ALL_PIECES] ^= s;
<   byTypeBB[pt] ^= s;
<   byColorBB[c] ^= s;
<   /* board[s] = NO_PIECE; */ // Not needed, will be overwritten by capturing
<   Square lastSquare = pieceList[c][pt][--pieceCount[c][pt]];
<   index[lastSquare] = index[s];
<   pieceList[c][pt][index[lastSquare]] = lastSquare;
<   pieceList[c][pt][pieceCount[c][pt]] = SQ_NONE;
<   pieceCount[c][ALL_PIECES]--;
---
> inline void Position::do_move(Move m, StateInfo& newSt) {
>   do_move(m, newSt, gives_check(m));
****************************************************************
pawns
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
24d24
< #include "bitcount.h"
26a27
> #include "thread.h"
33,50c34,35
<   // Doubled pawn penalty by file
<   const Score Doubled[FILE_NB] = {
<     S(13, 43), S(20, 48), S(23, 48), S(23, 48),
<     S(23, 48), S(23, 48), S(20, 48), S(13, 43) };
< 
<   // Isolated pawn penalty by opposed flag and file
<   const Score Isolated[2][FILE_NB] = {
<   { S(37, 45), S(54, 52), S(60, 52), S(60, 52),
<     S(60, 52), S(60, 52), S(54, 52), S(37, 45) },
<   { S(25, 30), S(36, 35), S(40, 35), S(40, 35),
<     S(40, 35), S(40, 35), S(36, 35), S(25, 30) } };
< 
<   // Backward pawn penalty by opposed flag and file
<   const Score Backward[2][FILE_NB] = {
<   { S(30, 42), S(43, 46), S(49, 46), S(49, 46),
<     S(49, 46), S(49, 46), S(43, 46), S(30, 42) },
<   { S(20, 28), S(29, 31), S(33, 31), S(33, 31),
<     S(33, 31), S(33, 31), S(29, 31), S(20, 28) } };
---
>   // Isolated pawn penalty by opposed flag
>   const Score Isolated[2] = { S(45, 40), S(30, 27) };
52,53c37,38
<   // Connected pawn bonus by opposed, phalanx flags and rank
<   Score Connected[2][2][RANK_NB];
---
>   // Backward pawn penalty by opposed flag
>   const Score Backward[2] = { S(56, 33), S(41, 19) };
55,58c40,44
<   // Levers bonus by rank
<   const Score Lever[RANK_NB] = {
<     S( 0, 0), S( 0, 0), S(0, 0), S(0, 0),
<     S(20,20), S(40,40), S(0, 0), S(0, 0) };
---
>   // Unsupported pawn penalty for pawns which are neither isolated or backward
>   const Score Unsupported = S(17, 8);
> 
>   // Connected pawn bonus by opposed, phalanx, twice supported and rank
>   Score Connected[2][2][2][RANK_NB];
60,61c46,47
<   // Unsupported pawn penalty
<   const Score UnsupportedPawnPenalty = S(20, 10);
---
>   // Doubled pawn penalty
>   const Score Doubled = S(18, 38);
63,75c49,84
<   // Weakness of our pawn shelter in front of the king indexed by [rank]
<   const Value ShelterWeakness[RANK_NB] =
<   { V(100), V(0), V(27), V(73), V(92), V(101), V(101) };
< 
<   // Danger of enemy pawns moving toward our king indexed by
<   // [edge files][no friendly pawn | pawn unblocked | pawn blocked][rank of enemy pawn]
<   const Value StormDanger[][3][RANK_NB] = {
<   { { V( 0),  V(64), V(128), V(51), V(26) },
<     { V(26),  V(32), V( 96), V(38), V(20) },
<     { V( 0),  V( 0), V(160), V(25), V(13) } },
<   { { V( 0),  V(64), V(128), V(51), V(26) },
<     { V(26),  V(32), V( 96), V(38), V(20) },
<     { V( 0),  V( 0), V( 80), V(13), V( 7) } } };
---
>   // Lever bonus by rank
>   const Score Lever[RANK_NB] = {
>     S( 0,  0), S( 0,  0), S(0, 0), S(0, 0),
>     S(17, 16), S(33, 32), S(0, 0), S(0, 0)
>   };
> 
>   // Weakness of our pawn shelter in front of the king by [distance from edge][rank].
>   // RANK_1 = 0 is used for files where we have no pawns or our pawn is behind our king.
>   const Value ShelterWeakness[][RANK_NB] = {
>     { V(100), V(20), V(10), V(46), V(82), V( 86), V( 98) },
>     { V(116), V( 4), V(28), V(87), V(94), V(108), V(104) },
>     { V(109), V( 1), V(59), V(87), V(62), V( 91), V(116) },
>     { V( 75), V(12), V(43), V(59), V(90), V( 84), V(112) }
>   };
> 
>   // Danger of enemy pawns moving toward our king by [type][distance from edge][rank].
>   // For the unopposed and unblocked cases, RANK_1 = 0 is used when opponent has no pawn
>   // on the given file, or their pawn is behind our king.
>   const Value StormDanger[][4][RANK_NB] = {
>     { { V( 0),  V(-290), V(-274), V(57), V(41) },  //BlockedByKing
>       { V( 0),  V(  60), V( 144), V(39), V(13) },
>       { V( 0),  V(  65), V( 141), V(41), V(34) },
>       { V( 0),  V(  53), V( 127), V(56), V(14) } },
>     { { V( 4),  V(  73), V( 132), V(46), V(31) },  //Unopposed
>       { V( 1),  V(  64), V( 143), V(26), V(13) },
>       { V( 1),  V(  47), V( 110), V(44), V(24) },
>       { V( 0),  V(  72), V( 127), V(50), V(31) } },
>     { { V( 0),  V(   0), V(  79), V(23), V( 1) },  //BlockedByPawn
>       { V( 0),  V(   0), V( 148), V(27), V( 2) },
>       { V( 0),  V(   0), V( 161), V(16), V( 1) },
>       { V( 0),  V(   0), V( 171), V(22), V(15) } },
>     { { V(22),  V(  45), V( 104), V(62), V( 6) },  //Unblocked
>       { V(31),  V(  30), V(  99), V(39), V(19) },
>       { V(23),  V(  29), V(  96), V(41), V(15) },
>       { V(21),  V(  23), V( 116), V(41), V(15) } }
>   };
79c88
<   const Value MaxSafetyBonus = V(263);
---
>   const Value MaxSafetyBonus = V(258);
87,90c96,99
<     const Color  Them  = (Us == WHITE ? BLACK    : WHITE);
<     const Square Up    = (Us == WHITE ? DELTA_N  : DELTA_S);
<     const Square Right = (Us == WHITE ? DELTA_NE : DELTA_SW);
<     const Square Left  = (Us == WHITE ? DELTA_NW : DELTA_SE);
---
>     const Color  Them  = (Us == WHITE ? BLACK      : WHITE);
>     const Square Up    = (Us == WHITE ? NORTH      : SOUTH);
>     const Square Right = (Us == WHITE ? NORTH_EAST : SOUTH_WEST);
>     const Square Left  = (Us == WHITE ? NORTH_WEST : SOUTH_EAST);
92c101,102
<     Bitboard b, p, doubled, connected;
---
>     Bitboard b, neighbours, stoppers, doubled, supported, phalanx;
>     Bitboard lever, leverPush, connected;
94,96c104,106
<     bool passed, isolated, opposed, phalanx, backward, unsupported, lever;
<     Score value = SCORE_ZERO;
<     const Square* pl = pos.list<PAWN>(Us);
---
>     bool opposed, backward;
>     Score score = SCORE_ZERO;
>     const Square* pl = pos.squares<PAWN>(Us);
102,103c112
<     e->passedPawns[Us] = 0;
<     e->kingSquares[Us] = SQ_NONE;
---
>     e->passedPawns[Us]   = e->pawnAttacksSpan[Us] = 0;
105,106c114,116
<     e->pawnAttacks[Us] = shift_bb<Right>(ourPawns) | shift_bb<Left>(ourPawns);
<     e->pawnsOnSquares[Us][BLACK] = popcount<Max15>(ourPawns & DarkSquares);
---
>     e->kingSquares[Us]   = SQ_NONE;
>     e->pawnAttacks[Us]   = shift<Right>(ourPawns) | shift<Left>(ourPawns);
>     e->pawnsOnSquares[Us][BLACK] = popcount(ourPawns & DarkSquares);
116,117c126,127
<         // This file cannot be semi-open
<         e->semiopenFiles[Us] &= ~(1 << f);
---
>         e->semiopenFiles[Us]   &= ~(1 << f);
>         e->pawnAttacksSpan[Us] |= pawn_attack_span(Us, s);
119,139c129,142
<         // Previous rank
<         p = rank_bb(s - pawn_push(Us));
< 
<         // Flag the pawn as passed, isolated, doubled,
<         // unsupported or connected (but not the backward one).
<         connected   =   ourPawns   & adjacent_files_bb(f) & (rank_bb(s) | p);
<         phalanx     =   connected  & rank_bb(s);
<         unsupported = !(ourPawns   & adjacent_files_bb(f) & p);
<         isolated    = !(ourPawns   & adjacent_files_bb(f));
<         doubled     =   ourPawns   & forward_bb(Us, s);
<         opposed     =   theirPawns & forward_bb(Us, s);
<         passed      = !(theirPawns & passed_pawn_mask(Us, s));
<         lever       =   theirPawns & pawnAttacksBB[s];
< 
<         // Test for backward pawn.
<         // If the pawn is passed, isolated, or connected it cannot be
<         // backward. If there are friendly pawns behind on adjacent files
<         // or if it can capture an enemy pawn it cannot be backward either.
<         if (   (passed | isolated | connected)
<             || (ourPawns & pawn_attack_span(Them, s))
<             || (pos.attacks_from<PAWN>(s, Us) & theirPawns))
---
>         // Flag the pawn
>         opposed    = theirPawns & forward_bb(Us, s);
>         stoppers   = theirPawns & passed_pawn_mask(Us, s);
>         lever      = theirPawns & pawnAttacksBB[s];
>         leverPush  = theirPawns & pawnAttacksBB[s + Up];
>         doubled    = ourPawns   & (s + Up);
>         neighbours = ourPawns   & adjacent_files_bb(f);
>         phalanx    = neighbours & rank_bb(s);
>         supported  = neighbours & rank_bb(s - Up);
>         connected  = supported | phalanx;
> 
>         // A pawn is backward when it is behind all pawns of the same color on the
>         // adjacent files and cannot be safely advanced.
>         if (!neighbours || lever || relative_rank(Us, s) >= RANK_5)
143,153c146,147
<             // We now know that there are no friendly pawns beside or behind this
<             // pawn on adjacent files. We now check whether the pawn is
<             // backward by looking in the forward direction on the adjacent
<             // files, and picking the closest pawn there.
<             b = pawn_attack_span(Us, s) & (ourPawns | theirPawns);
<             b = pawn_attack_span(Us, s) & rank_bb(backmost_sq(Us, b));
< 
<             // If we have an enemy pawn in the same or next rank, the pawn is
<             // backward because it cannot advance without being captured.
<             backward = (b | shift_bb<Up>(b)) & theirPawns;
<         }
---
>             // Find the backmost rank with neighbours or stoppers
>             b = rank_bb(backmost_sq(Us, neighbours | stoppers));
155c149,155
<         assert(opposed | passed | (pawn_attack_span(Us, s) & theirPawns));
---
>             // The pawn is backward when it cannot safely progress to that rank:
>             // either there is a stopper in the way on this rank, or there is a
>             // stopper on adjacent file which controls the way to that rank.
>             backward = (b | shift<Up>(b & adjacent_files_bb(f))) & stoppers;
> 
>             assert(!backward || !(pawn_attack_span(Them, s + Up) & neighbours));
>         }
158,160c158,164
<         // full attack info to evaluate passed pawns. Only the frontmost passed
<         // pawn on each file is considered a true passed pawn.
<         if (passed && !doubled)
---
>         // full attack info to evaluate them. Include also not passed pawns
>         // which could become passed after one or two pawn pushes when are
>         // not attacked more times than defended.
>         if (   !(stoppers ^ lever ^ leverPush)
>             && !(ourPawns & forward_bb(Us, s))
>             && popcount(supported) >= popcount(lever)
>             && popcount(phalanx)   >= popcount(leverPush))
164,165c168,169
<         if (isolated)
<             value -= Isolated[opposed][f];
---
>         if (!neighbours)
>             score -= Isolated[opposed];
167,171c171,172
<         if (unsupported && !isolated)
<             value -= UnsupportedPawnPenalty;
< 
<         if (doubled)
<             value -= Doubled[f] / distance<Rank>(s, frontmost_sq(Us, doubled));
---
>         else if (backward)
>             score -= Backward[opposed];
173,174c174,175
<         if (backward)
<             value -= Backward[opposed][f];
---
>         else if (!supported)
>             score -= Unsupported;
177c178,181
<             value += Connected[opposed][phalanx][relative_rank(Us, s)];
---
>             score += Connected[opposed][!!phalanx][more_than_one(supported)][relative_rank(Us, s)];
> 
>         if (doubled)
>             score -= Doubled;
180c184
<             value += Lever[relative_rank(Us, s)];
---
>             score += Lever[relative_rank(Us, s)];
183,186c187
<     b = e->semiopenFiles[Us] ^ 0xFF;
<     e->pawnSpan[Us] = b ? int(msb(b) - lsb(b)) : 0;
< 
<     return value;
---
>     return score;
193,199c194,200
< /// init() initializes some tables used by evaluation. Instead of hard-coded
< /// tables, when makes sense, we prefer to calculate them with a formula to
< /// reduce independent parameters and to allow easier tuning and better insight.
< 
< void init()
< {
<   static const int Seed[RANK_NB] = { 0, 6, 15, 10, 57, 75, 135, 258 };
---
> /// Pawns::init() initializes some tables needed by evaluation. Instead of using
> /// hard-coded tables, when makes sense, we prefer to calculate them with a formula
> /// to reduce independent parameters and to allow easier tuning and better insight.
> 
> void init() {
> 
>   static const int Seed[RANK_NB] = { 0, 8, 19, 13, 71, 94, 169, 324 };
203,207c204,210
<           for (Rank r = RANK_2; r < RANK_8; ++r)
<           {
<               int bonus = Seed[r] + (phalanx ? (Seed[r + 1] - Seed[r]) / 2 : 0);
<               Connected[opposed][phalanx][r] = make_score(bonus / 2, bonus >> opposed);
<           }
---
>           for (int apex = 0; apex <= 1; ++apex)
>               for (Rank r = RANK_2; r < RANK_8; ++r)
>   {
>       int v = (Seed[r] + (phalanx ? (Seed[r + 1] - Seed[r]) / 2 : 0)) >> opposed;
>       v += (apex ? v / 2 : 0);
>       Connected[opposed][phalanx][apex][r] = make_score(v, v * (r-2) / 4);
>   }
211,213c214,217
< /// probe() takes a position as input, computes a Entry object, and returns a
< /// pointer to it. The result is also stored in a hash table, so we don't have
< /// to recompute everything when the same pawn structure occurs again.
---
> /// Pawns::probe() looks up the current position's pawns configuration in
> /// the pawns hash table. It returns a pointer to the Entry if the position
> /// is found. Otherwise a new Entry is computed and stored there, so we don't
> /// have to recompute all when the same pawns configuration occurs again.
215c219
< Entry* probe(const Position& pos, Table& entries) {
---
> Entry* probe(const Position& pos) {
218c222
<   Entry* e = entries[key];
---
>   Entry* e = pos.this_thread()->pawnsTable[key];
224c228,230
<   e->value = evaluate<WHITE>(pos, e) - evaluate<BLACK>(pos, e);
---
>   e->score = evaluate<WHITE>(pos, e) - evaluate<BLACK>(pos, e);
>   e->asymmetry = popcount(e->semiopenFiles[WHITE] ^ e->semiopenFiles[BLACK]);
>   e->openFiles = popcount(e->semiopenFiles[WHITE] & e->semiopenFiles[BLACK]);
230c236
< /// the king is on, as well as the two adjacent files.
---
> /// the king is on, as well as the two closest files.
236c242,243
<   const Bitboard Edges = (FileABB | FileHBB) & (Rank2BB | Rank3BB);
---
> 
>   enum { BlockedByKing, Unopposed, BlockedByPawn, Unblocked };
242c249
<   File kf = std::max(FILE_B, std::min(FILE_G, file_of(ksq)));
---
>   File center = std::max(FILE_B, std::min(FILE_G, file_of(ksq)));
244c251
<   for (File f = kf - File(1); f <= kf + File(1); ++f)
---
>   for (File f = center - File(1); f <= center + File(1); ++f)
252,260c259,264
<       if (   (Edges & make_square(f, rkThem))
<           && file_of(ksq) == f
<           && relative_rank(Us, ksq) == rkThem - 1)
<           safety += 200;
<       else
<           safety -=  ShelterWeakness[rkUs]
<                    + StormDanger[f == FILE_A || f == FILE_H]
<                                 [rkUs   == RANK_1   ? 0 :
<                                  rkThem != rkUs + 1 ? 1 : 2][rkThem];
---
>       safety -=  ShelterWeakness[std::min(f, FILE_H - f)][rkUs]
>                + StormDanger
>                  [f == file_of(ksq) && rkThem == relative_rank(Us, ksq) + 1 ? BlockedByKing  :
>                   rkUs   == RANK_1                                          ? Unopposed :
>                   rkThem == rkUs + 1                                        ? BlockedByPawn  : Unblocked]
>                  [std::min(f, FILE_H - f)][rkThem];
275c279
<   minKingPawnDistance[Us] = 0;
---
>   int minKingPawnDistance = 0;
279,282c283
<       while (!(DistanceRingsBB[ksq][minKingPawnDistance[Us]++] & pawns)) {}
< 
<   if (relative_rank(Us, ksq) > RANK_4)
<       return make_score(0, -16 * minKingPawnDistance[Us]);
---
>       while (!(DistanceRingBB[ksq][minKingPawnDistance++] & pawns)) {}
293c294
<   return make_score(bonus, -16 * minKingPawnDistance[Us]);
---
>   return make_score(bonus, -16 * minKingPawnDistance);
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
35c36
<   Score pawns_value() const { return value; }
---
>   Score pawns_score() const { return score; }
37a39,41
>   Bitboard pawn_attacks_span(Color c) const { return pawnAttacksSpan[c]; }
>   int pawn_asymmetry() const { return asymmetry; }
>   int open_files() const { return openFiles; }
47,50d50
<   int pawn_span(Color c) const {
<     return pawnSpan[c];
<   }
< 
56c56
<   Score king_safety(const Position& pos, Square ksq)  {
---
>   Score king_safety(const Position& pos, Square ksq) {
68c68
<   Score value;
---
>   Score score;
70a71
>   Bitboard pawnAttacksSpan[COLOR_NB];
73d73
<   int minKingPawnDistance[COLOR_NB];
76d75
<   int pawnSpan[COLOR_NB];
77a77,78
>   int asymmetry;
>   int openFiles;
83c84
< Entry* probe(const Position& pos, Table& entries);
---
> Entry* probe(const Position& pos);
****************************************************************
movepick
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
11d11
< 
29,35c29,34
<     MAIN_SEARCH, CAPTURES_S1, KILLERS_S1, QUIETS_1_S1, QUIETS_2_S1, BAD_CAPTURES_S1,
<     EVASION,     EVASIONS_S2,
<     QSEARCH_0,   CAPTURES_S3, QUIET_CHECKS_S3,
<     QSEARCH_1,   CAPTURES_S4,
<     PROBCUT,     CAPTURES_S5,
<     RECAPTURE,   CAPTURES_S6,
<     STOP
---
>     MAIN_SEARCH, CAPTURES_INIT, GOOD_CAPTURES, KILLERS, COUNTERMOVE, QUIET_INIT, QUIET, BAD_CAPTURES,
>     EVASION, EVASIONS_INIT, ALL_EVASIONS,
>     PROBCUT, PROBCUT_INIT, PROBCUT_CAPTURES,
>     QSEARCH_WITH_CHECKS, QCAPTURES_1_INIT, QCAPTURES_1, QCHECKS,
>     QSEARCH_NO_CHECKS, QCAPTURES_2_INIT, QCAPTURES_2,
>     QSEARCH_RECAPTURES, QRECAPTURES
38c37
<   // Our insertion sort, which is guaranteed (and also needed) to be stable
---
>   // Our insertion sort, which is guaranteed to be stable, as it should be
52,59c51,54
<   // Unary predicate used by std::partition to split positive values from remaining
<   // ones so as to sort the two sets separately, with the second sort delayed.
<   inline bool has_positive_value(const ExtMove& move) { return move.value > 0; }
< 
<   // Picks the best move in the range (begin, end) and moves it to the front.
<   // It's faster than sorting all the moves in advance when there are few
<   // moves e.g. possible captures.
<   inline ExtMove* pick_best(ExtMove* begin, ExtMove* end)
---
>   // pick_best() finds the best move in the range (begin, end) and moves it to
>   // the front. It's faster than sorting all the moves in advance when there
>   // are few moves, e.g., the possible captures.
>   Move pick_best(ExtMove* begin, ExtMove* end)
62c57
<       return begin;
---
>       return *begin;
63a59
> 
70c66
< /// search captures, promotions and some checks) and how important good move
---
> /// search captures, promotions, and some checks) and how important good move
73,74c69,70
< MovePicker::MovePicker(const Position& p, Move ttm, Depth d, const HistoryStats& h,
<                        Move* cm, Move* fm, Search::Stack* s) : pos(p), history(h), depth(d) {
---
> MovePicker::MovePicker(const Position& p, Move ttm, Depth d, Search::Stack* s)
>            : pos(p), ss(s), depth(d) {
78,85c74,75
<   cur = end = moves;
<   endBadCaptures = moves + MAX_MOVES - 1;
<   countermoves = cm;
<   followupmoves = fm;
<   ss = s;
< 
<   if (pos.checkers())
<       stage = EVASION;
---
>   Square prevSq = to_sq((ss-1)->currentMove);
>   countermove = pos.this_thread()->counterMoves[pos.piece_on(prevSq)][prevSq];
87,91c77,79
<   else
<       stage = MAIN_SEARCH;
< 
<   ttMove = (ttm && pos.pseudo_legal(ttm) ? ttm : MOVE_NONE);
<   end += (ttMove != MOVE_NONE);
---
>   stage = pos.checkers() ? EVASION : MAIN_SEARCH;
>   ttMove = ttm && pos.pseudo_legal(ttm) ? ttm : MOVE_NONE;
>   stage += (ttMove == MOVE_NONE);
94,95c82,83
< MovePicker::MovePicker(const Position& p, Move ttm, Depth d, const HistoryStats& h,
<                        Square s) : pos(p), history(h), cur(moves), end(moves) {
---
> MovePicker::MovePicker(const Position& p, Move ttm, Depth d, Square s)
>            : pos(p) {
103c91
<       stage = QSEARCH_0;
---
>       stage = QSEARCH_WITH_CHECKS;
106c94
<       stage = QSEARCH_1;
---
>       stage = QSEARCH_NO_CHECKS;
110c98
<       stage = RECAPTURE;
---
>       stage = QSEARCH_RECAPTURES;
112c100
<       ttm = MOVE_NONE;
---
>       return;
115,116c103,104
<   ttMove = (ttm && pos.pseudo_legal(ttm) ? ttm : MOVE_NONE);
<   end += (ttMove != MOVE_NONE);
---
>   ttMove = ttm && pos.pseudo_legal(ttm) ? ttm : MOVE_NONE;
>   stage += (ttMove == MOVE_NONE);
119,120c107,108
< MovePicker::MovePicker(const Position& p, Move ttm, const HistoryStats& h, PieceType pt)
<                        : pos(p), history(h), cur(moves), end(moves) {
---
> MovePicker::MovePicker(const Position& p, Move ttm, Value th)
>            : pos(p), threshold(th) {
126,132c114,118
<   // In ProbCut we generate only captures that are better than the parent's
<   // captured piece.
<   captureThreshold = PieceValue[MG][pt];
<   ttMove = (ttm && pos.pseudo_legal(ttm) ? ttm : MOVE_NONE);
< 
<   if (ttMove && (!pos.capture(ttMove) || pos.see(ttMove) <= captureThreshold))
<       ttMove = MOVE_NONE;
---
>   // In ProbCut we generate captures with SEE higher than or equal to the given threshold
>   ttMove =   ttm
>           && pos.pseudo_legal(ttm)
>           && pos.capture(ttm)
>           && pos.see_ge(ttm, threshold)? ttm : MOVE_NONE;
134c120
<   end += (ttMove != MOVE_NONE);
---
>   stage += (ttMove == MOVE_NONE);
138c124
< /// score() assign a numerical value to each move in a move list. The moves with
---
> /// score() assigns a numerical value to each move in a move list. The moves with
142,151c128,132
<   // Winning and equal captures in the main search are ordered by MVV/LVA.
<   // Suprisingly, this appears to perform slightly better than SEE based
<   // move ordering. The reason is probably that in a position with a winning
<   // capture, capturing a more valuable (but sufficiently defended) piece
<   // first usually doesn't hurt. The opponent will have to recapture, and
<   // the hanging piece will still be hanging (except in the unusual cases
<   // where it is possible to recapture with the hanging piece). Exchanging
<   // big pieces before capturing a hanging piece probably helps to reduce
<   // the subtree size.
<   // In main search we want to push captures with negative SEE values to the
---
>   // Winning and equal captures in the main search are ordered by MVV, preferring
>   // captures near our home rank. Surprisingly, this appears to perform slightly
>   // better than SEE-based move ordering: exchanging big pieces before capturing
>   // a hanging piece probably helps to reduce the subtree size.
>   // In the main search we want to push captures with negative SEE values to the
153,168c134,137
<   // has been picked up in pick_move_from_list(). This way we save some SEE
<   // calls in case we get a cutoff.
<   Move m;
< 
<   for (ExtMove* it = moves; it != end; ++it)
<   {
<       m = it->move;
<       it->value =  PieceValue[MG][pos.piece_on(to_sq(m))]
<                  - Value(type_of(pos.moved_piece(m)));
< 
<       if (type_of(m) == ENPASSANT)
<           it->value += PieceValue[MG][PAWN];
< 
<       else if (type_of(m) == PROMOTION)
<           it->value += PieceValue[MG][promotion_type(m)] - PieceValue[MG][PAWN];
<   }
---
>   // has been picked up, saving some SEE calls in case we get a cutoff.
>   for (auto& m : *this)
>       m.value =  PieceValue[MG][pos.piece_on(to_sq(m))]
>                - Value(200 * relative_rank(pos.side_to_move(), to_sq(m)));
174c143
<   Move m;
---
>   const HistoryStats& history = pos.this_thread()->history;
176,180c145,155
<   for (ExtMove* it = moves; it != end; ++it)
<   {
<       m = it->move;
<       it->value = history[pos.moved_piece(m)][to_sq(m)];
<   }
---
>   const CounterMoveStats* cmh = (ss-1)->counterMoves;
>   const CounterMoveStats* fmh = (ss-2)->counterMoves;
>   const CounterMoveStats* fmh2 = (ss-4)->counterMoves;
> 
>   Color c = pos.side_to_move();
> 
>   for (auto& m : *this)
>       m.value =  (cmh  ?  (*cmh)[pos.moved_piece(m)][to_sq(m)] : VALUE_ZERO)
>                + (fmh  ?  (*fmh)[pos.moved_piece(m)][to_sq(m)] : VALUE_ZERO)
>                + (fmh2 ? (*fmh2)[pos.moved_piece(m)][to_sq(m)] : VALUE_ZERO)
>                + history.get(c, m);
185,199c160,167
<   // Try good captures ordered by MVV/LVA, then non-captures if destination square
<   // is not under attack, ordered by history value, then bad-captures and quiet
<   // moves with a negative SEE. This last group is ordered by the SEE value.
<   Move m;
<   Value see;
< 
<   for (ExtMove* it = moves; it != end; ++it)
<   {
<       m = it->move;
<       if ((see = pos.see_sign(m)) < VALUE_ZERO)
<           it->value = see - HistoryStats::Max; // At the bottom
< 
<       else if (pos.capture(m))
<           it->value =  PieceValue[MG][pos.piece_on(to_sq(m))]
<                      - Value(type_of(pos.moved_piece(m))) + HistoryStats::Max;
---
>   // Try captures ordered by MVV/LVA, then non-captures ordered by stats heuristics
>   const HistoryStats& history = pos.this_thread()->history;
>   Color c = pos.side_to_move();
> 
>   for (auto& m : *this)
>       if (pos.capture(m))
>           m.value =  PieceValue[MG][pos.piece_on(to_sq(m))]
>                    - Value(type_of(pos.moved_piece(m))) + HistoryStats::Max;
201,287c169
<           it->value = history[pos.moved_piece(m)][to_sq(m)];
<   }
< }
< 
< 
< /// generate_next_stage() generates, scores and sorts the next bunch of moves,
< /// when there are no more moves to try for the current stage.
< 
< void MovePicker::generate_next_stage() {
< 
<   cur = moves;
< 
<   switch (++stage) {
< 
<   case CAPTURES_S1: case CAPTURES_S3: case CAPTURES_S4: case CAPTURES_S5: case CAPTURES_S6:
<       end = generate<CAPTURES>(pos, moves);
<       score<CAPTURES>();
<       return;
< 
<   case KILLERS_S1:
<       cur = killers;
<       end = cur + 2;
< 
<       killers[0].move = ss->killers[0];
<       killers[1].move = ss->killers[1];
<       killers[2].move = killers[3].move = MOVE_NONE;
<       killers[4].move = killers[5].move = MOVE_NONE;
< 
<       // Please note that following code is racy and could yield to rare (less
<       // than 1 out of a million) duplicated entries in SMP case. This is harmless.
< 
<       // Be sure countermoves are different from killers
<       for (int i = 0; i < 2; ++i)
<           if (   countermoves[i] != (cur+0)->move
<               && countermoves[i] != (cur+1)->move)
<               (end++)->move = countermoves[i];
< 
<       // Be sure followupmoves are different from killers and countermoves
<       for (int i = 0; i < 2; ++i)
<           if (   followupmoves[i] != (cur+0)->move
<               && followupmoves[i] != (cur+1)->move
<               && followupmoves[i] != (cur+2)->move
<               && followupmoves[i] != (cur+3)->move)
<               (end++)->move = followupmoves[i];
<       return;
< 
<   case QUIETS_1_S1:
<       endQuiets = end = generate<QUIETS>(pos, moves);
<       score<QUIETS>();
<       end = std::partition(cur, end, has_positive_value);
<       insertion_sort(cur, end);
<       return;
< 
<   case QUIETS_2_S1:
<       cur = end;
<       end = endQuiets;
<       if (depth >= 3 * ONE_PLY)
<           insertion_sort(cur, end);
<       return;
< 
<   case BAD_CAPTURES_S1:
<       // Just pick them in reverse order to get MVV/LVA ordering
<       cur = moves + MAX_MOVES - 1;
<       end = endBadCaptures;
<       return;
< 
<   case EVASIONS_S2:
<       end = generate<EVASIONS>(pos, moves);
<       if (end > moves + 1)
<           score<EVASIONS>();
<       return;
< 
<   case QUIET_CHECKS_S3:
<       end = generate<QUIET_CHECKS>(pos, moves);
<       return;
< 
<   case EVASION: case QSEARCH_0: case QSEARCH_1: case PROBCUT: case RECAPTURE:
<       stage = STOP;
<       /* Fall through */
< 
<   case STOP:
<       end = cur + 1; // Avoid another next_phase() call
<       return;
< 
<   default:
<       assert(false);
<   }
---
>           m.value = history.get(c, m);
295,296d176
< template<>
< Move MovePicker::next_move<false>() {
298c178
<   Move move;
---
> Move MovePicker::next_move() {
300,303c180
<   while (true)
<   {
<       while (cur == end)
<           generate_next_stage();
---
>   Move move;
305c182
<       switch (stage) {
---
>   switch (stage) {
307,309c184,193
<       case MAIN_SEARCH: case EVASION: case QSEARCH_0: case QSEARCH_1: case PROBCUT:
<           ++cur;
<           return ttMove;
---
>   case MAIN_SEARCH: case EVASION: case QSEARCH_WITH_CHECKS:
>   case QSEARCH_NO_CHECKS: case PROBCUT:
>       ++stage;
>       return ttMove;
> 
>   case CAPTURES_INIT:
>       endBadCaptures = cur = moves;
>       endMoves = generate<CAPTURES>(pos, cur);
>       score<CAPTURES>();
>       ++stage;
311,312c195,198
<       case CAPTURES_S1:
<           move = pick_best(cur++, end)->move;
---
>   case GOOD_CAPTURES:
>       while (cur < endMoves)
>       {
>           move = pick_best(cur++, endMoves);
315c201
<               if (pos.see_sign(move) >= VALUE_ZERO)
---
>               if (pos.see_ge(move, VALUE_ZERO))
318,319c204,205
<               // Losing capture, move it to the tail of the array
<               (endBadCaptures--)->move = move;
---
>               // Losing capture, move it to the beginning of the array
>               *endBadCaptures++ = move;
321,330c207
<           break;
< 
<       case KILLERS_S1:
<           move = (cur++)->move;
<           if (    move != MOVE_NONE
<               &&  move != ttMove
<               &&  pos.pseudo_legal(move)
<               && !pos.capture(move))
<               return move;
<           break;
---
>       }
332,333c209,253
<       case QUIETS_1_S1: case QUIETS_2_S1:
<           move = (cur++)->move;
---
>       ++stage;
>       move = ss->killers[0];  // First killer move
>       if (    move != MOVE_NONE
>           &&  move != ttMove
>           &&  pos.pseudo_legal(move)
>           && !pos.capture(move))
>           return move;
> 
>   case KILLERS:
>       ++stage;
>       move = ss->killers[1]; // Second killer move
>       if (    move != MOVE_NONE
>           &&  move != ttMove
>           &&  pos.pseudo_legal(move)
>           && !pos.capture(move))
>           return move;
> 
>   case COUNTERMOVE:
>       ++stage;
>       move = countermove;
>       if (    move != MOVE_NONE
>           &&  move != ttMove
>           &&  move != ss->killers[0]
>           &&  move != ss->killers[1]
>           &&  pos.pseudo_legal(move)
>           && !pos.capture(move))
>           return move;
> 
>   case QUIET_INIT:
>       cur = endBadCaptures;
>       endMoves = generate<QUIETS>(pos, cur);
>       score<QUIETS>();
>       if (depth < 3 * ONE_PLY)
>       {
>           ExtMove* goodQuiet = std::partition(cur, endMoves, [](const ExtMove& m)
>                                              { return m.value > VALUE_ZERO; });
>           insertion_sort(cur, goodQuiet);
>       } else
>           insertion_sort(cur, endMoves);
>       ++stage;
> 
>   case QUIET:
>       while (cur < endMoves)
>       {
>           move = *cur++;
335,340c255,257
<               && move != killers[0].move
<               && move != killers[1].move
<               && move != killers[2].move
<               && move != killers[3].move
<               && move != killers[4].move
<               && move != killers[5].move)
---
>               && move != ss->killers[0]
>               && move != ss->killers[1]
>               && move != countermove)
342,345c259,261
<           break;
< 
<       case BAD_CAPTURES_S1:
<           return (cur--)->move;
---
>       }
>       ++stage;
>       cur = moves; // Point to beginning of bad captures
347,348c263,277
<       case EVASIONS_S2: case CAPTURES_S3: case CAPTURES_S4:
<           move = pick_best(cur++, end)->move;
---
>   case BAD_CAPTURES:
>       if (cur < endBadCaptures)
>           return *cur++;
>       break;
> 
>   case EVASIONS_INIT:
>       cur = moves;
>       endMoves = generate<EVASIONS>(pos, cur);
>       score<EVASIONS>();
>       ++stage;
> 
>   case ALL_EVASIONS:
>       while (cur < endMoves)
>       {
>           move = pick_best(cur++, endMoves);
351c280,281
<           break;
---
>       }
>       break;
353,357c283,287
<       case CAPTURES_S5:
<            move = pick_best(cur++, end)->move;
<            if (move != ttMove && pos.see(move) > captureThreshold)
<                return move;
<            break;
---
>   case PROBCUT_INIT:
>       cur = moves;
>       endMoves = generate<CAPTURES>(pos, cur);
>       score<CAPTURES>();
>       ++stage;
359,361c289,294
<       case CAPTURES_S6:
<           move = pick_best(cur++, end)->move;
<           if (to_sq(move) == recaptureSquare)
---
>   case PROBCUT_CAPTURES:
>       while (cur < endMoves)
>       {
>           move = pick_best(cur++, endMoves);
>           if (   move != ttMove
>               && pos.see_ge(move, threshold))
363c296,297
<           break;
---
>       }
>       break;
365,366c299,308
<       case QUIET_CHECKS_S3:
<           move = (cur++)->move;
---
>   case QCAPTURES_1_INIT: case QCAPTURES_2_INIT:
>       cur = moves;
>       endMoves = generate<CAPTURES>(pos, cur);
>       score<CAPTURES>();
>       ++stage;
> 
>   case QCAPTURES_1: case QCAPTURES_2:
>       while (cur < endMoves)
>       {
>           move = pick_best(cur++, endMoves);
368a311,312
>       }
>       if (stage == QCAPTURES_2)
369a314,325
>       cur = moves;
>       endMoves = generate<QUIET_CHECKS>(pos, cur);
>       ++stage;
> 
>   case QCHECKS:
>       while (cur < endMoves)
>       {
>           move = cur++->move;
>           if (move != ttMove)
>               return move;
>       }
>       break;
371,372c327,331
<       case STOP:
<           return MOVE_NONE;
---
>   case QSEARCH_RECAPTURES:
>       cur = moves;
>       endMoves = generate<CAPTURES>(pos, cur);
>       score<CAPTURES>();
>       ++stage;
374,375c333,338
<       default:
<           assert(false);
---
>   case QRECAPTURES:
>       while (cur < endMoves)
>       {
>           move = pick_best(cur++, endMoves);
>           if (to_sq(move) == recaptureSquare)
>               return move;
377,378c340
<   }
< }
---
>       break;
379a342,344
>   default:
>       assert(false);
>   }
381,385c346,347
< /// Version of next_move() to use at split point nodes where the move is grabbed
< /// from the split point's shared MovePicker object. This function is not thread
< /// safe so must be lock protected by the caller.
< template<>
< Move MovePicker::next_move<true>() { return ss->splitPoint->movePicker->next_move<false>(); }
---
>   return MOVE_NONE;
> }
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
28d28
< #include "search.h"
32,41c32,34
< /// The Stats struct stores moves statistics. According to the template parameter
< /// the class can store History, Gains and Countermoves. History records how often
< /// different moves have been successful or unsuccessful during the current search
< /// and is used for reduction and move ordering decisions. Gains records the move's
< /// best evaluation gain from one ply to the next and is used for pruning decisions.
< /// Countermoves store the move that refute a previous one. Entries are stored
< /// using only the moving piece and destination square, hence two moves with
< /// different origin but same destination and piece will be considered identical.
< template<bool Gain, typename T>
< struct Stats {
---
> /// HistoryStats records how often quiet moves have been successful or unsuccessful
> /// during the current search, and is used for reduction and move ordering decisions.
> struct HistoryStats {
43c36
<   static const Value Max = Value(250);
---
>   static const Value Max = Value(1 << 28);
45c38
<   const T* operator[](Piece pc) const { return table[pc]; }
---
>   Value get(Color c, Move m) const { return table[c][from_sq(m)][to_sq(m)]; }
46a40
>   void update(Color c, Move m, Value v) {
48,50c42
<   void update(Piece pc, Square to, Move m) {
< 
<     if (m == table[pc][to].first)
---
>     if (abs(int(v)) >= 324)
53,54c45,49
<     table[pc][to].second = table[pc][to].first;
<     table[pc][to].first = m;
---
>     Square from = from_sq(m);
>     Square to = to_sq(m);
> 
>     table[c][from][to] -= table[c][from][to] * abs(int(v)) / 324;
>     table[c][from][to] += int(v) * 32;
56a52,68
> private:
>   Value table[COLOR_NB][SQUARE_NB][SQUARE_NB];
> };
> 
> 
> /// A template struct, used to generate MoveStats and CounterMoveHistoryStats:
> /// MoveStats store the move that refute a previous one.
> /// CounterMoveHistoryStats is like HistoryStats, but with two consecutive moves.
> /// Entries are stored using only the moving piece and destination square, hence
> /// two moves with different origin but same destination and piece will be
> /// considered identical.
> template<typename T>
> struct Stats {
>   const T* operator[](Piece pc) const { return table[pc]; }
>   T* operator[](Piece pc) { return table[pc]; }
>   void clear() { std::memset(table, 0, sizeof(table)); }
>   void update(Piece pc, Square to, Move m) { table[pc][to] = m; }
59,60c71,72
<     if (Gain)
<         table[pc][to] = std::max(v, table[pc][to] - 1);
---
>     if (abs(int(v)) >= 324)
>         return;
62,63c74,75
<     else if (abs(table[pc][to] + v) < Max)
<         table[pc][to] +=  v;
---
>     table[pc][to] -= table[pc][to] * abs(int(v)) / 936;
>     table[pc][to] += int(v) * 32;
70,72c82,84
< typedef Stats< true, Value> GainsStats;
< typedef Stats<false, Value> HistoryStats;
< typedef Stats<false, std::pair<Move, Move> > MovesStats;
---
> typedef Stats<Move> MoveStats;
> typedef Stats<Value> CounterMoveStats;
> typedef Stats<CounterMoveStats> CounterMoveHistoryStats;
80a93
> namespace Search { struct Stack; }
83,85d95
< 
<   MovePicker& operator=(const MovePicker&); // Silence a warning under MSVC
< 
87,89c97,102
<   MovePicker(const Position&, Move, Depth, const HistoryStats&, Square);
<   MovePicker(const Position&, Move, const HistoryStats&, PieceType);
<   MovePicker(const Position&, Move, Depth, const HistoryStats&, Move*, Move*, Search::Stack*);
---
>   MovePicker(const MovePicker&) = delete;
>   MovePicker& operator=(const MovePicker&) = delete;
> 
>   MovePicker(const Position&, Move, Value);
>   MovePicker(const Position&, Move, Depth, Square);
>   MovePicker(const Position&, Move, Depth, Search::Stack*);
91c104
<   template<bool SpNode> Move next_move();
---
>   Move next_move();
95c108,109
<   void generate_next_stage();
---
>   ExtMove* begin() { return cur; }
>   ExtMove* end() { return endMoves; }
98,101c112,113
<   const HistoryStats& history;
<   Search::Stack* ss;
<   Move* countermoves;
<   Move* followupmoves;
---
>   const Search::Stack* ss;
>   Move countermove;
104d115
<   ExtMove killers[6];
106c117
<   Value captureThreshold;
---
>   Value threshold;
108c119
<   ExtMove *cur, *end, *endQuiets, *endBadCaptures;
---
>   ExtMove *cur, *endMoves, *endBadCaptures;
****************************************************************
movegen
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
28c29
<   ExtMove* generate_castling(const Position& pos, ExtMove* moveList, Color us, const CheckInfo* ci) {
---
>   ExtMove* generate_castling(const Position& pos, ExtMove* moveList, Color us) {
37c38
<     Square kfrom = pos.king_square(us);
---
>     Square kfrom = pos.square<KING>(us);
44,45c45,46
<     const Square K = Chess960 ? kto > kfrom ? DELTA_W : DELTA_E
<                               : KingSide    ? DELTA_W : DELTA_E;
---
>     const Square K = Chess960 ? kto > kfrom ? WEST : EAST
>                               : KingSide    ? WEST : EAST;
59c60
<     if (Checks && !pos.gives_check(m, *ci))
---
>     if (Checks && !pos.gives_check(m))
62,63c63
<     (moveList++)->move = m;
< 
---
>     *moveList++ = m;
68,70c68,69
<   template<GenType Type, Square Delta>
<   inline ExtMove* generate_promotions(ExtMove* moveList, Bitboard pawnsOn7,
<                                       Bitboard target, const CheckInfo* ci) {
---
>   template<GenType Type, Square D>
>   ExtMove* make_promotions(ExtMove* moveList, Square to, Square ksq) {
72c71,72
<     Bitboard b = shift_bb<Delta>(pawnsOn7) & target;
---
>     if (Type == CAPTURES || Type == EVASIONS || Type == NON_EVASIONS)
>         *moveList++ = make<PROMOTION>(to - D, to, QUEEN);
74c74
<     while (b)
---
>     if (Type == QUIETS || Type == EVASIONS || Type == NON_EVASIONS)
76,93c76,78
<         Square to = pop_lsb(&b);
< 
<         if (Type == CAPTURES || Type == EVASIONS || Type == NON_EVASIONS)
<             (moveList++)->move = make<PROMOTION>(to - Delta, to, QUEEN);
< 
<         if (Type == QUIETS || Type == EVASIONS || Type == NON_EVASIONS)
<         {
<             (moveList++)->move = make<PROMOTION>(to - Delta, to, ROOK);
<             (moveList++)->move = make<PROMOTION>(to - Delta, to, BISHOP);
<             (moveList++)->move = make<PROMOTION>(to - Delta, to, KNIGHT);
<         }
< 
<         // Knight promotion is the only promotion that can give a direct check
<         // that's not already included in the queen promotion.
<         if (Type == QUIET_CHECKS && (StepAttacksBB[W_KNIGHT][to] & ci->ksq))
<             (moveList++)->move = make<PROMOTION>(to - Delta, to, KNIGHT);
<         else
<             (void)ci; // Silence a warning under MSVC
---
>         *moveList++ = make<PROMOTION>(to - D, to, ROOK);
>         *moveList++ = make<PROMOTION>(to - D, to, BISHOP);
>         *moveList++ = make<PROMOTION>(to - D, to, KNIGHT);
95a81,87
>     // Knight promotion is the only promotion that can give a direct check
>     // that's not already included in the queen promotion.
>     if (Type == QUIET_CHECKS && (StepAttacksBB[W_KNIGHT][to] & ksq))
>         *moveList++ = make<PROMOTION>(to - D, to, KNIGHT);
>     else
>         (void)ksq; // Silence a warning under MSVC
> 
101,102c93
<   ExtMove* generate_pawn_moves(const Position& pos, ExtMove* moveList,
<                                Bitboard target, const CheckInfo* ci) {
---
>   ExtMove* generate_pawn_moves(const Position& pos, ExtMove* moveList, Bitboard target) {
106,112c97,103
<     const Color    Them     = (Us == WHITE ? BLACK    : WHITE);
<     const Bitboard TRank8BB = (Us == WHITE ? Rank8BB  : Rank1BB);
<     const Bitboard TRank7BB = (Us == WHITE ? Rank7BB  : Rank2BB);
<     const Bitboard TRank3BB = (Us == WHITE ? Rank3BB  : Rank6BB);
<     const Square   Up       = (Us == WHITE ? DELTA_N  : DELTA_S);
<     const Square   Right    = (Us == WHITE ? DELTA_NE : DELTA_SW);
<     const Square   Left     = (Us == WHITE ? DELTA_NW : DELTA_SE);
---
>     const Color    Them     = (Us == WHITE ? BLACK      : WHITE);
>     const Bitboard TRank8BB = (Us == WHITE ? Rank8BB    : Rank1BB);
>     const Bitboard TRank7BB = (Us == WHITE ? Rank7BB    : Rank2BB);
>     const Bitboard TRank3BB = (Us == WHITE ? Rank3BB    : Rank6BB);
>     const Square   Up       = (Us == WHITE ? NORTH      : SOUTH);
>     const Square   Right    = (Us == WHITE ? NORTH_EAST : SOUTH_WEST);
>     const Square   Left     = (Us == WHITE ? NORTH_WEST : SOUTH_EAST);
114c105
<     Bitboard b1, b2, dc1, dc2, emptySquares;
---
>     Bitboard emptySquares;
127,128c118,119
<         b1 = shift_bb<Up>(pawnsNotOn7)   & emptySquares;
<         b2 = shift_bb<Up>(b1 & TRank3BB) & emptySquares;
---
>         Bitboard b1 = shift<Up>(pawnsNotOn7)   & emptySquares;
>         Bitboard b2 = shift<Up>(b1 & TRank3BB) & emptySquares;
138,139c129,132
<             b1 &= pos.attacks_from<PAWN>(ci->ksq, Them);
<             b2 &= pos.attacks_from<PAWN>(ci->ksq, Them);
---
>             Square ksq = pos.square<KING>(Them);
> 
>             b1 &= pos.attacks_from<PAWN>(ksq, Them);
>             b2 &= pos.attacks_from<PAWN>(ksq, Them);
145c138,139
<             if (pawnsNotOn7 & ci->dcCandidates)
---
>             Bitboard dcCandidates = pos.discovered_check_candidates();
>             if (pawnsNotOn7 & dcCandidates)
147,148c141,142
<                 dc1 = shift_bb<Up>(pawnsNotOn7 & ci->dcCandidates) & emptySquares & ~file_bb(ci->ksq);
<                 dc2 = shift_bb<Up>(dc1 & TRank3BB) & emptySquares;
---
>                 Bitboard dc1 = shift<Up>(pawnsNotOn7 & dcCandidates) & emptySquares & ~file_bb(ksq);
>                 Bitboard dc2 = shift<Up>(dc1 & TRank3BB) & emptySquares;
158c152
<             (moveList++)->move = make_move(to - Up, to);
---
>             *moveList++ = make_move(to - Up, to);
164c158
<             (moveList++)->move = make_move(to - Up - Up, to);
---
>             *moveList++ = make_move(to - Up - Up, to);
177,179c171,184
<         moveList = generate_promotions<Type, Right>(moveList, pawnsOn7, enemies, ci);
<         moveList = generate_promotions<Type, Left >(moveList, pawnsOn7, enemies, ci);
<         moveList = generate_promotions<Type, Up>(moveList, pawnsOn7, emptySquares, ci);
---
>         Bitboard b1 = shift<Right>(pawnsOn7) & enemies;
>         Bitboard b2 = shift<Left >(pawnsOn7) & enemies;
>         Bitboard b3 = shift<Up   >(pawnsOn7) & emptySquares;
> 
>         Square ksq = pos.square<KING>(Them);
> 
>         while (b1)
>             moveList = make_promotions<Type, Right>(moveList, pop_lsb(&b1), ksq);
> 
>         while (b2)
>             moveList = make_promotions<Type, Left >(moveList, pop_lsb(&b2), ksq);
> 
>         while (b3)
>             moveList = make_promotions<Type, Up   >(moveList, pop_lsb(&b3), ksq);
185,186c190,191
<         b1 = shift_bb<Right>(pawnsNotOn7) & enemies;
<         b2 = shift_bb<Left >(pawnsNotOn7) & enemies;
---
>         Bitboard b1 = shift<Right>(pawnsNotOn7) & enemies;
>         Bitboard b2 = shift<Left >(pawnsNotOn7) & enemies;
191c196
<             (moveList++)->move = make_move(to - Right, to);
---
>             *moveList++ = make_move(to - Right, to);
197c202
<             (moveList++)->move = make_move(to - Left, to);
---
>             *moveList++ = make_move(to - Left, to);
215c220
<                 (moveList++)->move = make<ENPASSANT>(pop_lsb(&b1), pos.ep_square());
---
>                 *moveList++ = make<ENPASSANT>(pop_lsb(&b1), pos.ep_square());
223c228
<   template<PieceType Pt, bool Checks> FORCE_INLINE
---
>   template<PieceType Pt, bool Checks>
225c230
<                           Bitboard target, const CheckInfo* ci) {
---
>                           Bitboard target) {
229c234
<     const Square* pl = pos.list<Pt>(us);
---
>     const Square* pl = pos.squares<Pt>(us);
236c241
<                 && !(PseudoAttacks[Pt][from] & target & ci->checkSq[Pt]))
---
>                 && !(PseudoAttacks[Pt][from] & target & pos.check_squares(Pt)))
239c244
<             if (unlikely(ci->dcCandidates) && (ci->dcCandidates & from))
---
>             if (pos.discovered_check_candidates() & from)
246c251
<             b &= ci->checkSq[Pt];
---
>             b &= pos.check_squares(Pt);
249c254
<             (moveList++)->move = make_move(from, pop_lsb(&b));
---
>             *moveList++ = make_move(from, pop_lsb(&b));
256,258c261,262
<   template<Color Us, GenType Type> FORCE_INLINE
<   ExtMove* generate_all(const Position& pos, ExtMove* moveList, Bitboard target,
<                         const CheckInfo* ci = NULL) {
---
>   template<Color Us, GenType Type>
>   ExtMove* generate_all(const Position& pos, ExtMove* moveList, Bitboard target) {
262,266c266,270
<     moveList = generate_pawn_moves<Us, Type>(pos, moveList, target, ci);
<     moveList = generate_moves<KNIGHT, Checks>(pos, moveList, Us, target, ci);
<     moveList = generate_moves<BISHOP, Checks>(pos, moveList, Us, target, ci);
<     moveList = generate_moves<  ROOK, Checks>(pos, moveList, Us, target, ci);
<     moveList = generate_moves< QUEEN, Checks>(pos, moveList, Us, target, ci);
---
>     moveList = generate_pawn_moves<Us, Type>(pos, moveList, target);
>     moveList = generate_moves<KNIGHT, Checks>(pos, moveList, Us, target);
>     moveList = generate_moves<BISHOP, Checks>(pos, moveList, Us, target);
>     moveList = generate_moves<  ROOK, Checks>(pos, moveList, Us, target);
>     moveList = generate_moves< QUEEN, Checks>(pos, moveList, Us, target);
270c274
<         Square ksq = pos.king_square(Us);
---
>         Square ksq = pos.square<KING>(Us);
273c277
<             (moveList++)->move = make_move(ksq, pop_lsb(&b));
---
>             *moveList++ = make_move(ksq, pop_lsb(&b));
280,281c284,285
<             moveList = generate_castling<MakeCastling<Us,  KING_SIDE>::right, Checks, true>(pos, moveList, Us, ci);
<             moveList = generate_castling<MakeCastling<Us, QUEEN_SIDE>::right, Checks, true>(pos, moveList, Us, ci);
---
>             moveList = generate_castling<MakeCastling<Us,  KING_SIDE>::right, Checks, true>(pos, moveList, Us);
>             moveList = generate_castling<MakeCastling<Us, QUEEN_SIDE>::right, Checks, true>(pos, moveList, Us);
285,286c289,290
<             moveList = generate_castling<MakeCastling<Us,  KING_SIDE>::right, Checks, false>(pos, moveList, Us, ci);
<             moveList = generate_castling<MakeCastling<Us, QUEEN_SIDE>::right, Checks, false>(pos, moveList, Us, ci);
---
>             moveList = generate_castling<MakeCastling<Us,  KING_SIDE>::right, Checks, false>(pos, moveList, Us);
>             moveList = generate_castling<MakeCastling<Us, QUEEN_SIDE>::right, Checks, false>(pos, moveList, Us);
293d296
< 
314,316c317,319
<   Bitboard target = Type == CAPTURES     ?  pos.pieces(~us)
<                   : Type == QUIETS       ? ~pos.pieces()
<                   : Type == NON_EVASIONS ? ~pos.pieces(us) : 0;
---
>   Bitboard target =  Type == CAPTURES     ?  pos.pieces(~us)
>                    : Type == QUIETS       ? ~pos.pieces()
>                    : Type == NON_EVASIONS ? ~pos.pieces(us) : 0;
336,337c339
<   CheckInfo ci(pos);
<   Bitboard dc = ci.dcCandidates;
---
>   Bitboard dc = pos.discovered_check_candidates();
350c352
<          b &= ~PseudoAttacks[QUEEN][ci.ksq];
---
>          b &= ~PseudoAttacks[QUEEN][pos.square<KING>(~us)];
353c355
<          (moveList++)->move = make_move(from, pop_lsb(&b));
---
>          *moveList++ = make_move(from, pop_lsb(&b));
356,357c358,359
<   return us == WHITE ? generate_all<WHITE, QUIET_CHECKS>(pos, moveList, ~pos.pieces(), &ci)
<                      : generate_all<BLACK, QUIET_CHECKS>(pos, moveList, ~pos.pieces(), &ci);
---
>   return us == WHITE ? generate_all<WHITE, QUIET_CHECKS>(pos, moveList, ~pos.pieces())
>                      : generate_all<BLACK, QUIET_CHECKS>(pos, moveList, ~pos.pieces());
369c371
<   Square ksq = pos.king_square(us);
---
>   Square ksq = pos.square<KING>(us);
385c387
<       (moveList++)->move = make_move(ksq, pop_lsb(&b));
---
>       *moveList++ = make_move(ksq, pop_lsb(&b));
404d405
<   ExtMove *end, *cur = moveList;
406c407,408
<   Square ksq = pos.king_square(pos.side_to_move());
---
>   Square ksq = pos.square<KING>(pos.side_to_move());
>   ExtMove* cur = moveList;
408,413c410,415
<   end = pos.checkers() ? generate<EVASIONS>(pos, moveList)
<                        : generate<NON_EVASIONS>(pos, moveList);
<   while (cur != end)
<       if (   (pinned || from_sq(cur->move) == ksq || type_of(cur->move) == ENPASSANT)
<           && !pos.legal(cur->move, pinned))
<           cur->move = (--end)->move;
---
>   moveList = pos.checkers() ? generate<EVASIONS    >(pos, moveList)
>                             : generate<NON_EVASIONS>(pos, moveList);
>   while (cur != moveList)
>       if (   (pinned || from_sq(*cur) == ksq || type_of(*cur) == ENPASSANT)
>           && !pos.legal(*cur))
>           *cur = (--moveList)->move;
417c419
<   return end;
---
>   return moveList;
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
24a26,27
> class Position;
> 
34c37,47
< class Position;
---
> struct ExtMove {
>   Move move;
>   Value value;
> 
>   operator Move() const { return move; }
>   void operator=(Move m) { move = m; }
> };
> 
> inline bool operator<(const ExtMove& f, const ExtMove& s) {
>   return f.value < s.value;
> }
44,46c57,59
<   explicit MoveList(const Position& pos) : cur(moveList), last(generate<T>(pos, moveList)) { last->move = MOVE_NONE; }
<   void operator++() { ++cur; }
<   Move operator*() const { return cur->move; }
---
>   explicit MoveList(const Position& pos) : last(generate<T>(pos, moveList)) {}
>   const ExtMove* begin() const { return moveList; }
>   const ExtMove* end() const { return last; }
48,49c61,62
<   bool contains(Move m) const {
<     for (const ExtMove* it(moveList); it != last; ++it) if (it->move == m) return true;
---
>   bool contains(Move move) const {
>     for (const auto& m : *this) if (m == move) return true;
54,55c67
<   ExtMove moveList[MAX_MOVES];
<   ExtMove *cur, *last;
---
>   ExtMove moveList[MAX_MOVES], *last;
****************************************************************
misc
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
19a21,38
> #ifdef _WIN32
> #if _WIN32_WINNT < 0x0601
> #undef  _WIN32_WINNT
> #define _WIN32_WINNT 0x0601 // Force to include needed API prototypes
> #endif
> #include <windows.h>
> // The needed Windows API for processor groups could be missed from old Windows
> // versions, so instead of calling them directly (forcing the linker to resolve
> // the calls at compile time), try to load them at runtime. To do this we need
> // first to define the corresponding function pointers.
> extern "C" {
> typedef bool(*fun1_t)(LOGICAL_PROCESSOR_RELATIONSHIP,
>                       PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD);
> typedef bool(*fun2_t)(USHORT, PGROUP_AFFINITY);
> typedef bool(*fun3_t)(HANDLE, CONST GROUP_AFFINITY*, PGROUP_AFFINITY);
> }
> #endif
> 
23a43
> #include <vector>
36,38d55
< /// Debug counters
< int64_t hits[2], means[2];
< 
42c59
< /// usual i/o functionality, all without changing a single line of code!
---
> /// usual I/O functionality, all without changing a single line of code!
45c62
< struct Tie: public streambuf { // MSVC requires splitted streambuf for cin and cout
---
> struct Tie: public streambuf { // MSVC requires split streambuf for cin and cout
47c64
<   Tie(streambuf* b, ofstream* f) : buf(b), file(f) {}
---
>   Tie(streambuf* b, streambuf* l) : buf(b), logBuf(l) {}
49c66
<   int sync() { return file->rdbuf()->pubsync(), buf->pubsync(); }
---
>   int sync() { return logBuf->pubsync(), buf->pubsync(); }
54,55c71
<   streambuf* buf;
<   ofstream* file;
---
>   streambuf *buf, *logBuf;
59c75
<     static int last = '\n';
---
>     static int last = '\n'; // Single log file
62c78
<         file->rdbuf()->sputn(prefix, 3);
---
>         logBuf->sputn(prefix, 3);
64c80
<     return last = file->rdbuf()->sputc((char)c);
---
>     return last = logBuf->sputc((char)c);
70,71c86,87
<   Logger() : in(cin.rdbuf(), &file), out(cout.rdbuf(), &file) {}
<  ~Logger() { start(false); }
---
>   Logger() : in(cin.rdbuf(), file.rdbuf()), out(cout.rdbuf(), file.rdbuf()) {}
>  ~Logger() { start(""); }
77c93
<   static void start(bool b) {
---
>   static void start(const std::string& fname) {
81c97
<     if (b && !l.file.is_open())
---
>     if (!fname.empty() && !l.file.is_open())
83c99
<         l.file.open("io_log.txt", ifstream::out | ifstream::app);
---
>         l.file.open(fname, ifstream::out);
87c103
<     else if (!b && l.file.is_open())
---
>     else if (fname.empty() && l.file.is_open())
120c136
<      << "Tord Romstad, Marco Costalba and Joona Kiiski";
---
>      << "T. Romstad, M. Costalba, J. Kiiski, G. Linscott";
126a143
> static int64_t hits[2], means[2];
129c146
< void dbg_hit_on_c(bool c, bool b) { if (c) dbg_hit_on(b); }
---
> void dbg_hit_on(bool c, bool b) { if (c) dbg_hit_on(b); }
162,181c179
< void start_logger(bool b) { Logger::start(b); }
< 
< 
< /// timed_wait() waits for msec milliseconds. It is mainly a helper to wrap
< /// the conversion from milliseconds to struct timespec, as used by pthreads.
< 
< void timed_wait(WaitCondition& sleepCond, Lock& sleepLock, int msec) {
< 
< #ifdef _WIN32
<   int tm = msec;
< #else
<   timespec ts, *tm = &ts;
<   uint64_t ms = Time::now() + msec;
< 
<   ts.tv_sec = ms / 1000;
<   ts.tv_nsec = (ms % 1000) * 1000000LL;
< #endif
< 
<   cond_timedwait(sleepCond, sleepLock, tm);
< }
---
> void start_logger(const std::string& fname) { Logger::start(fname); }
189c187
< void prefetch(char*) {}
---
> void prefetch(void*) {}
193c191
< void prefetch(char* addr) {
---
> void prefetch(void* addr) {
202c200
<   _mm_prefetch(addr, _MM_HINT_T0);
---
>   _mm_prefetch((char*)addr, _MM_HINT_T0);
208a207,319
> 
> namespace WinProcGroup {
> 
> #ifndef _WIN32
> 
> void bindThisThread(size_t) {}
> 
> #else
> 
> /// get_group() retrieves logical processor information using Windows specific
> /// API and returns the best group id for the thread with index idx. Original
> /// code from Texel by Peter sterlund.
> 
> int get_group(size_t idx) {
> 
>   int threads = 0;
>   int nodes = 0;
>   int cores = 0;
>   DWORD returnLength = 0;
>   DWORD byteOffset = 0;
> 
>   // Early exit if the needed API is not available at runtime
>   HMODULE k32 = GetModuleHandle("Kernel32.dll");
>   auto fun1 = (fun1_t)GetProcAddress(k32, "GetLogicalProcessorInformationEx");
>   if (!fun1)
>       return -1;
> 
>   // First call to get returnLength. We expect it to fail due to null buffer
>   if (fun1(RelationAll, nullptr, &returnLength))
>       return -1;
> 
>   // Once we know returnLength, allocate the buffer
>   SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *buffer, *ptr;
>   ptr = buffer = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)malloc(returnLength);
> 
>   // Second call, now we expect to succeed
>   if (!fun1(RelationAll, buffer, &returnLength))
>   {
>       free(buffer);
>       return -1;
>   }
> 
>   while (ptr->Size > 0 && byteOffset + ptr->Size <= returnLength)
>   {
>       if (ptr->Relationship == RelationNumaNode)
>           nodes++;
> 
>       else if (ptr->Relationship == RelationProcessorCore)
>       {
>           cores++;
>           threads += (ptr->Processor.Flags == LTP_PC_SMT) ? 2 : 1;
>       }
> 
>       byteOffset += ptr->Size;
>       ptr = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)(((char*)ptr) + ptr->Size);
>   }
> 
>   free(buffer);
> 
>   std::vector<int> groups;
> 
>   // Run as many threads as possible on the same node until core limit is
>   // reached, then move on filling the next node.
>   for (int n = 0; n < nodes; n++)
>       for (int i = 0; i < cores / nodes; i++)
>           groups.push_back(n);
> 
>   // In case a core has more than one logical processor (we assume 2) and we
>   // have still threads to allocate, then spread them evenly across available
>   // nodes.
>   for (int t = 0; t < threads - cores; t++)
>       groups.push_back(t % nodes);
> 
>   // If we still have more threads than the total number of logical processors
>   // then return -1 and let the OS to decide what to do.
>   return idx < groups.size() ? groups[idx] : -1;
> }
> 
> 
> /// bindThisThread() set the group affinity of the current thread
> 
> void bindThisThread(size_t idx) {
> 
>   // If OS already scheduled us on a different group than 0 then don't overwrite
>   // the choice, eventually we are one of many one-threaded processes running on
>   // some Windows NUMA hardware, for instance in fishtest. To make it simple,
>   // just check if running threads are below a threshold, in this case all this
>   // NUMA machinery is not needed.
>   if (Threads.size() < 8)
>       return;
> 
>   // Use only local variables to be thread-safe
>   int group = get_group(idx);
> 
>   if (group == -1)
>       return;
> 
>   // Early exit if the needed API are not available at runtime
>   HMODULE k32 = GetModuleHandle("Kernel32.dll");
>   auto fun2 = (fun2_t)GetProcAddress(k32, "GetNumaNodeProcessorMaskEx");
>   auto fun3 = (fun3_t)GetProcAddress(k32, "SetThreadGroupAffinity");
> 
>   if (!fun2 || !fun3)
>       return;
> 
>   GROUP_AFFINITY affinity;
>   if (fun2(group, &affinity))
>       fun3(GetCurrentThread(), &affinity, nullptr);
> }
> 
> #endif
> 
> } // namespace WinProcGroup
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23a25
> #include <chrono>
31,33c33,34
< void timed_wait(WaitCondition&, Lock&, int);
< void prefetch(char* addr);
< void start_logger(bool b);
---
> void prefetch(void* addr);
> void start_logger(const std::string& fname);
36c37
< void dbg_hit_on_c(bool c, bool b);
---
> void dbg_hit_on(bool c, bool b);
39a41
> typedef std::chrono::milliseconds::rep TimePoint; // A value in milliseconds
41,43c43,45
< namespace Time {
<   typedef int64_t point;
<   inline point now() { return system_time_to_msec(); }
---
> inline TimePoint now() {
>   return std::chrono::duration_cast<std::chrono::milliseconds>
>         (std::chrono::steady_clock::now().time_since_epoch()).count();
46d47
< 
49d49
<   HashTable() : table(Size, Entry()) {}
53c53
<   std::vector<Entry> table;
---
>   std::vector<Entry> table = std::vector<Entry>(Size);
98a99,109
> 
> 
> /// Under Windows it is not possible for a process to run on more than one
> /// logical processor group. This usually means to be limited to use max 64
> /// cores. To overcome this, some special platform specific API should be
> /// called to set group affinity for each thread. Original code from Texel by
> /// Peter sterlund.
> 
> namespace WinProcGroup {
>   void bindThisThread(size_t idx);
> }
****************************************************************
material
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
20c21
< #include <algorithm>  // For std::min
---
> #include <algorithm> // For std::min
22c23
< #include <cstring>
---
> #include <cstring>   // For std::memset
24a26
> #include "thread.h"
30c32
<   // Polynomial material balance parameters
---
>   // Polynomial material imbalance parameters
32,35c34
<   //                      pair  pawn knight bishop rook queen
<   const int Linear[6] = { 1852, -162, -1122, -183,  249, -154 };
< 
<   const int QuadraticSameSide[][PIECE_TYPE_NB] = {
---
>   const int QuadraticOurs[][PIECE_TYPE_NB] = {
38,43c37,42
<     {   0                               }, // Bishop pair
<     {  39,    2                         }, // Pawn
<     {  35,  271,  -4                    }, // Knight      OUR PIECES
<     {   0,  105,   4,    0              }, // Bishop
<     { -27,   -2,  46,   100,  -141      }, // Rook
<     {-177,   25, 129,   142,  -137,   0 }  // Queen
---
>     {1667                               }, // Bishop pair
>     {  40,    2                         }, // Pawn
>     {  32,  255,  -3                    }, // Knight      OUR PIECES
>     {   0,  104,   4,    0              }, // Bishop
>     { -26,   -2,  47,   105,  -149      }, // Rook
>     {-185,   24, 122,   137,  -134,   0 }  // Queen
46c45
<   const int QuadraticOppositeSide[][PIECE_TYPE_NB] = {
---
>   const int QuadraticTheirs[][PIECE_TYPE_NB] = {
50,54c49,53
<     {  37,    0                         }, // Pawn
<     {  10,   62,   0                    }, // Knight      OUR PIECES
<     {  57,   64,  39,     0             }, // Bishop
<     {  50,   40,  23,   -22,    0       }, // Rook
<     {  98,  105, -39,   141,  274,    0 }  // Queen
---
>     {  36,    0                         }, // Pawn
>     {   9,   63,   0                    }, // Knight      OUR PIECES
>     {  59,   65,  42,     0             }, // Bishop
>     {  46,   39,  24,   -24,    0       }, // Rook
>     { 101,  100, -37,   141,  268,    0 }  // Queen
59c58
<   Endgame<KXK>   EvaluateKXK[]   = { Endgame<KXK>(WHITE),   Endgame<KXK>(BLACK) };
---
>   Endgame<KXK>    EvaluateKXK[] = { Endgame<KXK>(WHITE),    Endgame<KXK>(BLACK) };
66,85c65,82
<   // Helper templates used to detect a given material distribution
<   template<Color Us> bool is_KXK(const Position& pos) {
<     const Color Them = (Us == WHITE ? BLACK : WHITE);
<     return  !more_than_one(pos.pieces(Them))
<           && pos.non_pawn_material(Us) >= RookValueMg;
<   }
< 
<   template<Color Us> bool is_KBPsKs(const Position& pos) {
<     return   pos.non_pawn_material(Us) == BishopValueMg
<           && pos.count<BISHOP>(Us) == 1
<           && pos.count<PAWN  >(Us) >= 1;
<   }
< 
<   template<Color Us> bool is_KQKRPs(const Position& pos) {
<     const Color Them = (Us == WHITE ? BLACK : WHITE);
<     return  !pos.count<PAWN>(Us)
<           && pos.non_pawn_material(Us) == QueenValueMg
<           && pos.count<QUEEN>(Us)  == 1
<           && pos.count<ROOK>(Them) == 1
<           && pos.count<PAWN>(Them) >= 1;
---
>   // Helper used to detect a given material distribution
>   bool is_KXK(const Position& pos, Color us) {
>     return  !more_than_one(pos.pieces(~us))
>           && pos.non_pawn_material(us) >= RookValueMg;
>   }
> 
>   bool is_KBPsKs(const Position& pos, Color us) {
>     return   pos.non_pawn_material(us) == BishopValueMg
>           && pos.count<BISHOP>(us) == 1
>           && pos.count<PAWN  >(us) >= 1;
>   }
> 
>   bool is_KQKRPs(const Position& pos, Color us) {
>     return  !pos.count<PAWN>(us)
>           && pos.non_pawn_material(us) == QueenValueMg
>           && pos.count<QUEEN>(us)  == 1
>           && pos.count<ROOK>(~us) == 1
>           && pos.count<PAWN>(~us) >= 1;
90d86
< 
104c100
<         int v = Linear[pt1];
---
>         int v = 0;
107,108c103,104
<             v +=  QuadraticSameSide[pt1][pt2] * pieceCount[Us][pt2]
<                 + QuadraticOppositeSide[pt1][pt2] * pieceCount[Them][pt2];
---
>             v +=  QuadraticOurs[pt1][pt2] * pieceCount[Us][pt2]
>                 + QuadraticTheirs[pt1][pt2] * pieceCount[Them][pt2];
120,123c116,119
< /// Material::probe() takes a position object as input, looks up a MaterialEntry
< /// object, and returns a pointer to it. If the material configuration is not
< /// already present in the table, it is computed and stored there, so we don't
< /// have to recompute everything when the same material configuration occurs again.
---
> /// Material::probe() looks up the current position's material configuration in
> /// the material hash table. It returns a pointer to the Entry if the position
> /// is found. Otherwise a new Entry is computed and stored there, so we don't
> /// have to recompute all when the same material configuration occurs again.
125c121
< Entry* probe(const Position& pos, Table& entries, Endgames& endgames) {
---
> Entry* probe(const Position& pos) {
128c124
<   Entry* e = entries[key];
---
>   Entry* e = pos.this_thread()->materialTable[key];
130,132d125
<   // If e->key matches the position's material hash key, it means that we
<   // have analysed this material configuration before, and we can simply
<   // return the information we found the last time instead of recomputing it.
144c137
<   if (endgames.probe(key, e->evaluationFunction))
---
>   if ((e->evaluationFunction = pos.this_thread()->endgames.probe<Value>(key)) != nullptr)
147,157c140,145
<   if (is_KXK<WHITE>(pos))
<   {
<       e->evaluationFunction = &EvaluateKXK[WHITE];
<       return e;
<   }
< 
<   if (is_KXK<BLACK>(pos))
<   {
<       e->evaluationFunction = &EvaluateKXK[BLACK];
<       return e;
<   }
---
>   for (Color c = WHITE; c <= BLACK; ++c)
>       if (is_KXK(pos, c))
>       {
>           e->evaluationFunction = &EvaluateKXK[c];
>           return e;
>       }
159,163c147,148
<   // OK, we didn't find any special evaluation function for the current
<   // material configuration. Is there a suitable scaling function?
<   //
<   // We face problems when there are several conflicting applicable
<   // scaling functions and we need to decide which one to use.
---
>   // OK, we didn't find any special evaluation function for the current material
>   // configuration. Is there a suitable specialized scaling function?
166c151
<   if (endgames.probe(key, sf))
---
>   if ((sf = pos.this_thread()->endgames.probe<ScaleFactor>(key)) != nullptr)
168c153
<       e->scalingFunction[sf->color()] = sf;
---
>       e->scalingFunction[sf->strong_side()] = sf; // Only strong color assigned
172,182c157,163
<   // Generic scaling functions that refer to more than one material
<   // distribution. They should be probed after the specialized ones.
<   // Note that these ones don't return after setting the function.
<   if (is_KBPsKs<WHITE>(pos))
<       e->scalingFunction[WHITE] = &ScaleKBPsK[WHITE];
< 
<   if (is_KBPsKs<BLACK>(pos))
<       e->scalingFunction[BLACK] = &ScaleKBPsK[BLACK];
< 
<   if (is_KQKRPs<WHITE>(pos))
<       e->scalingFunction[WHITE] = &ScaleKQKRPs[WHITE];
---
>   // We didn't find any specialized scaling function, so fall back on generic
>   // ones that refer to more than one material distribution. Note that in this
>   // case we don't return after setting the function.
>   for (Color c = WHITE; c <= BLACK; ++c)
>   {
>     if (is_KBPsKs(pos, c))
>         e->scalingFunction[c] = &ScaleKBPsK[c];
184,185c165,167
<   else if (is_KQKRPs<BLACK>(pos))
<       e->scalingFunction[BLACK] = &ScaleKQKRPs[BLACK];
---
>     else if (is_KQKRPs(pos, c))
>         e->scalingFunction[c] = &ScaleKQKRPs[c];
>   }
190c172
<   if (npm_w + npm_b == VALUE_ZERO && pos.pieces(PAWN))
---
>   if (npm_w + npm_b == VALUE_ZERO && pos.pieces(PAWN)) // Only pawns on the board
194a177
> 
199a183
> 
211,213c195,197
<   // No pawns makes it difficult to win, even with a material advantage. This
<   // catches some trivial draws like KK, KBK and KNK and gives a very drawish
<   // scale factor for cases such as KRKBP and KmmKm (except for KBBKN).
---
>   // Zero or just one pawn makes it difficult to win, even with a small material
>   // advantage. This catches some trivial draws like KK, KBK and KNK and gives a
>   // drawish scale factor for cases such as KRKBP and KmmKm (except for KBBKN).
215c199,200
<       e->factor[WHITE] = uint8_t(npm_w < RookValueMg ? SCALE_FACTOR_DRAW : npm_b <= BishopValueMg ? 4 : 12);
---
>       e->factor[WHITE] = uint8_t(npm_w <  RookValueMg   ? SCALE_FACTOR_DRAW :
>                                  npm_b <= BishopValueMg ? 4 : 14);
218c203,204
<       e->factor[BLACK] = uint8_t(npm_b < RookValueMg ? SCALE_FACTOR_DRAW : npm_w <= BishopValueMg ? 4 : 12);
---
>       e->factor[BLACK] = uint8_t(npm_b <  RookValueMg   ? SCALE_FACTOR_DRAW :
>                                  npm_w <= BishopValueMg ? 4 : 14);
226,234d211
<   // Compute the space weight
<   if (npm_w + npm_b >= 2 * QueenValueMg + 4 * RookValueMg + 2 * KnightValueMg)
<   {
<       int minorPieceCount =  pos.count<KNIGHT>(WHITE) + pos.count<BISHOP>(WHITE)
<                            + pos.count<KNIGHT>(BLACK) + pos.count<BISHOP>(BLACK);
< 
<       e->spaceWeight = make_score(minorPieceCount * minorPieceCount, 0);
<   }
< 
238c215
<   const int pieceCount[COLOR_NB][PIECE_TYPE_NB] = {
---
>   const int PieceCount[COLOR_NB][PIECE_TYPE_NB] = {
244c221
<   e->value = (int16_t)((imbalance<WHITE>(pieceCount) - imbalance<BLACK>(pieceCount)) / 16);
---
>   e->value = int16_t((imbalance<WHITE>(PieceCount) - imbalance<BLACK>(PieceCount)) / 16);
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
31c32
< /// It contains a material balance evaluation, a function pointer to a special
---
> /// It contains a material imbalance evaluation, a function pointer to a special
33c34
< /// standard evaluation function will be used), and "scale factors".
---
> /// standard evaluation function will be used), and scale factors.
35,37c36,38
< /// The scale factors are used to scale the evaluation score up or down.
< /// For instance, in KRB vs KR endgames, the score is scaled down by a factor
< /// of 4, which will result in scores of absolute value less than one pawn.
---
> /// The scale factors are used to scale the evaluation score up or down. For
> /// instance, in KRB vs KR endgames, the score is scaled down by a factor of 4,
> /// which will result in scores of absolute value less than one pawn.
41,42c42
<   Score material_value() const { return make_score(value, value); }
<   Score space_weight() const { return spaceWeight; }
---
>   Score imbalance() const { return make_score(value, value); }
44c44
<   bool specialized_eval_exists() const { return evaluationFunction != NULL; }
---
>   bool specialized_eval_exists() const { return evaluationFunction != nullptr; }
47,52c47,51
<   // scale_factor takes a position and a color as input, and returns a scale factor
<   // for the given color. We have to provide the position in addition to the color,
<   // because the scale factor need not be a constant: It can also be a function
<   // which should be applied to the position. For instance, in KBP vs K endgames,
<   // a scaling function for draws with rook pawns and wrong-colored bishops.
< 
---
>   // scale_factor takes a position and a color as input and returns a scale factor
>   // for the given color. We have to provide the position in addition to the color
>   // because the scale factor may also be a function which should be applied to
>   // the position. For instance, in KBP vs K endgames, the scaling function looks
>   // for rook pawns and wrong-colored bishops.
54,56c53,55
< 
<     return !scalingFunction[c] || (*scalingFunction[c])(pos) == SCALE_FACTOR_NONE
<           ? ScaleFactor(factor[c]) : (*scalingFunction[c])(pos);
---
>     ScaleFactor sf = scalingFunction[c] ? (*scalingFunction[c])(pos)
>                                         :  SCALE_FACTOR_NONE;
>     return sf != SCALE_FACTOR_NONE ? sf : ScaleFactor(factor[c]);
63,64c62,63
<   EndgameBase<ScaleFactor>* scalingFunction[COLOR_NB];
<   Score spaceWeight;
---
>   EndgameBase<ScaleFactor>* scalingFunction[COLOR_NB]; // Could be one for each
>                                                        // side (e.g. KPKP, KBPsKs)
70c69
< Entry* probe(const Position& pos, Table& entries, Endgames& endgames);
---
> Entry* probe(const Position& pos);
****************************************************************
evaluate
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
21a23
> #include <cstring>   // For std::memset
25c27
< #include "bitcount.h"
---
> #include "bitboard.h"
29d30
< #include "thread.h"
32a34,71
>   namespace Trace {
> 
>     enum Term { // The first 8 entries are for PieceType
>       MATERIAL = 8, IMBALANCE, MOBILITY, THREAT, PASSED, SPACE, TOTAL, TERM_NB
>     };
> 
>     double scores[TERM_NB][COLOR_NB][PHASE_NB];
> 
>     double to_cp(Value v) { return double(v) / PawnValueEg; }
> 
>     void add(int idx, Color c, Score s) {
>       scores[idx][c][MG] = to_cp(mg_value(s));
>       scores[idx][c][EG] = to_cp(eg_value(s));
>     }
> 
>     void add(int idx, Score w, Score b = SCORE_ZERO) {
>       add(idx, WHITE, w); add(idx, BLACK, b);
>     }
> 
>     std::ostream& operator<<(std::ostream& os, Term t) {
> 
>       if (t == MATERIAL || t == IMBALANCE || t == Term(PAWN) || t == TOTAL)
>           os << "  ---   --- |   ---   --- | ";
>       else
>           os << std::setw(5) << scores[t][WHITE][MG] << " "
>              << std::setw(5) << scores[t][WHITE][EG] << " | "
>              << std::setw(5) << scores[t][BLACK][MG] << " "
>              << std::setw(5) << scores[t][BLACK][EG] << " | ";
> 
>       os << std::setw(5) << scores[t][WHITE][MG] - scores[t][BLACK][MG] << " "
>          << std::setw(5) << scores[t][WHITE][EG] - scores[t][BLACK][EG] << " \n";
> 
>       return os;
>     }
>   }
> 
>   using namespace Trace;
> 
37,39c76,78
<     // Pointers to material and pawn hash table entries
<     Material::Entry* mi;
<     Pawns::Entry* pi;
---
>     Material::Entry* me;
>     Pawns::Entry* pe;
>     Bitboard mobilityArea[COLOR_NB];
42,43c81
<     // attacked by a given color and piece type, attackedBy[color][ALL_PIECES]
<     // contains all squares attacked by the given color.
---
>     // attacked by a given color and piece type (can be also ALL_PIECES).
45a84,88
>     // attackedBy2[color] are the squares attacked by 2 pieces of a given color,
>     // possibly via x-ray or by one pawn and one piece. Diagonal x-ray through
>     // pawn or squares attacked by 2 pawns are not explicitly added.
>     Bitboard attackedBy2[COLOR_NB];
> 
58c101
<     // kingAttackersWeight[color] is the sum of the "weight" of the pieces of the
---
>     // kingAttackersWeight[color] is the sum of the "weights" of the pieces of the
64,68c107,111
<     // kingAdjacentZoneAttacksCount[color] is the number of attacks to squares
<     // directly adjacent to the king of the given color. Pieces which attack
<     // more than one square are counted multiple times. For instance, if black's
<     // king is on g8 and there's a white knight on g5, this knight adds
<     // 2 to kingAdjacentZoneAttacksCount[BLACK].
---
>     // kingAdjacentZoneAttacksCount[color] is the number of attacks by the given
>     // color to squares directly adjacent to the enemy king. Pieces which attack
>     // more than one square are counted multiple times. For instance, if there is
>     // a white knight on g5 and black's king is on g8, this white knight adds 2
>     // to kingAdjacentZoneAttacksCount[WHITE].
70,71d112
< 
<     Bitboard pinnedPieces[COLOR_NB];
74,78c115,116
<   namespace Tracing {
< 
<     enum Terms { // First 8 entries are for PieceType
<       MATERIAL = 8, IMBALANCE, MOBILITY, THREAT, PASSED, SPACE, TOTAL, TERMS_NB
<     };
---
>   #define V(v) Value(v)
>   #define S(mg, eg) make_score(mg, eg)
80,89c118,135
<     Score scores[COLOR_NB][TERMS_NB];
<     EvalInfo ei;
<     ScaleFactor sf;
< 
<     double to_cp(Value v);
<     void write(int idx, Color c, Score s);
<     void write(int idx, Score w, Score b = SCORE_ZERO);
<     void print(std::stringstream& ss, const char* name, int idx);
<     std::string do_trace(const Position& pos);
<   }
---
>   // MobilityBonus[PieceType][attacked] contains bonuses for middle and end game,
>   // indexed by piece type and number of attacked squares in the mobility area.
>   const Score MobilityBonus[][32] = {
>     {}, {},
>     { S(-75,-76), S(-56,-54), S( -9,-26), S( -2,-10), S(  6,  5), S( 15, 11), // Knights
>       S( 22, 26), S( 30, 28), S( 36, 29) },
>     { S(-48,-58), S(-21,-19), S( 16, -2), S( 26, 12), S( 37, 22), S( 51, 42), // Bishops
>       S( 54, 54), S( 63, 58), S( 65, 63), S( 71, 70), S( 79, 74), S( 81, 86),
>       S( 92, 90), S( 97, 94) },
>     { S(-56,-78), S(-25,-18), S(-11, 26), S( -5, 55), S( -4, 70), S( -1, 81), // Rooks
>       S(  8,109), S( 14,120), S( 21,128), S( 23,143), S( 31,154), S( 32,160),
>       S( 43,165), S( 49,168), S( 59,169) },
>     { S(-40,-35), S(-25,-12), S(  2,  7), S(  4, 19), S( 14, 37), S( 24, 55), // Queens
>       S( 25, 62), S( 40, 76), S( 43, 79), S( 47, 87), S( 54, 94), S( 56,102),
>       S( 60,111), S( 70,116), S( 72,118), S( 73,122), S( 75,128), S( 77,130),
>       S( 85,133), S( 94,136), S( 99,140), S(108,157), S(112,158), S(113,161),
>       S(118,174), S(119,177), S(123,191), S(128,199) }
>   };
91,94c137,143
<   // Evaluation weights, indexed by evaluation term
<   enum { Mobility, PawnStructure, PassedPawns, Space, KingSafety };
<   const struct Weight { int mg, eg; } Weights[] = {
<     {289, 344}, {233, 201}, {221, 273}, {46, 0}, {318, 0}
---
>   // Outpost[knight/bishop][supported by pawn] contains bonuses for minor
>   // pieces if they can reach an outpost square, bigger if that square is
>   // supported by a pawn. If the minor piece occupies an outpost square
>   // then score is doubled.
>   const Score Outpost[][2] = {
>     { S(22, 6), S(33, 9) }, // Knight
>     { S( 9, 2), S(14, 4) }  // Bishop
97,98c146,154
<   typedef Value V;
<   #define S(mg, eg) make_score(mg, eg)
---
>   // RookOnFile[semiopen/open] contains bonuses for each rook when there is no
>   // friendly pawn on the rook file.
>   const Score RookOnFile[2] = { S(20, 7), S(45, 20) };
> 
>   // ThreatBySafePawn[PieceType] contains bonuses according to which piece
>   // type is attacked by a pawn which is protected or is not attacked.
>   const Score ThreatBySafePawn[PIECE_TYPE_NB] = {
>     S(0, 0), S(0, 0), S(176, 139), S(131, 127), S(217, 218), S(203, 215)
>   };
100,117c156,160
<   // MobilityBonus[PieceType][attacked] contains bonuses for middle and end
<   // game, indexed by piece type and number of attacked squares not occupied by
<   // friendly pieces.
<   const Score MobilityBonus[][32] = {
<     {}, {},
<     { S(-65,-50), S(-42,-30), S(-9,-10), S( 3,  0), S(15, 10), S(27, 20), // Knights
<       S( 37, 28), S( 42, 31), S(44, 33) },
<     { S(-52,-47), S(-28,-23), S( 6,  1), S(20, 15), S(34, 29), S(48, 43), // Bishops
<       S( 60, 55), S( 68, 63), S(74, 68), S(77, 72), S(80, 75), S(82, 77),
<       S( 84, 79), S( 86, 81) },
<     { S(-47,-53), S(-31,-26), S(-5,  0), S( 1, 16), S( 7, 32), S(13, 48), // Rooks
<       S( 18, 64), S( 22, 80), S(26, 96), S(29,109), S(31,115), S(33,119),
<       S( 35,122), S( 36,123), S(37,124) },
<     { S(-42,-40), S(-28,-23), S(-5, -7), S( 0,  0), S( 6, 10), S(11, 19), // Queens
<       S( 13, 29), S( 18, 38), S(20, 40), S(21, 41), S(22, 41), S(22, 41),
<       S( 22, 41), S( 23, 41), S(24, 41), S(25, 41), S(25, 41), S(25, 41),
<       S( 25, 41), S( 25, 41), S(25, 41), S(25, 41), S(25, 41), S(25, 41),
<       S( 25, 41), S( 25, 41), S(25, 41), S(25, 41) }
---
>   // ThreatByMinor/ByRook[attacked PieceType] contains bonuses according to
>   // which piece type attacks which one. Attacks on lesser pieces which are
>   // pawn-defended are not considered.
>   const Score ThreatByMinor[PIECE_TYPE_NB] = {
>     S(0, 0), S(0, 33), S(45, 43), S(46, 47), S(72, 107), S(48, 118)
120,136c163,164
<   // Outpost[PieceType][Square] contains bonuses for knights and bishops outposts,
<   // indexed by piece type and square (from white's point of view).
<   const Value Outpost[][SQUARE_NB] = {
<   {// A     B     C     D     E     F     G     H
<     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0), // Knights
<     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0),
<     V(0), V(0), V(4), V(8), V(8), V(4), V(0), V(0),
<     V(0), V(4),V(17),V(26),V(26),V(17), V(4), V(0),
<     V(0), V(8),V(26),V(35),V(35),V(26), V(8), V(0),
<     V(0), V(4),V(17),V(17),V(17),V(17), V(4), V(0) },
<   {
<     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0), // Bishops
<     V(0), V(0), V(0), V(0), V(0), V(0), V(0), V(0),
<     V(0), V(0), V(5), V(5), V(5), V(5), V(0), V(0),
<     V(0), V(5),V(10),V(10),V(10),V(10), V(5), V(0),
<     V(0),V(10),V(21),V(21),V(21),V(21),V(10), V(0),
<     V(0), V(5), V(8), V(8), V(8), V(8), V(5), V(0) }
---
>   const Score ThreatByRook[PIECE_TYPE_NB] = {
>     S(0, 0), S(0, 25), S(40, 62), S(40, 59), S( 0, 34), S(35, 48)
139,145c167,175
<   // Threat[defended/weak][minor/major attacking][attacked PieceType] contains
<   // bonuses according to which piece type attacks which one.
<   const Score Threat[][2][PIECE_TYPE_NB] = {
<   { { S(0, 0), S( 0, 0), S(19, 37), S(24, 37), S(44, 97), S(35,106) },   // Defended Minor
<     { S(0, 0), S( 0, 0), S( 9, 14), S( 9, 14), S( 7, 14), S(24, 48) } }, // Defended Major
<   { { S(0, 0), S( 0,32), S(33, 41), S(31, 50), S(41,100), S(35,104) },   // Weak Minor
<     { S(0, 0), S( 0,27), S(26, 57), S(26, 57), S(0 , 43), S(23, 51) } }  // Weak Major
---
>   // ThreatByKing[on one/on many] contains bonuses for king attacks on
>   // pawns or pieces which are not pawn-defended.
>   const Score ThreatByKing[2] = { S(3, 62), S(9, 138) };
> 
>   // Passed[mg/eg][Rank] contains midgame and endgame bonuses for passed pawns.
>   // We don't use a Score because we process the two components independently.
>   const Value Passed[][RANK_NB] = {
>     { V(5), V( 5), V(31), V(73), V(166), V(252) },
>     { V(7), V(14), V(38), V(73), V(166), V(252) }
148,151c178,181
<   // ThreatenedByPawn[PieceType] contains a penalty according to which piece
<   // type is attacked by an enemy pawn.
<   const Score ThreatenedByPawn[] = {
<     S(0, 0), S(0, 0), S(87, 118), S(84, 122), S(114, 203), S(121, 217)
---
>   // PassedFile[File] contains a bonus according to the file of a passed pawn
>   const Score PassedFile[FILE_NB] = {
>     S(  9, 10), S( 2, 10), S( 1, -8), S(-20,-12),
>     S(-20,-12), S( 1, -8), S( 2, 10), S(  9, 10)
155,164c185,198
<   const Score KingOnOne        = S( 2, 58);
<   const Score KingOnMany       = S( 6,125);
<   const Score RookOnPawn       = S( 7, 27);
<   const Score RookOpenFile     = S(43, 21);
<   const Score RookSemiOpenFile = S(19, 10);
<   const Score BishopPawns      = S( 8, 12);
<   const Score MinorBehindPawn  = S(16,  0);
<   const Score TrappedRook      = S(92,  0);
<   const Score Unstoppable      = S( 0, 20);
<   const Score Hanging          = S(31, 26);
---
>   const Score MinorBehindPawn     = S(16,  0);
>   const Score BishopPawns         = S( 8, 12);
>   const Score RookOnPawn          = S( 8, 24);
>   const Score TrappedRook         = S(92,  0);
>   const Score WeakQueen           = S(50, 10);
>   const Score OtherCheck          = S(10, 10);
>   const Score CloseEnemies        = S( 7,  0);
>   const Score PawnlessFlank       = S(20, 80);
>   const Score LooseEnemies        = S( 0, 25);
>   const Score ThreatByHangingPawn = S(71, 61);
>   const Score ThreatByRank        = S(16,  3);
>   const Score Hanging             = S(48, 27);
>   const Score ThreatByPawnPush    = S(38, 22);
>   const Score HinderPassedPawn    = S( 7,  0);
171a206
>   #undef V
173,186d207
<   // SpaceMask[Color] contains the area of the board which is considered
<   // by the space evaluation. In the middlegame, each side is given a bonus
<   // based on how many squares inside this area are safe and available for
<   // friendly minor pieces.
<   const Bitboard SpaceMask[] = {
<     (FileCBB | FileDBB | FileEBB | FileFBB) & (Rank2BB | Rank3BB | Rank4BB),
<     (FileCBB | FileDBB | FileEBB | FileFBB) & (Rank7BB | Rank6BB | Rank5BB)
<   };
< 
<   // King danger constants and variables. The king danger scores are taken
<   // from KingDanger[]. Various little "meta-bonuses" measuring the strength
<   // of the enemy attack are added up into an integer, which is used as an
<   // index to KingDanger[].
<   //
188c209
<   const int KingAttackWeights[] = { 0, 0, 2, 2, 3, 5 };
---
>   const int KingAttackWeights[PIECE_TYPE_NB] = { 0, 0, 78, 56, 45, 11 };
190,205c211,215
<   // Bonuses for enemy's safe checks
<   const int QueenContactCheck = 24;
<   const int RookContactCheck  = 16;
<   const int QueenCheck        = 12;
<   const int RookCheck         = 8;
<   const int BishopCheck       = 2;
<   const int KnightCheck       = 3;
< 
<   // KingDanger[attackUnits] contains the actual king danger weighted
<   // scores, indexed by a calculated integer number.
<   Score KingDanger[128];
< 
<   // apply_weight() weighs score 'v' by weight 'w' trying to prevent overflow
<   Score apply_weight(Score v, const Weight& w) {
<     return make_score(mg_value(v) * w.mg / 256, eg_value(v) * w.eg / 256);
<   }
---
>   // Penalties for enemy's safe checks
>   const int QueenCheck        = 745;
>   const int RookCheck         = 688;
>   const int BishopCheck       = 588;
>   const int KnightCheck       = 924;
206a217,218
>   // Threshold for lazy evaluation
>   const Value LazyThreshold = Value(1500);
208,209c220,221
<   // init_eval_info() initializes king bitboards for given color adding
<   // pawn attacks. To be done at the beginning of the evaluation.
---
>   // eval_init() initializes king and attack bitboards for a given color
>   // adding pawn attacks. To be done at the beginning of the evaluation.
212c224
<   void init_eval_info(const Position& pos, EvalInfo& ei) {
---
>   void eval_init(const Position& pos, EvalInfo& ei) {
215,228c227,250
<     const Square Down = (Us == WHITE ? DELTA_S : DELTA_N);
< 
<     ei.pinnedPieces[Us] = pos.pinned_pieces(Us);
< 
<     Bitboard b = ei.attackedBy[Them][KING] = pos.attacks_from<KING>(pos.king_square(Them));
<     ei.attackedBy[Us][ALL_PIECES] = ei.attackedBy[Us][PAWN] = ei.pi->pawn_attacks(Us);
< 
<     // Init king safety tables only if we are going to use them
<     if (pos.non_pawn_material(Us) >= QueenValueMg)
<     {
<         ei.kingRing[Them] = b | shift_bb<Down>(b);
<         b &= ei.attackedBy[Us][PAWN];
<         ei.kingAttackersCount[Us] = b ? popcount<Max15>(b) : 0;
<         ei.kingAdjacentZoneAttacksCount[Us] = ei.kingAttackersWeight[Us] = 0;
---
>     const Square Up   = (Us == WHITE ? NORTH : SOUTH);
>     const Square Down = (Us == WHITE ? SOUTH : NORTH);
>     const Bitboard LowRanks = (Us == WHITE ? Rank2BB | Rank3BB: Rank7BB | Rank6BB);
> 
>     // Find our pawns on the first two ranks, and those which are blocked
>     Bitboard b = pos.pieces(Us, PAWN) & (shift<Down>(pos.pieces()) | LowRanks);
> 
>     // Squares occupied by those pawns, by our king, or controlled by enemy pawns
>     // are excluded from the mobility area.
>     ei.mobilityArea[Us] = ~(b | pos.square<KING>(Us) | ei.pe->pawn_attacks(Them));
> 
>     // Initialise the attack bitboards with the king and pawn information
>     b = ei.attackedBy[Us][KING] = pos.attacks_from<KING>(pos.square<KING>(Us));
>     ei.attackedBy[Us][PAWN] = ei.pe->pawn_attacks(Us);
> 
>     ei.attackedBy2[Us]            = b & ei.attackedBy[Us][PAWN];
>     ei.attackedBy[Us][ALL_PIECES] = b | ei.attackedBy[Us][PAWN];
> 
>     // Init our king safety tables only if we are going to use them
>     if (pos.non_pawn_material(Them) >= QueenValueMg)
>     {
>         ei.kingRing[Us] = b | shift<Up>(b);
>         ei.kingAttackersCount[Them] = popcount(b & ei.pe->pawn_attacks(Them));
>         ei.kingAdjacentZoneAttacksCount[Them] = ei.kingAttackersWeight[Them] = 0;
231c253
<         ei.kingRing[Them] = ei.kingAttackersCount[Us] = 0;
---
>         ei.kingRing[Us] = ei.kingAttackersCount[Them] = 0;
235c257,258
<   // evaluate_outpost() evaluates bishop and knight outpost squares
---
>   // evaluate_pieces() assigns bonuses and penalties to the pieces of a given
>   // color and type.
237,238c260,261
<   template<PieceType Pt, Color Us>
<   Score evaluate_outpost(const Position& pos, const EvalInfo& ei, Square s) {
---
>   template<bool DoTrace, Color Us = WHITE, PieceType Pt = KNIGHT>
>   Score evaluate_pieces(const Position& pos, EvalInfo& ei, Score* mobility) {
239a263
>     const PieceType NextPt = (Us == WHITE ? Pt : PieceType(Pt + 1));
240a265,267
>     const Bitboard OutpostRanks = (Us == WHITE ? Rank4BB | Rank5BB | Rank6BB
>                                                : Rank5BB | Rank4BB | Rank3BB);
>     const Square* pl = pos.squares<Pt>(Us);
242,267c269
<     assert (Pt == BISHOP || Pt == KNIGHT);
< 
<     // Initial bonus based on square
<     Value bonus = Outpost[Pt == BISHOP][relative_square(Us, s)];
< 
<     // Increase bonus if supported by pawn, especially if the opponent has
<     // no minor piece which can trade with the outpost piece.
<     if (bonus && (ei.attackedBy[Us][PAWN] & s))
<     {
<         if (   !pos.pieces(Them, KNIGHT)
<             && !(squares_of_color(s) & pos.pieces(Them, BISHOP)))
<             bonus += bonus + bonus / 2;
<         else
<             bonus += bonus / 2;
<     }
< 
<     return make_score(bonus * 2, bonus / 2);
<   }
< 
< 
<   // evaluate_pieces() assigns bonuses and penalties to the pieces of a given color
< 
<   template<PieceType Pt, Color Us, bool Trace>
<   Score evaluate_pieces(const Position& pos, EvalInfo& ei, Score* mobility, Bitboard* mobilityArea) {
< 
<     Bitboard b;
---
>     Bitboard b, bb;
271,274d272
<     const PieceType NextPt = (Us == WHITE ? Pt : PieceType(Pt + 1));
<     const Color Them = (Us == WHITE ? BLACK : WHITE);
<     const Square* pl = pos.list<Pt>(Us);
< 
284,285c282,283
<         if (ei.pinnedPieces[Us] & s)
<             b &= LineBB[pos.king_square(Us)][s];
---
>         if (pos.pinned_pieces(Us) & s)
>             b &= LineBB[pos.square<KING>(Us)][s];
286a285
>         ei.attackedBy2[Us] |= ei.attackedBy[Us][ALL_PIECES] & b;
293,295c292
<             Bitboard bb = b & ei.attackedBy[Them][KING];
<             if (bb)
<                 ei.kingAdjacentZoneAttacksCount[Us] += popcount<Max15>(bb);
---
>             ei.kingAdjacentZoneAttacksCount[Us] += popcount(b & ei.attackedBy[Them][KING]);
303,304c300
<         int mob = Pt != QUEEN ? popcount<Max15>(b & mobilityArea[Us])
<                               : popcount<Full >(b & mobilityArea[Us]);
---
>         int mob = popcount(b & ei.mobilityArea[Us]);
308,312d303
<         // Decrease score if we are attacked by an enemy pawn. The remaining part
<         // of threat evaluation must be done later when we have full attack info.
<         if (ei.attackedBy[Them][PAWN] & s)
<             score -= ThreatenedByPawn[Pt];
< 
315,321c306,315
<             // Penalty for bishop with same colored pawns
<             if (Pt == BISHOP)
<                 score -= BishopPawns * ei.pi->pawns_on_same_color_squares(Us, s);
< 
<             // Bishop and knight outpost square
<             if (!(pos.pieces(Them, PAWN) & pawn_attack_span(Us, s)))
<                 score += evaluate_outpost<Pt, Us>(pos, ei, s);
---
>             // Bonus for outpost squares
>             bb = OutpostRanks & ~ei.pe->pawn_attacks_span(Them);
>             if (bb & s)
>                 score += Outpost[Pt == BISHOP][!!(ei.attackedBy[Us][PAWN] & s)] * 2;
>             else
>             {
>                 bb &= b & ~pos.pieces(Us);
>                 if (bb)
>                    score += Outpost[Pt == BISHOP][!!(ei.attackedBy[Us][PAWN] & bb)];
>             }
323c317
<             // Bishop or knight behind a pawn
---
>             // Bonus when behind a pawn
326a321,338
> 
>             // Penalty for pawns on the same color square as the bishop
>             if (Pt == BISHOP)
>                 score -= BishopPawns * ei.pe->pawns_on_same_color_squares(Us, s);
> 
>             // An important Chess960 pattern: A cornered bishop blocked by a friendly
>             // pawn diagonally in front of it is a very serious problem, especially
>             // when that pawn is also blocked.
>             if (   Pt == BISHOP
>                 && pos.is_chess960()
>                 && (s == relative_square(Us, SQ_A1) || s == relative_square(Us, SQ_H1)))
>             {
>                 Square d = pawn_push(Us) + (file_of(s) == FILE_A ? EAST : WEST);
>                 if (pos.piece_on(s + d) == make_piece(Us, PAWN))
>                     score -= !pos.empty(s + d + pawn_push(Us))                ? TrappedBishopA1H1 * 4
>                             : pos.piece_on(s + d + d) == make_piece(Us, PAWN) ? TrappedBishopA1H1 * 2
>                                                                               : TrappedBishopA1H1;
>             }
331c343
<             // Rook piece attacking enemy pawns on the same rank/file
---
>             // Bonus for aligning with enemy pawns on the same rank/file
332a345,352
>                 score += RookOnPawn * popcount(pos.pieces(Them, PAWN) & PseudoAttacks[ROOK][s]);
> 
>             // Bonus when on an open or semi-open file
>             if (ei.pe->semiopen_file(Us, file_of(s)))
>                 score += RookOnFile[!!ei.pe->semiopen_file(Them, file_of(s))];
> 
>             // Penalty when trapped by the king, even more if the king cannot castle
>             else if (mob <= 3)
334,337c354
<                 Bitboard pawns = pos.pieces(Them, PAWN) & PseudoAttacks[ROOK][s];
<                 if (pawns)
<                     score += popcount<Max15>(pawns) * RookOnPawn;
<             }
---
>                 Square ksq = pos.square<KING>(Us);
339,353c356,359
<             // Give a bonus for a rook on a open or semi-open file
<             if (ei.pi->semiopen_file(Us, file_of(s)))
<                 score += ei.pi->semiopen_file(Them, file_of(s)) ? RookOpenFile : RookSemiOpenFile;
< 
<             if (mob > 3 || ei.pi->semiopen_file(Us, file_of(s)))
<                 continue;
< 
<             Square ksq = pos.king_square(Us);
< 
<             // Penalize rooks which are trapped by a king. Penalize more if the
<             // king has lost its castling capability.
<             if (   ((file_of(ksq) < FILE_E) == (file_of(s) < file_of(ksq)))
<                 && (rank_of(ksq) == rank_of(s) || relative_rank(Us, ksq) == RANK_1)
<                 && !ei.pi->semiopen_side(Us, file_of(ksq), file_of(s) < file_of(ksq)))
<                 score -= (TrappedRook - make_score(mob * 22, 0)) * (1 + !pos.can_castle(Us));
---
>                 if (   ((file_of(ksq) < FILE_E) == (file_of(s) < file_of(ksq)))
>                     && !ei.pe->semiopen_side(Us, file_of(ksq), file_of(s) < file_of(ksq)))
>                     score -= (TrappedRook - make_score(mob * 22, 0)) * (1 + !pos.can_castle(Us));
>             }
356,361c362
<         // An important Chess960 pattern: A cornered bishop blocked by a friendly
<         // pawn diagonally in front of it is a very serious problem, especially
<         // when that pawn is also blocked.
<         if (   Pt == BISHOP
<             && pos.is_chess960()
<             && (s == relative_square(Us, SQ_A1) || s == relative_square(Us, SQ_H1)))
---
>         if (Pt == QUEEN)
363,367c364,367
<             Square d = pawn_push(Us) + (file_of(s) == FILE_A ? DELTA_E : DELTA_W);
<             if (pos.piece_on(s + d) == make_piece(Us, PAWN))
<                 score -= !pos.empty(s + d + pawn_push(Us))                ? TrappedBishopA1H1 * 4
<                         : pos.piece_on(s + d + d) == make_piece(Us, PAWN) ? TrappedBishopA1H1 * 2
<                                                                           : TrappedBishopA1H1;
---
>             // Penalty if any relative pin or discovered attack against the queen
>             Bitboard pinners;
>             if (pos.slider_blockers(pos.pieces(Them, ROOK, BISHOP), s, pinners))
>                 score -= WeakQueen;
371,372c371,372
<     if (Trace)
<         Tracing::write(Pt, Us, score);
---
>     if (DoTrace)
>         Trace::add(Pt, Us, score);
374c374,375
<     return score - evaluate_pieces<NextPt, Them, Trace>(pos, ei, mobility, mobilityArea);
---
>     // Recursively call evaluate_pieces() of next piece type until KING is excluded
>     return score - evaluate_pieces<DoTrace, Them, NextPt>(pos, ei, mobility);
378c379
<   Score evaluate_pieces<KING, WHITE, false>(const Position&, EvalInfo&, Score*, Bitboard*) { return SCORE_ZERO; }
---
>   Score evaluate_pieces<false, WHITE, KING>(const Position&, EvalInfo&, Score*) { return SCORE_ZERO; }
380c381
<   Score evaluate_pieces<KING, WHITE,  true>(const Position&, EvalInfo&, Score*, Bitboard*) { return SCORE_ZERO; }
---
>   Score evaluate_pieces< true, WHITE, KING>(const Position&, EvalInfo&, Score*) { return SCORE_ZERO; }
385,386c386
<   template<Color Us, bool Trace>
<   Score evaluate_king(const Position& pos, const EvalInfo& ei) {
---
>   const Bitboard CenterFiles = FileCBB | FileDBB | FileEBB | FileFBB;
388c388,391
<     const Color Them = (Us == WHITE ? BLACK : WHITE);
---
>   const Bitboard KingFlank[FILE_NB] = {
>     CenterFiles >> 2, CenterFiles >> 2, CenterFiles >> 2, CenterFiles, CenterFiles,
>     CenterFiles << 2, CenterFiles << 2, CenterFiles << 2
>   };
390,392c393,403
<     Bitboard undefended, b, b1, b2, safe;
<     int attackUnits;
<     const Square ksq = pos.king_square(Us);
---
>   template<Color Us, bool DoTrace>
>   Score evaluate_king(const Position& pos, const EvalInfo& ei) {
> 
>     const Color Them    = (Us == WHITE ? BLACK : WHITE);
>     const Square Up     = (Us == WHITE ? NORTH : SOUTH);
>     const Bitboard Camp = (Us == WHITE ? ~Bitboard(0) ^ Rank6BB ^ Rank7BB ^ Rank8BB
>                                        : ~Bitboard(0) ^ Rank1BB ^ Rank2BB ^ Rank3BB);
> 
>     const Square ksq = pos.square<KING>(Us);
>     Bitboard undefended, b, b1, b2, safe, other;
>     int kingDanger;
395c406
<     Score score = ei.pi->king_safety<Us>(pos, ksq);
---
>     Score score = ei.pe->king_safety<Us>(pos, ksq);
400,406c411,418
<         // Find the attacked squares around the king which have no defenders
<         // apart from the king itself
<         undefended =  ei.attackedBy[Them][ALL_PIECES]
<                     & ei.attackedBy[Us][KING]
<                     & ~(  ei.attackedBy[Us][PAWN]   | ei.attackedBy[Us][KNIGHT]
<                         | ei.attackedBy[Us][BISHOP] | ei.attackedBy[Us][ROOK]
<                         | ei.attackedBy[Us][QUEEN]);
---
>         // Find the attacked squares which are defended only by our king...
>         undefended =   ei.attackedBy[Them][ALL_PIECES]
>                     &  ei.attackedBy[Us][KING]
>                     & ~ei.attackedBy2[Us];
> 
>         // ... and those which are not defended at all in the larger king ring
>         b =  ei.attackedBy[Them][ALL_PIECES] & ~ei.attackedBy[Us][ALL_PIECES]
>            & ei.kingRing[Us] & ~pos.pieces(Them);
408,409c420,421
<         // Initialize the 'attackUnits' variable, which is used later on as an
<         // index to the KingDanger[] array. The initial value is based on the
---
>         // Initialize the 'kingDanger' variable, which will be transformed
>         // later into a king danger score. The initial value is based on the
413,427c425,434
<         attackUnits =  std::min(20, (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)
<                      + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + popcount<Max15>(undefended))
<                      + 2 * (ei.pinnedPieces[Us] != 0)
<                      - mg_value(score) / 32
<                      - !pos.count<QUEEN>(Them) * 15;
< 
<         // Analyse the enemy's safe queen contact checks. Firstly, find the
<         // undefended squares around the king that are attacked by the enemy's
<         // queen...
<         b = undefended & ei.attackedBy[Them][QUEEN] & ~pos.pieces(Them);
<         if (b)
<         {
<             // ...and then remove squares not supported by another enemy piece
<             b &= (  ei.attackedBy[Them][PAWN]   | ei.attackedBy[Them][KNIGHT]
<                   | ei.attackedBy[Them][BISHOP] | ei.attackedBy[Them][ROOK]);
---
>         kingDanger =  std::min(807, ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them])
>                     + 101 * ei.kingAdjacentZoneAttacksCount[Them]
>                     + 235 * popcount(undefended)
>                     + 134 * (popcount(b) + !!pos.pinned_pieces(Us))
>                     - 717 * !pos.count<QUEEN>(Them)
>                     -   7 * mg_value(score) / 5 - 5;
> 
>         // Analyse the safe enemy's checks which are possible on next move
>         safe  = ~pos.pieces(Them);
>         safe &= ~ei.attackedBy[Us][ALL_PIECES] | (undefended & ei.attackedBy2[Them]);
429,431c436,437
<             if (b)
<                 attackUnits +=  QueenContactCheck * popcount<Max15>(b);
<         }
---
>         b1 = pos.attacks_from<ROOK  >(ksq);
>         b2 = pos.attacks_from<BISHOP>(ksq);
433,436c439,441
<         // Analyse the enemy's safe rook contact checks. Firstly, find the
<         // undefended squares around the king that are attacked by the enemy's
<         // rooks...
<         b = undefended & ei.attackedBy[Them][ROOK] & ~pos.pieces(Them);
---
>         // Enemy queen safe checks
>         if ((b1 | b2) & ei.attackedBy[Them][QUEEN] & safe)
>             kingDanger += QueenCheck;
438,439c443,447
<         // Consider only squares where the enemy's rook gives check
<         b &= PseudoAttacks[ROOK][ksq];
---
>         // For minors and rooks, also consider the square safe if attacked twice,
>         // and only defended by our queen.
>         safe |=  ei.attackedBy2[Them]
>                & ~(ei.attackedBy2[Us] | pos.pieces(Them))
>                & ei.attackedBy[Us][QUEEN];
441,445c449,453
<         if (b)
<         {
<             // ...and then remove squares not supported by another enemy piece
<             b &= (  ei.attackedBy[Them][PAWN]   | ei.attackedBy[Them][KNIGHT]
<                   | ei.attackedBy[Them][BISHOP] | ei.attackedBy[Them][QUEEN]);
---
>         // Some other potential checks are also analysed, even from squares
>         // currently occupied by the opponent own pieces, as long as the square
>         // is not attacked by our pawns, and is not occupied by a blocked pawn.
>         other = ~(   ei.attackedBy[Us][PAWN]
>                   | (pos.pieces(Them, PAWN) & shift<Up>(pos.pieces(PAWN))));
447,449c455,457
<             if (b)
<                 attackUnits +=  RookContactCheck * popcount<Max15>(b);
<         }
---
>         // Enemy rooks safe and other checks
>         if (b1 & ei.attackedBy[Them][ROOK] & safe)
>             kingDanger += RookCheck;
451,452c459,460
<         // Analyse the enemy's safe distance checks for sliders and knights
<         safe = ~(pos.pieces(Them) | ei.attackedBy[Us][ALL_PIECES]);
---
>         else if (b1 & ei.attackedBy[Them][ROOK] & other)
>             score -= OtherCheck;
454,455c462,464
<         b1 = pos.attacks_from<ROOK>(ksq) & safe;
<         b2 = pos.attacks_from<BISHOP>(ksq) & safe;
---
>         // Enemy bishops safe and other checks
>         if (b2 & ei.attackedBy[Them][BISHOP] & safe)
>             kingDanger += BishopCheck;
457,460c466,467
<         // Enemy queen safe checks
<         b = (b1 | b2) & ei.attackedBy[Them][QUEEN];
<         if (b)
<             attackUnits += QueenCheck * popcount<Max15>(b);
---
>         else if (b2 & ei.attackedBy[Them][BISHOP] & other)
>             score -= OtherCheck;
462,465c469,472
<         // Enemy rooks safe checks
<         b = b1 & ei.attackedBy[Them][ROOK];
<         if (b)
<             attackUnits += RookCheck * popcount<Max15>(b);
---
>         // Enemy knights safe and other checks
>         b = pos.attacks_from<KNIGHT>(ksq) & ei.attackedBy[Them][KNIGHT];
>         if (b & safe)
>             kingDanger += KnightCheck;
467,470c474,475
<         // Enemy bishops safe checks
<         b = b2 & ei.attackedBy[Them][BISHOP];
<         if (b)
<             attackUnits += BishopCheck * popcount<Max15>(b);
---
>         else if (b & other)
>             score -= OtherCheck;
472,475c477,480
<         // Enemy knights safe checks
<         b = pos.attacks_from<KNIGHT>(ksq) & ei.attackedBy[Them][KNIGHT] & safe;
<         if (b)
<             attackUnits += KnightCheck * popcount<Max15>(b);
---
>         // Transform the kingDanger units into a Score, and substract it from the evaluation
>         if (kingDanger > 0)
>             score -= make_score(std::min(kingDanger * kingDanger / 4096,  2 * int(BishopValueMg)), 0);
>     }
477,478c482,484
<         // To index KingDanger[] attackUnits must be in [0, 99] range
<         attackUnits = std::min(99, std::max(0, attackUnits));
---
>     // King tropism: firstly, find squares that opponent attacks in our king flank
>     File kf = file_of(ksq);
>     b = ei.attackedBy[Them][ALL_PIECES] & KingFlank[kf] & Camp;
480,483c486,498
<         // Finally, extract the king danger score from the KingDanger[]
<         // array and subtract the score from evaluation.
<         score -= KingDanger[attackUnits];
<     }
---
>     assert(((Us == WHITE ? b << 4 : b >> 4) & b) == 0);
>     assert(popcount(Us == WHITE ? b << 4 : b >> 4) == popcount(b));
> 
>     // Secondly, add the squares which are attacked twice in that flank and
>     // which are not defended by our pawns.
>     b =  (Us == WHITE ? b << 4 : b >> 4)
>        | (b & ei.attackedBy2[Them] & ~ei.attackedBy[Us][PAWN]);
> 
>     score -= CloseEnemies * popcount(b);
> 
>     // Penalty when our king is on a pawnless flank
>     if (!(pos.pieces(PAWN) & KingFlank[kf]))
>         score -= PawnlessFlank;
485,486c500,501
<     if (Trace)
<         Tracing::write(KING, Us, score);
---
>     if (DoTrace)
>         Trace::add(KING, Us, score);
492,493c507,508
<   // evaluate_threats() assigns bonuses according to the type of attacking piece
<   // and the type of attacked one.
---
>   // evaluate_threats() assigns bonuses according to the types of the attacking
>   // and the attacked pieces.
495c510
<   template<Color Us, bool Trace>
---
>   template<Color Us, bool DoTrace>
498,501c513,518
<     const Color Them = (Us == WHITE ? BLACK : WHITE);
< 
<     enum { Defended, Weak };
<     enum { Minor, Major };
---
>     const Color Them        = (Us == WHITE ? BLACK      : WHITE);
>     const Square Up         = (Us == WHITE ? NORTH      : SOUTH);
>     const Square Left       = (Us == WHITE ? NORTH_WEST : SOUTH_EAST);
>     const Square Right      = (Us == WHITE ? NORTH_EAST : SOUTH_WEST);
>     const Bitboard TRank2BB = (Us == WHITE ? Rank2BB    : Rank7BB);
>     const Bitboard TRank7BB = (Us == WHITE ? Rank7BB    : Rank2BB);
503c520
<     Bitboard b, weak, defended;
---
>     Bitboard b, weak, defended, safeThreats;
506,508c523,526
<     // Non-pawn enemies defended by a pawn
<     defended =  (pos.pieces(Them) ^ pos.pieces(Them, PAWN))
<               &  ei.attackedBy[Them][PAWN];
---
>     // Small bonus if the opponent has loose pawns or pieces
>     if (   (pos.pieces(Them) ^ pos.pieces(Them, QUEEN, KING))
>         & ~(ei.attackedBy[Us][ALL_PIECES] | ei.attackedBy[Them][ALL_PIECES]))
>         score += LooseEnemies;
510,511c528,531
<     // Add a bonus according to the kind of attacking pieces
<     if (defended)
---
>     // Non-pawn enemies attacked by a pawn
>     weak = (pos.pieces(Them) ^ pos.pieces(Them, PAWN)) & ei.attackedBy[Us][PAWN];
> 
>     if (weak)
513,515c533,534
<         b = defended & (ei.attackedBy[Us][KNIGHT] | ei.attackedBy[Us][BISHOP]);
<         while (b)
<             score += Threat[Defended][Minor][type_of(pos.piece_on(pop_lsb(&b)))];
---
>         b = pos.pieces(Us, PAWN) & ( ~ei.attackedBy[Them][ALL_PIECES]
>                                     | ei.attackedBy[Us][ALL_PIECES]);
517,519c536,542
<         b = defended & (ei.attackedBy[Us][ROOK]);
<         while (b)
<             score += Threat[Defended][Major][type_of(pos.piece_on(pop_lsb(&b)))];
---
>         safeThreats = (shift<Right>(b) | shift<Left>(b)) & weak;
> 
>         if (weak ^ safeThreats)
>             score += ThreatByHangingPawn;
> 
>         while (safeThreats)
>             score += ThreatBySafePawn[type_of(pos.piece_on(pop_lsb(&safeThreats)))];
521a545,547
>     // Non-pawn enemies defended by a pawn
>     defended = (pos.pieces(Them) ^ pos.pieces(Them, PAWN)) & ei.attackedBy[Them][PAWN];
> 
528c554
<     if (weak)
---
>     if (defended | weak)
530c556
<         b = weak & (ei.attackedBy[Us][KNIGHT] | ei.attackedBy[Us][BISHOP]);
---
>         b = (defended | weak) & (ei.attackedBy[Us][KNIGHT] | ei.attackedBy[Us][BISHOP]);
532c558,563
<             score += Threat[Weak][Minor][type_of(pos.piece_on(pop_lsb(&b)))];
---
>         {
>             Square s = pop_lsb(&b);
>             score += ThreatByMinor[type_of(pos.piece_on(s))];
>             if (type_of(pos.piece_on(s)) != PAWN)
>                 score += ThreatByRank * (int)relative_rank(Them, s);
>         }
534c565
<         b = weak & (ei.attackedBy[Us][ROOK] | ei.attackedBy[Us][QUEEN]);
---
>         b = (pos.pieces(Them, QUEEN) | weak) & ei.attackedBy[Us][ROOK];
536c567,572
<             score += Threat[Weak][Major][type_of(pos.piece_on(pop_lsb(&b)))];
---
>         {
>             Square s = pop_lsb(&b);
>             score += ThreatByRook[type_of(pos.piece_on(s))];
>             if (type_of(pos.piece_on(s)) != PAWN)
>                 score += ThreatByRank * (int)relative_rank(Them, s);
>         }
538,540c574
<         b = weak & ~ei.attackedBy[Them][ALL_PIECES];
<         if (b)
<             score += more_than_one(b) ? Hanging * popcount<Max15>(b) : Hanging;
---
>         score += Hanging * popcount(weak & ~ei.attackedBy[Them][ALL_PIECES]);
544c578
<             score += more_than_one(b) ? KingOnMany : KingOnOne;
---
>             score += ThreatByKing[more_than_one(b)];
547,548c581,596
<     if (Trace)
<         Tracing::write(Tracing::THREAT, Us, score);
---
>     // Bonus if some pawns can safely push and attack an enemy piece
>     b = pos.pieces(Us, PAWN) & ~TRank7BB;
>     b = shift<Up>(b | (shift<Up>(b & TRank2BB) & ~pos.pieces()));
> 
>     b &=  ~pos.pieces()
>         & ~ei.attackedBy[Them][PAWN]
>         & (ei.attackedBy[Us][ALL_PIECES] | ~ei.attackedBy[Them][ALL_PIECES]);
> 
>     b =  (shift<Left>(b) | shift<Right>(b))
>        &  pos.pieces(Them)
>        & ~ei.attackedBy[Us][PAWN];
> 
>     score += ThreatByPawnPush * popcount(b);
> 
>     if (DoTrace)
>         Trace::add(THREAT, Us, score);
554c602,603
<   // evaluate_passed_pawns() evaluates the passed pawns of the given color
---
>   // evaluate_passer_pawns() evaluates the passed pawns and candidate passed
>   // pawns of the given color.
556,557c605,606
<   template<Color Us, bool Trace>
<   Score evaluate_passed_pawns(const Position& pos, const EvalInfo& ei) {
---
>   template<Color Us, bool DoTrace>
>   Score evaluate_passer_pawns(const Position& pos, const EvalInfo& ei) {
561c610
<     Bitboard b, squaresToQueen, defendedSquares, unsafeSquares;
---
>     Bitboard b, bb, squaresToQueen, defendedSquares, unsafeSquares;
564c613
<     b = ei.pi->passed_pawns(Us);
---
>     b = ei.pe->passed_pawns(Us);
570c619,622
<         assert(pos.pawn_passed(Us, s));
---
>         assert(!(pos.pieces(PAWN) & forward_bb(Us, s)));
> 
>         bb = forward_bb(Us, s) & (ei.attackedBy[Them][ALL_PIECES] | pos.pieces(Them));
>         score -= HinderPassedPawn * popcount(bb);
575,576c627
<         // Base bonus based on rank
<         Value mbonus = Value(17 * rr), ebonus = Value(7 * (rr + r + 1));
---
>         Value mbonus = Passed[MG][r], ebonus = Passed[EG][r];
583,584c634,635
<             ebonus +=  distance(pos.king_square(Them), blockSq) * 5 * rr
<                      - distance(pos.king_square(Us  ), blockSq) * 2 * rr;
---
>             ebonus +=  distance(pos.square<KING>(Them), blockSq) * 5 * rr
>                      - distance(pos.square<KING>(Us  ), blockSq) * 2 * rr;
588c639
<                 ebonus -= distance(pos.king_square(Us), blockSq + pawn_push(Us)) * rr;
---
>                 ebonus -= distance(pos.square<KING>(Us), blockSq + pawn_push(Us)) * rr;
598c649
<                 Bitboard bb = forward_bb(Them, s) & pos.pieces(ROOK, QUEEN) & pos.attacks_from<ROOK>(s);
---
>                 bb = forward_bb(Them, s) & pos.pieces(ROOK, QUEEN) & pos.attacks_from<ROOK>(s);
608c659
<                 int k = !unsafeSquares ? 15 : !(unsafeSquares & blockSq) ? 9 : 0;
---
>                 int k = !unsafeSquares ? 18 : !(unsafeSquares & blockSq) ? 8 : 0;
610c661
<                 // If the path to queen is fully defended, assign a big bonus.
---
>                 // If the path to the queen is fully defended, assign a big bonus.
621c672
<                 mbonus += rr * 3 + r * 2 + 3, ebonus += rr + r * 2;
---
>                 mbonus += rr + r * 2, ebonus += rr + r * 2;
624,625c675,682
<         if (pos.count<PAWN>(Us) < pos.count<PAWN>(Them))
<             ebonus += ebonus / 4;
---
>         // Assign a small bonus when the opponent has no pieces left
>         if (!pos.non_pawn_material(Them))
>             ebonus += 20;
> 
>         // Scale down bonus for candidate passers which need more than one pawn
>         // push to become passed.
>         if (!pos.pawn_passed(Us, s + pawn_push(Us)))
>             mbonus /= 2, ebonus /= 2;
627c684
<         score += make_score(mbonus, ebonus);
---
>         score += make_score(mbonus, ebonus) + PassedFile[file_of(s)];
630,631c687,688
<     if (Trace)
<         Tracing::write(Tracing::PASSED, Us, apply_weight(score, Weights[PassedPawns]));
---
>     if (DoTrace)
>         Trace::add(PASSED, Us, score);
634,646c691
<     return apply_weight(score, Weights[PassedPawns]);
<   }
< 
< 
<   // evaluate_unstoppable_pawns() scores the most advanced passed pawn. In case
<   // both players have no pieces but pawns, this is somewhat related to the
<   // possibility that pawns are unstoppable.
< 
<   Score evaluate_unstoppable_pawns(Color us, const EvalInfo& ei) {
< 
<     Bitboard b = ei.pi->passed_pawns(us);
< 
<     return b ? Unstoppable * int(relative_rank(us, frontmost_sq(us, b))) : SCORE_ZERO;
---
>     return score;
654,655c699,700
<   // twice. Finally, the space bonus is scaled by a weight taken from the
<   // material hash table. The aim is to improve play on game opening.
---
>   // twice. Finally, the space bonus is multiplied by a weight. The aim is to
>   // improve play on game opening.
657c702
<   int evaluate_space(const Position& pos, const EvalInfo& ei) {
---
>   Score evaluate_space(const Position& pos, const EvalInfo& ei) {
659a705,707
>     const Bitboard SpaceMask =
>       Us == WHITE ? CenterFiles & (Rank2BB | Rank3BB | Rank4BB)
>                   : CenterFiles & (Rank7BB | Rank6BB | Rank5BB);
662c710
<     // SpaceMask[]. A square is unsafe if it is attacked by an enemy
---
>     // SpaceMask. A square is unsafe if it is attacked by an enemy
664c712
<     Bitboard safe =   SpaceMask[Us]
---
>     Bitboard safe =   SpaceMask
674c722
<     // Since SpaceMask[Us] is fully on our half of the board
---
>     // Since SpaceMask[Us] is fully on our half of the board...
677,678c725,730
<     // Count safe + (behind & safe) with a single popcount
<     return popcount<Full>((Us == WHITE ? safe << 32 : safe >> 32) | (behind & safe));
---
>     // ...count safe + (behind & safe) with a single popcount.
>     int bonus = popcount((Us == WHITE ? safe << 32 : safe >> 32) | (behind & safe));
>     bonus = std::min(16, bonus);
>     int weight = pos.count<ALL_PIECES>(Us) - 2 * ei.pe->open_files();
> 
>     return make_score(bonus * weight * weight / 18, 0);
682c734,737
<   // do_evaluate() is the evaluation entry point, called directly from evaluate()
---
>   // evaluate_initiative() computes the initiative correction value for the
>   // position, i.e., second order bonus/malus based on the known attacking/defending
>   // status of the players.
>   Score evaluate_initiative(const Position& pos, int asymmetry, Value eg) {
684,685c739,741
<   template<bool Trace>
<   Value do_evaluate(const Position& pos) {
---
>     int kingDistance =  distance<File>(pos.square<KING>(WHITE), pos.square<KING>(BLACK))
>                       - distance<Rank>(pos.square<KING>(WHITE), pos.square<KING>(BLACK));
>     int pawns = pos.count<PAWN>(WHITE) + pos.count<PAWN>(BLACK);
687c743,744
<     assert(!pos.checkers());
---
>     // Compute the initiative bonus for the attacking side
>     int initiative = 8 * (asymmetry + kingDistance - 15) + 12 * pawns;
689,742c746,749
<     EvalInfo ei;
<     Score score, mobility[2] = { SCORE_ZERO, SCORE_ZERO };
<     Thread* thisThread = pos.this_thread();
< 
<     // Initialize score by reading the incrementally updated scores included
<     // in the position object (material + piece square tables).
<     // Score is computed from the point of view of white.
<     score = pos.psq_score();
< 
<     // Probe the material hash table
<     ei.mi = Material::probe(pos, thisThread->materialTable, thisThread->endgames);
<     score += ei.mi->material_value();
< 
<     // If we have a specialized evaluation function for the current material
<     // configuration, call it and return.
<     if (ei.mi->specialized_eval_exists())
<         return ei.mi->evaluate(pos);
< 
<     // Probe the pawn hash table
<     ei.pi = Pawns::probe(pos, thisThread->pawnsTable);
<     score += apply_weight(ei.pi->pawns_value(), Weights[PawnStructure]);
< 
<     // Initialize attack and king safety bitboards
<     init_eval_info<WHITE>(pos, ei);
<     init_eval_info<BLACK>(pos, ei);
< 
<     ei.attackedBy[WHITE][ALL_PIECES] |= ei.attackedBy[WHITE][KING];
<     ei.attackedBy[BLACK][ALL_PIECES] |= ei.attackedBy[BLACK][KING];
< 
<     // Do not include in mobility squares protected by enemy pawns or occupied by our pawns or king
<     Bitboard mobilityArea[] = { ~(ei.attackedBy[BLACK][PAWN] | pos.pieces(WHITE, PAWN, KING)),
<                                 ~(ei.attackedBy[WHITE][PAWN] | pos.pieces(BLACK, PAWN, KING)) };
< 
<     // Evaluate pieces and mobility
<     score += evaluate_pieces<KNIGHT, WHITE, Trace>(pos, ei, mobility, mobilityArea);
<     score += apply_weight(mobility[WHITE] - mobility[BLACK], Weights[Mobility]);
< 
<     // Evaluate kings after all other pieces because we need complete attack
<     // information when computing the king safety evaluation.
<     score +=  evaluate_king<WHITE, Trace>(pos, ei)
<             - evaluate_king<BLACK, Trace>(pos, ei);
< 
<     // Evaluate tactical threats, we need full attack information including king
<     score +=  evaluate_threats<WHITE, Trace>(pos, ei)
<             - evaluate_threats<BLACK, Trace>(pos, ei);
< 
<     // Evaluate passed pawns, we need full attack information including king
<     score +=  evaluate_passed_pawns<WHITE, Trace>(pos, ei)
<             - evaluate_passed_pawns<BLACK, Trace>(pos, ei);
< 
<     // If both sides have only pawns, score for potential unstoppable pawns
<     if (!pos.non_pawn_material(WHITE) && !pos.non_pawn_material(BLACK))
<         score +=  evaluate_unstoppable_pawns(WHITE, ei)
<                 - evaluate_unstoppable_pawns(BLACK, ei);
---
>     // Now apply the bonus: note that we find the attacking side by extracting
>     // the sign of the endgame value, and that we carefully cap the bonus so
>     // that the endgame score will never be divided by more than two.
>     int value = ((eg > 0) - (eg < 0)) * std::max(initiative, -abs(eg / 2));
744,749c751,756
<     // Evaluate space for both sides, only in middlegame
<     if (ei.mi->space_weight())
<     {
<         int s = evaluate_space<WHITE>(pos, ei) - evaluate_space<BLACK>(pos, ei);
<         score += apply_weight(s * ei.mi->space_weight(), Weights[Space]);
<     }
---
>     return make_score(0, value);
>   }
> 
> 
>   // evaluate_scale_factor() computes the scale factor for the winning side
>   ScaleFactor evaluate_scale_factor(const Position& pos, const EvalInfo& ei, Value eg) {
751,753c758,759
<     // Scale winning side if position is more drawish than it appears
<     Color strongSide = eg_value(score) > VALUE_DRAW ? WHITE : BLACK;
<     ScaleFactor sf = ei.mi->scale_factor(pos, strongSide);
---
>     Color strongSide = eg > VALUE_DRAW ? WHITE : BLACK;
>     ScaleFactor sf = ei.me->scale_factor(pos, strongSide);
757c763
<     if (    ei.mi->game_phase() < PHASE_MIDGAME
---
>     if (    ei.me->game_phase() < PHASE_MIDGAME
763c769
<             // is almost a draw, in case of KBP vs KB is even more a draw.
---
>             // is almost a draw, in case of KBP vs KB, it is even more a draw.
766c772
<                 sf = more_than_one(pos.pieces(PAWN)) ? ScaleFactor(32) : ScaleFactor(8);
---
>                 sf = more_than_one(pos.pieces(PAWN)) ? ScaleFactor(31) : ScaleFactor(9);
771c777
<                  sf = ScaleFactor(50 * sf / SCALE_FACTOR_NORMAL);
---
>                 sf = ScaleFactor(46);
775,778c781,784
<         else if (    abs(eg_value(score)) <= BishopValueEg
<                  &&  ei.pi->pawn_span(strongSide) <= 1
<                  && !pos.pawn_passed(~strongSide, pos.king_square(~strongSide)))
<                  sf = ei.pi->pawn_span(strongSide) ? ScaleFactor(56) : ScaleFactor(38);
---
>         else if (    abs(eg) <= BishopValueEg
>                  &&  pos.count<PAWN>(strongSide) <= 2
>                  && !pos.pawn_passed(~strongSide, pos.square<KING>(~strongSide)))
>             sf = ScaleFactor(37 + 7 * pos.count<PAWN>(strongSide));
781,803c787
<     // Interpolate between a middlegame and a (scaled by 'sf') endgame score
<     Value v =  mg_value(score) * int(ei.mi->game_phase())
<              + eg_value(score) * int(PHASE_MIDGAME - ei.mi->game_phase()) * sf / SCALE_FACTOR_NORMAL;
< 
<     v /= int(PHASE_MIDGAME);
< 
<     // In case of tracing add all single evaluation contributions for both white and black
<     if (Trace)
<     {
<         Tracing::write(Tracing::MATERIAL, pos.psq_score());
<         Tracing::write(Tracing::IMBALANCE, ei.mi->material_value());
<         Tracing::write(PAWN, ei.pi->pawns_value());
<         Tracing::write(Tracing::MOBILITY, apply_weight(mobility[WHITE], Weights[Mobility])
<                                         , apply_weight(mobility[BLACK], Weights[Mobility]));
<         Score w = ei.mi->space_weight() * evaluate_space<WHITE>(pos, ei);
<         Score b = ei.mi->space_weight() * evaluate_space<BLACK>(pos, ei);
<         Tracing::write(Tracing::SPACE, apply_weight(w, Weights[Space]), apply_weight(b, Weights[Space]));
<         Tracing::write(Tracing::TOTAL, score);
<         Tracing::ei = ei;
<         Tracing::sf = sf;
<     }
< 
<     return (pos.side_to_move() == WHITE ? v : -v) + Eval::Tempo;
---
>     return sf;
805a790
> } // namespace
807,819d791
<   // Tracing function definitions
< 
<   double Tracing::to_cp(Value v) { return double(v) / PawnValueEg; }
< 
<   void Tracing::write(int idx, Color c, Score s) { scores[c][idx] = s; }
< 
<   void Tracing::write(int idx, Score w, Score b) {
< 
<     write(idx, WHITE, w);
<     write(idx, BLACK, b);
<   }
< 
<   void Tracing::print(std::stringstream& ss, const char* name, int idx) {
821,822c793,794
<     Score wScore = scores[WHITE][idx];
<     Score bScore = scores[BLACK][idx];
---
> /// evaluate() is the main evaluation function. It returns a static evaluation
> /// of the position from the point of view of the side to move.
824,839c796,797
<     switch (idx) {
<     case MATERIAL: case IMBALANCE: case PAWN: case TOTAL:
<         ss << std::setw(15) << name << " |   ---   --- |   ---   --- | "
<            << std::setw(5)  << to_cp(mg_value(wScore - bScore)) << " "
<            << std::setw(5)  << to_cp(eg_value(wScore - bScore)) << " \n";
<         break;
<     default:
<         ss << std::setw(15) << name << " | " << std::noshowpos
<            << std::setw(5)  << to_cp(mg_value(wScore)) << " "
<            << std::setw(5)  << to_cp(eg_value(wScore)) << " | "
<            << std::setw(5)  << to_cp(mg_value(bScore)) << " "
<            << std::setw(5)  << to_cp(eg_value(bScore)) << " | "
<            << std::setw(5)  << to_cp(mg_value(wScore - bScore)) << " "
<            << std::setw(5)  << to_cp(eg_value(wScore - bScore)) << " \n";
<     }
<   }
---
> template<bool DoTrace>
> Value Eval::evaluate(const Position& pos) {
841c799
<   std::string Tracing::do_trace(const Position& pos) {
---
>   assert(!pos.checkers());
843c801,803
<     std::memset(scores, 0, sizeof(scores));
---
>   Score mobility[COLOR_NB] = { SCORE_ZERO, SCORE_ZERO };
>   Value v;
>   EvalInfo ei;
845,846c805,806
<     Value v = do_evaluate<true>(pos);
<     v = pos.side_to_move() == WHITE ? v : -v; // White's point of view
---
>   // Probe the material hash table
>   ei.me = Material::probe(pos);
848,865c808,811
<     std::stringstream ss;
<     ss << std::showpoint << std::noshowpos << std::fixed << std::setprecision(2)
<        << "      Eval term |    White    |    Black    |    Total    \n"
<        << "                |   MG    EG  |   MG    EG  |   MG    EG  \n"
<        << "----------------+-------------+-------------+-------------\n";
< 
<     print(ss, "Material", MATERIAL);
<     print(ss, "Imbalance", IMBALANCE);
<     print(ss, "Pawns", PAWN);
<     print(ss, "Knights", KNIGHT);
<     print(ss, "Bishops", BISHOP);
<     print(ss, "Rooks", ROOK);
<     print(ss, "Queens", QUEEN);
<     print(ss, "Mobility", MOBILITY);
<     print(ss, "King safety", KING);
<     print(ss, "Threats", THREAT);
<     print(ss, "Passed pawns", PASSED);
<     print(ss, "Space", SPACE);
---
>   // If we have a specialized evaluation function for the current material
>   // configuration, call it and return.
>   if (ei.me->specialized_eval_exists())
>       return ei.me->evaluate(pos);
867,868c813,816
<     ss << "----------------+-------------+-------------+-------------\n";
<     print(ss, "Total", TOTAL);
---
>   // Initialize score by reading the incrementally updated scores included in
>   // the position object (material + piece square tables) and the material
>   // imbalance. Score is computed internally from the white point of view.
>   Score score = pos.psq_score() + ei.me->imbalance();
870c818,820
<     ss << "\nTotal Evaluation: " << to_cp(v) << " (white side)\n";
---
>   // Probe the pawn hash table
>   ei.pe = Pawns::probe(pos);
>   score += ei.pe->pawns_score();
872,873c822,825
<     return ss.str();
<   }
---
>   // Early exit if score is high
>   v = (mg_value(score) + eg_value(score)) / 2;
>   if (abs(v) > LazyThreshold)
>      return pos.side_to_move() == WHITE ? v : -v;
875c827,829
< } // namespace
---
>   // Initialize attack and king safety bitboards
>   eval_init<WHITE>(pos, ei);
>   eval_init<BLACK>(pos, ei);
876a831,833
>   // Evaluate all pieces but king and pawns
>   score += evaluate_pieces<DoTrace>(pos, ei, mobility);
>   score += mobility[WHITE] - mobility[BLACK];
878c835,838
< namespace Eval {
---
>   // Evaluate kings after all other pieces because we need full attack
>   // information when computing the king safety evaluation.
>   score +=  evaluate_king<WHITE, DoTrace>(pos, ei)
>           - evaluate_king<BLACK, DoTrace>(pos, ei);
880,881c840,842
<   /// evaluate() is the main evaluation function. It returns a static evaluation
<   /// of the position always from the point of view of the side to move.
---
>   // Evaluate tactical threats, we need full attack information including king
>   score +=  evaluate_threats<WHITE, DoTrace>(pos, ei)
>           - evaluate_threats<BLACK, DoTrace>(pos, ei);
883,885c844,846
<   Value evaluate(const Position& pos) {
<     return do_evaluate<false>(pos);
<   }
---
>   // Evaluate passed pawns, we need full attack information including king
>   score +=  evaluate_passer_pawns<WHITE, DoTrace>(pos, ei)
>           - evaluate_passer_pawns<BLACK, DoTrace>(pos, ei);
886a848,851
>   // Evaluate space for both sides, only during opening
>   if (pos.non_pawn_material(WHITE) + pos.non_pawn_material(BLACK) >= 12222)
>       score +=  evaluate_space<WHITE>(pos, ei)
>               - evaluate_space<BLACK>(pos, ei);
888,894c853,854
<   /// trace() is like evaluate(), but instead of returning a value, it returns
<   /// a string (suitable for outputting to stdout) that contains the detailed
<   /// descriptions and values of each evaluation term. It's mainly used for
<   /// debugging.
<   std::string trace(const Position& pos) {
<     return Tracing::do_trace(pos);
<   }
---
>   // Evaluate position potential for the winning side
>   score += evaluate_initiative(pos, ei.pe->pawn_asymmetry(), eg_value(score));
895a856,857
>   // Evaluate scale factor for the winning side
>   ScaleFactor sf = evaluate_scale_factor(pos, ei, eg_value(score));
897c859,861
<   /// init() computes evaluation weights.
---
>   // Interpolate between a middlegame and a (scaled by 'sf') endgame score
>   v =  mg_value(score) * int(ei.me->game_phase())
>      + eg_value(score) * int(PHASE_MIDGAME - ei.me->game_phase()) * sf / SCALE_FACTOR_NORMAL;
899c863
<   void init() {
---
>   v /= int(PHASE_MIDGAME);
901,902c865,915
<     const double MaxSlope = 30;
<     const double Peak = 1280;
---
>   // In case of tracing add all remaining individual evaluation terms
>   if (DoTrace)
>   {
>       Trace::add(MATERIAL, pos.psq_score());
>       Trace::add(IMBALANCE, ei.me->imbalance());
>       Trace::add(PAWN, ei.pe->pawns_score());
>       Trace::add(MOBILITY, mobility[WHITE], mobility[BLACK]);
>       if (pos.non_pawn_material(WHITE) + pos.non_pawn_material(BLACK) >= 12222)
>           Trace::add(SPACE, evaluate_space<WHITE>(pos, ei)
>                           , evaluate_space<BLACK>(pos, ei));
>       Trace::add(TOTAL, score);
>   }
> 
>   return (pos.side_to_move() == WHITE ? v : -v) + Eval::Tempo; // Side to move point of view
> }
> 
> // Explicit template instantiations
> template Value Eval::evaluate<true >(const Position&);
> template Value Eval::evaluate<false>(const Position&);
> 
> 
> /// trace() is like evaluate(), but instead of returning a value, it returns
> /// a string (suitable for outputting to stdout) that contains the detailed
> /// descriptions and values of each evaluation term. Useful for debugging.
> 
> std::string Eval::trace(const Position& pos) {
> 
>   std::memset(scores, 0, sizeof(scores));
> 
>   Value v = evaluate<true>(pos);
>   v = pos.side_to_move() == WHITE ? v : -v; // White's point of view
> 
>   std::stringstream ss;
>   ss << std::showpoint << std::noshowpos << std::fixed << std::setprecision(2)
>      << "      Eval term |    White    |    Black    |    Total    \n"
>      << "                |   MG    EG  |   MG    EG  |   MG    EG  \n"
>      << "----------------+-------------+-------------+-------------\n"
>      << "       Material | " << Term(MATERIAL)
>      << "      Imbalance | " << Term(IMBALANCE)
>      << "          Pawns | " << Term(PAWN)
>      << "        Knights | " << Term(KNIGHT)
>      << "         Bishop | " << Term(BISHOP)
>      << "          Rooks | " << Term(ROOK)
>      << "         Queens | " << Term(QUEEN)
>      << "       Mobility | " << Term(MOBILITY)
>      << "    King safety | " << Term(KING)
>      << "        Threats | " << Term(THREAT)
>      << "   Passed pawns | " << Term(PASSED)
>      << "          Space | " << Term(SPACE)
>      << "----------------+-------------+-------------+-------------\n"
>      << "          Total | " << Term(TOTAL);
904,909c917
<     for (int t = 0, i = 1; i < 100; ++i)
<     {
<         t = int(std::min(Peak, std::min(0.4 * i * i, t + MaxSlope)));
<         KingDanger[i] = apply_weight(make_score(t, 0), Weights[KingSafety]);
<     }
<   }
---
>   ss << "\nTotal Evaluation: " << to_cp(v) << " (white side)\n";
911c919,920
< } // namespace Eval
---
>   return ss.str();
> }
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
22a24,25
> #include <string>
> 
29c32
< const Value Tempo = Value(17); // Must be visible to search
---
> const Value Tempo = Value(20); // Must be visible to search
31,32d33
< void init();
< Value evaluate(const Position& pos);
34a36,37
> template<bool DoTrace = false>
> Value evaluate(const Position& pos);
****************************************************************
endgame
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
24d24
< #include "bitcount.h"
42c42
<     100, 90, 80, 70, 70, 80, 90, 100,
---
>     100, 90, 80, 70, 70, 80, 90, 100
61a62,64
>   // Pawn Rank based scaling factors used in KRPPKRP endgame
>   const int KRPPKRPScaleFactors[RANK_NB] = { 0, 9, 10, 14, 21, 44, 0, 0 };
> 
74c77
<     if (file_of(pos.list<PAWN>(strongSide)[0]) >= FILE_E)
---
>     if (file_of(pos.square<PAWN>(strongSide)) >= FILE_E)
83,104d85
<   // Get the material key of Position out of the given endgame key code
<   // like "KBPKN". The trick here is to first forge an ad-hoc FEN string
<   // and then let a Position object do the work for us.
<   Key key(const string& code, Color c) {
< 
<     assert(code.length() > 0 && code.length() < 8);
<     assert(code[0] == 'K');
< 
<     string sides[] = { code.substr(code.find('K', 1)),      // Weak
<                        code.substr(0, code.find('K', 1)) }; // Strong
< 
<     std::transform(sides[c].begin(), sides[c].end(), sides[c].begin(), tolower);
< 
<     string fen =  sides[0] + char(8 - sides[0].length() + '0') + "/8/8/8/8/8/8/"
<                 + sides[1] + char(8 - sides[1].length() + '0') + " w - - 0 10";
< 
<     return Position(fen, false, NULL).material_key();
<   }
< 
<   template<typename M>
<   void delete_endgame(const typename M::value_type& p) { delete p.second; }
< 
131d111
< Endgames::~Endgames() {
133,137c113
<   for_each(m1.begin(), m1.end(), delete_endgame<M1>);
<   for_each(m2.begin(), m2.end(), delete_endgame<M2>);
< }
< 
< template<EndgameType E>
---
> template<EndgameType E, typename T>
139,141c115,117
< 
<   map((Endgame<E>*)0)[key(code, WHITE)] = new Endgame<E>(WHITE);
<   map((Endgame<E>*)0)[key(code, BLACK)] = new Endgame<E>(BLACK);
---
>   StateInfo st;
>   map<T>()[Position().set(code, WHITE, &st).material_key()] = std::unique_ptr<EndgameBase<T>>(new Endgame<E>(WHITE));
>   map<T>()[Position().set(code, BLACK, &st).material_key()] = std::unique_ptr<EndgameBase<T>>(new Endgame<E>(BLACK));
159,160c135,136
<   Square winnerKSq = pos.king_square(strongSide);
<   Square loserKSq = pos.king_square(weakSide);
---
>   Square winnerKSq = pos.square<KING>(strongSide);
>   Square loserKSq = pos.square<KING>(weakSide);
170,171c146,148
<       || pos.bishop_pair(strongSide))
<       result += VALUE_KNOWN_WIN;
---
>       ||(pos.count<BISHOP>(strongSide) > 1 && opposite_colors(pos.squares<BISHOP>(strongSide)[0],
>                                                               pos.squares<BISHOP>(strongSide)[1])))
>       result = std::min(result + VALUE_KNOWN_WIN, VALUE_MATE_IN_MAX_PLY - 1);
185,187c162,164
<   Square winnerKSq = pos.king_square(strongSide);
<   Square loserKSq = pos.king_square(weakSide);
<   Square bishopSq = pos.list<BISHOP>(strongSide)[0];
---
>   Square winnerKSq = pos.square<KING>(strongSide);
>   Square loserKSq = pos.square<KING>(weakSide);
>   Square bishopSq = pos.square<BISHOP>(strongSide);
214,216c191,193
<   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
<   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
<   Square psq  = normalize(pos, strongSide, pos.list<PAWN>(strongSide)[0]);
---
>   Square wksq = normalize(pos, strongSide, pos.square<KING>(strongSide));
>   Square bksq = normalize(pos, strongSide, pos.square<KING>(weakSide));
>   Square psq  = normalize(pos, strongSide, pos.square<PAWN>(strongSide));
220c197
<   if (!Bitbases::probe_kpk(wksq, psq, bksq, us))
---
>   if (!Bitbases::probe(wksq, psq, bksq, us))
239,242c216,219
<   Square wksq = relative_square(strongSide, pos.king_square(strongSide));
<   Square bksq = relative_square(strongSide, pos.king_square(weakSide));
<   Square rsq  = relative_square(strongSide, pos.list<ROOK>(strongSide)[0]);
<   Square psq  = relative_square(strongSide, pos.list<PAWN>(weakSide)[0]);
---
>   Square wksq = relative_square(strongSide, pos.square<KING>(strongSide));
>   Square bksq = relative_square(strongSide, pos.square<KING>(weakSide));
>   Square rsq  = relative_square(strongSide, pos.square<ROOK>(strongSide));
>   Square psq  = relative_square(strongSide, pos.square<PAWN>(weakSide));
266,267c243,244
<       result =  Value(200) - 8 * (  distance(wksq, psq + DELTA_S)
<                                   - distance(bksq, psq + DELTA_S)
---
>       result =  Value(200) - 8 * (  distance(wksq, psq + SOUTH)
>                                   - distance(bksq, psq + SOUTH)
282c259
<   Value result = Value(PushToEdges[pos.king_square(weakSide)]);
---
>   Value result = Value(PushToEdges[pos.square<KING>(weakSide)]);
295,296c272,273
<   Square bksq = pos.king_square(weakSide);
<   Square bnsq = pos.list<KNIGHT>(weakSide)[0];
---
>   Square bksq = pos.square<KING>(weakSide);
>   Square bnsq = pos.square<KNIGHT>(weakSide);
312,314c289,291
<   Square winnerKSq = pos.king_square(strongSide);
<   Square loserKSq = pos.king_square(weakSide);
<   Square pawnSq = pos.list<PAWN>(weakSide)[0];
---
>   Square winnerKSq = pos.square<KING>(strongSide);
>   Square loserKSq = pos.square<KING>(weakSide);
>   Square pawnSq = pos.square<PAWN>(weakSide);
337,338c314,315
<   Square winnerKSq = pos.king_square(strongSide);
<   Square loserKSq = pos.king_square(weakSide);
---
>   Square winnerKSq = pos.square<KING>(strongSide);
>   Square loserKSq = pos.square<KING>(weakSide);
367c344
<   File pawnFile = file_of(pos.list<PAWN>(strongSide)[0]);
---
>   File pawnsFile = file_of(lsb(pawns));
369,371c346,348
<   // All pawns are on a single rook file ?
<   if (    (pawnFile == FILE_A || pawnFile == FILE_H)
<       && !(pawns & ~file_bb(pawnFile)))
---
>   // All pawns are on a single rook file?
>   if (    (pawnsFile == FILE_A || pawnsFile == FILE_H)
>       && !(pawns & ~file_bb(pawnsFile)))
373,375c350,352
<       Square bishopSq = pos.list<BISHOP>(strongSide)[0];
<       Square queeningSq = relative_square(strongSide, make_square(pawnFile, RANK_8));
<       Square kingSq = pos.king_square(weakSide);
---
>       Square bishopSq = pos.square<BISHOP>(strongSide);
>       Square queeningSq = relative_square(strongSide, make_square(pawnsFile, RANK_8));
>       Square kingSq = pos.square<KING>(weakSide);
383,384c360,361
<   if (    (pawnFile == FILE_B || pawnFile == FILE_G)
<       && !(pos.pieces(PAWN) & ~file_bb(pawnFile))
---
>   if (    (pawnsFile == FILE_B || pawnsFile == FILE_G)
>       && !(pos.pieces(PAWN) & ~file_bb(pawnsFile))
391,393c368,370
<       Square strongKingSq = pos.king_square(strongSide);
<       Square weakKingSq = pos.king_square(weakSide);
<       Square bishopSq = pos.list<BISHOP>(strongSide)[0];
---
>       Square strongKingSq = pos.square<KING>(strongSide);
>       Square weakKingSq = pos.square<KING>(weakSide);
>       Square bishopSq = pos.square<BISHOP>(strongSide);
430,431c407,408
<   Square kingSq = pos.king_square(weakSide);
<   Square rsq = pos.list<ROOK>(weakSide)[0];
---
>   Square kingSq = pos.square<KING>(weakSide);
>   Square rsq = pos.square<ROOK>(weakSide);
434c411
<       &&  relative_rank(weakSide, pos.king_square(strongSide)) >= RANK_4
---
>       &&  relative_rank(weakSide, pos.square<KING>(strongSide)) >= RANK_4
458,462c435,439
<   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
<   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
<   Square wrsq = normalize(pos, strongSide, pos.list<ROOK>(strongSide)[0]);
<   Square wpsq = normalize(pos, strongSide, pos.list<PAWN>(strongSide)[0]);
<   Square brsq = normalize(pos, strongSide, pos.list<ROOK>(weakSide)[0]);
---
>   Square wksq = normalize(pos, strongSide, pos.square<KING>(strongSide));
>   Square bksq = normalize(pos, strongSide, pos.square<KING>(weakSide));
>   Square wrsq = normalize(pos, strongSide, pos.square<ROOK>(strongSide));
>   Square wpsq = normalize(pos, strongSide, pos.square<PAWN>(strongSide));
>   Square brsq = normalize(pos, strongSide, pos.square<ROOK>(weakSide));
482c459
<       && (rank_of(brsq) == RANK_1 || (!tempo && distance(file_of(brsq), f) >= 3)))
---
>       && (rank_of(brsq) == RANK_1 || (!tempo && distance<File>(brsq, wpsq) >= 3)))
503c480
<       && bksq == wpsq + DELTA_N
---
>       && bksq == wpsq + NORTH
524c501
<       && (distance(wksq, wpsq + DELTA_N) < distance(bksq, wpsq + DELTA_N) - 2 + tempo)
---
>       && (distance(wksq, wpsq + NORTH) < distance(bksq, wpsq + NORTH) - 2 + tempo)
527c504
<               && (distance(wksq, wpsq + DELTA_N) < distance(bksq, wrsq) + tempo))))
---
>               && (distance(wksq, wpsq + NORTH) < distance(bksq, wrsq) + tempo))))
554,556c531,533
<       Square ksq = pos.king_square(weakSide);
<       Square bsq = pos.list<BISHOP>(weakSide)[0];
<       Square psq = pos.list<PAWN>(strongSide)[0];
---
>       Square ksq = pos.square<KING>(weakSide);
>       Square bsq = pos.square<BISHOP>(weakSide);
>       Square psq = pos.square<PAWN>(strongSide);
569c546
<           if (d <= 2 && !(d == 0 && ksq == pos.king_square(strongSide) + 2 * push))
---
>           if (d <= 2 && !(d == 0 && ksq == pos.square<KING>(strongSide) + 2 * push))
597,599c574,576
<   Square wpsq1 = pos.list<PAWN>(strongSide)[0];
<   Square wpsq2 = pos.list<PAWN>(strongSide)[1];
<   Square bksq = pos.king_square(weakSide);
---
>   Square wpsq1 = pos.squares<PAWN>(strongSide)[0];
>   Square wpsq2 = pos.squares<PAWN>(strongSide)[1];
>   Square bksq = pos.square<KING>(weakSide);
611,618c588,589
<       switch (r) {
<       case RANK_2: return ScaleFactor(10);
<       case RANK_3: return ScaleFactor(10);
<       case RANK_4: return ScaleFactor(15);
<       case RANK_5: return ScaleFactor(20);
<       case RANK_6: return ScaleFactor(40);
<       default: assert(false);
<       }
---
>       assert(r > RANK_1 && r < RANK_7);
>       return ScaleFactor(KRPPKRPScaleFactors[r]);
633c604
<   Square ksq = pos.king_square(weakSide);
---
>   Square ksq = pos.square<KING>(weakSide);
635d605
<   Square psq = pos.list<PAWN>(strongSide)[0];
641c611
<       &&  distance<File>(ksq, psq) <= 1)
---
>       &&  distance<File>(ksq, lsb(pawns)) <= 1)
658,661c628,631
<   Square pawnSq = pos.list<PAWN>(strongSide)[0];
<   Square strongBishopSq = pos.list<BISHOP>(strongSide)[0];
<   Square weakBishopSq = pos.list<BISHOP>(weakSide)[0];
<   Square weakKingSq = pos.king_square(weakSide);
---
>   Square pawnSq = pos.square<PAWN>(strongSide);
>   Square strongBishopSq = pos.square<BISHOP>(strongSide);
>   Square weakBishopSq = pos.square<BISHOP>(weakSide);
>   Square weakKingSq = pos.square<KING>(weakSide);
685,687c655,656
<       else
<       {
<           Bitboard path = forward_bb(strongSide, pawnSq);
---
>       
>       Bitboard path = forward_bb(strongSide, pawnSq);
689,690c658,659
<           if (path & pos.pieces(weakSide, KING))
<               return SCALE_FACTOR_DRAW;
---
>       if (path & pos.pieces(weakSide, KING))
>           return SCALE_FACTOR_DRAW;
692,695c661,663
<           if (  (pos.attacks_from<BISHOP>(weakBishopSq) & path)
<               && distance(weakBishopSq, pawnSq) >= 3)
<               return SCALE_FACTOR_DRAW;
<       }
---
>       if (  (pos.attacks_from<BISHOP>(weakBishopSq) & path)
>           && distance(weakBishopSq, pawnSq) >= 3)
>           return SCALE_FACTOR_DRAW;
708,709c676,677
<   Square wbsq = pos.list<BISHOP>(strongSide)[0];
<   Square bbsq = pos.list<BISHOP>(weakSide)[0];
---
>   Square wbsq = pos.square<BISHOP>(strongSide);
>   Square bbsq = pos.square<BISHOP>(weakSide);
714,716c682,684
<   Square ksq = pos.king_square(weakSide);
<   Square psq1 = pos.list<PAWN>(strongSide)[0];
<   Square psq2 = pos.list<PAWN>(strongSide)[1];
---
>   Square ksq = pos.square<KING>(weakSide);
>   Square psq1 = pos.squares<PAWN>(strongSide)[0];
>   Square psq2 = pos.squares<PAWN>(strongSide)[1];
779,781c747,749
<   Square pawnSq = pos.list<PAWN>(strongSide)[0];
<   Square strongBishopSq = pos.list<BISHOP>(strongSide)[0];
<   Square weakKingSq = pos.king_square(weakSide);
---
>   Square pawnSq = pos.square<PAWN>(strongSide);
>   Square strongBishopSq = pos.square<BISHOP>(strongSide);
>   Square weakKingSq = pos.square<KING>(weakSide);
802,803c770,771
<   Square pawnSq     = normalize(pos, strongSide, pos.list<PAWN>(strongSide)[0]);
<   Square weakKingSq = normalize(pos, strongSide, pos.king_square(weakSide));
---
>   Square pawnSq     = normalize(pos, strongSide, pos.square<PAWN>(strongSide));
>   Square weakKingSq = normalize(pos, strongSide, pos.square<KING>(weakSide));
817,819c785,787
<   Square pawnSq = pos.list<PAWN>(strongSide)[0];
<   Square bishopSq = pos.list<BISHOP>(weakSide)[0];
<   Square weakKingSq = pos.king_square(weakSide);
---
>   Square pawnSq = pos.square<PAWN>(strongSide);
>   Square bishopSq = pos.square<BISHOP>(weakSide);
>   Square weakKingSq = pos.square<KING>(weakSide);
842,844c810,812
<   Square wksq = normalize(pos, strongSide, pos.king_square(strongSide));
<   Square bksq = normalize(pos, strongSide, pos.king_square(weakSide));
<   Square psq  = normalize(pos, strongSide, pos.list<PAWN>(strongSide)[0]);
---
>   Square wksq = normalize(pos, strongSide, pos.square<KING>(strongSide));
>   Square bksq = normalize(pos, strongSide, pos.square<KING>(weakSide));
>   Square psq  = normalize(pos, strongSide, pos.square<PAWN>(strongSide));
855c823
<   return Bitbases::probe_kpk(wksq, psq, bksq, us) ? SCALE_FACTOR_NONE : SCALE_FACTOR_DRAW;
---
>   return Bitbases::probe(wksq, psq, bksq, us) ? SCALE_FACTOR_NONE : SCALE_FACTOR_DRAW;
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
23a25
> #include <memory>
24a27,28
> #include <type_traits>
> #include <utility>
48c52
<   SCALE_FUNS,
---
>   SCALING_FUNCTIONS,
66,70c70,72
< /// Value or a ScaleFactor. Type eg_fun<int>::type returns either ScaleFactor
< /// or Value depending on whether the template parameter is 0 or 1.
< 
< template<int> struct eg_fun { typedef Value type; };
< template<> struct eg_fun<1> { typedef ScaleFactor type; };
---
> /// Value or a ScaleFactor.
> template<EndgameType E> using
> eg_type = typename std::conditional<(E < SCALING_FUNCTIONS), Value, ScaleFactor>::type;
78,79c80,81
<   virtual ~EndgameBase() {}
<   virtual Color color() const = 0;
---
>   virtual ~EndgameBase() = default;
>   virtual Color strong_side() const = 0;
84c86
< template<EndgameType E, typename T = typename eg_fun<(E > SCALE_FUNS)>::type>
---
> template<EndgameType E, typename T = eg_type<E>>
88c90
<   Color color() const { return strongSide; }
---
>   Color strong_side() const { return strongSide; }
92c94
<   const Color strongSide, weakSide;
---
>   Color strongSide, weakSide;
97,98c99,100
< /// base objects in two std::map typedefs. We then use polymorphism to invoke
< /// the actual endgame function by calling its virtual operator().
---
> /// base objects in two std::map. We use polymorphism to invoke the actual
> /// endgame function by calling its virtual operator().
102,103c104
<   typedef std::map<Key, EndgameBase<eg_fun<0>::type>*> M1;
<   typedef std::map<Key, EndgameBase<eg_fun<1>::type>*> M2;
---
>   template<typename T> using Map = std::map<Key, std::unique_ptr<EndgameBase<T>>>;
105,106c106,107
<   M1 m1;
<   M2 m2;
---
>   template<EndgameType E, typename T = eg_type<E>>
>   void add(const std::string& code);
108,109c109,112
<   M1& map(M1::mapped_type) { return m1; }
<   M2& map(M2::mapped_type) { return m2; }
---
>   template<typename T>
>   Map<T>& map() {
>     return std::get<std::is_same<T, ScaleFactor>::value>(maps);
>   }
111c114
<   template<EndgameType E> void add(const std::string& code);
---
>   std::pair<Map<Value>, Map<ScaleFactor>> maps;
115d117
<  ~Endgames();
117,118c119,122
<   template<typename T> T probe(Key key, T& eg)
<   { return eg = map(eg).count(key) ? map(eg)[key] : NULL; }
---
>   template<typename T>
>   EndgameBase<T>* probe(Key key) {
>     return map<T>().count(key) ? map<T>()[key].get() : nullptr;
>   }
****************************************************************
bitboard
****************************************************************
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
21d21
< #include <cstring> // For memset
24d23
< #include "bitcount.h"
27,28c26,30
< Bitboard RookMasks[SQUARE_NB];
< Bitboard RookMagics[SQUARE_NB];
---
> uint8_t PopCnt16[1 << 16];
> int SquareDistance[SQUARE_NB][SQUARE_NB];
> 
> Bitboard  RookMasks  [SQUARE_NB];
> Bitboard  RookMagics [SQUARE_NB];
30c32
< unsigned RookShifts[SQUARE_NB];
---
> unsigned  RookShifts [SQUARE_NB];
32,33c34,35
< Bitboard BishopMasks[SQUARE_NB];
< Bitboard BishopMagics[SQUARE_NB];
---
> Bitboard  BishopMasks  [SQUARE_NB];
> Bitboard  BishopMagics [SQUARE_NB];
35c37
< unsigned BishopShifts[SQUARE_NB];
---
> unsigned  BishopShifts [SQUARE_NB];
45c47
< Bitboard DistanceRingsBB[SQUARE_NB][8];
---
> Bitboard DistanceRingBB[SQUARE_NB][8];
51,52d52
< int SquareDistance[SQUARE_NB][SQUARE_NB];
< 
56,57c56,57
<   const uint64_t DeBruijn_64 = 0x3F79D71B4CB0A89ULL;
<   const uint32_t DeBruijn_32 = 0x783A9B23;
---
>   const uint64_t DeBruijn64 = 0x3F79D71B4CB0A89ULL;
>   const uint32_t DeBruijn32 = 0x783A9B23;
59,62c59,62
<   int MS1BTable[256];
<   Square BSFTable[SQUARE_NB];
<   Bitboard RookTable[0x19000];  // Storage space for rook attacks
<   Bitboard BishopTable[0x1480]; // Storage space for bishop attacks
---
>   int MSBTable[256];            // To implement software msb()
>   Square BSFTable[SQUARE_NB];   // To implement software bitscan
>   Bitboard RookTable[0x19000];  // To store rook attacks
>   Bitboard BishopTable[0x1480]; // To store bishop attacks
69c69,70
<   FORCE_INLINE unsigned bsf_index(Bitboard b) {
---
>   // bsf_index() returns the index into BSFTable[] to look up the bitscan. Uses
>   // Matt Taylor's folding for 32 bit case, extended to 64 bit by Kim Walisch.
71,74c72,75
<     // Matt Taylor's folding for 32 bit systems, extended to 64 bits by Kim Walisch
<     b ^= (b - 1);
<     return Is64Bit ? (b * DeBruijn_64) >> 58
<                    : ((unsigned(b) ^ unsigned(b >> 32)) * DeBruijn_32) >> 26;
---
>   unsigned bsf_index(Bitboard b) {
>     b ^= b - 1;
>     return Is64Bit ? (b * DeBruijn64) >> 58
>                    : ((unsigned(b) ^ unsigned(b >> 32)) * DeBruijn32) >> 26;
76d76
< }
78,79d77
< /// lsb()/msb() finds the least/most significant bit in a non-zero bitboard.
< /// pop_lsb() finds and clears the least significant bit in a non-zero bitboard.
81c79
< #ifndef USE_BSFQ
---
>   // popcount16() counts the non-zero bits using SWAR-Popcount algorithm
83c81,87
< Square lsb(Bitboard b) { return BSFTable[bsf_index(b)]; }
---
>   unsigned popcount16(unsigned u) {
>     u -= (u >> 1) & 0x5555U;
>     u = ((u >> 2) & 0x3333U) + (u & 0x3333U);
>     u = ((u >> 4) + u) & 0x0F0FU;
>     return (u * 0x0101U) >> 8;
>   }
> }
85c89
< Square pop_lsb(Bitboard* b) {
---
> #ifdef NO_BSF
87,89c91,95
<   Bitboard bb = *b;
<   *b = bb & (bb - 1);
<   return BSFTable[bsf_index(bb)];
---
> /// Software fall-back of lsb() and msb() for CPU lacking hardware support
> 
> Square lsb(Bitboard b) {
>   assert(b);
>   return BSFTable[bsf_index(b)];
93a100
>   assert(b);
117c124
<   return Square(result + MS1BTable[b32]);
---
>   return Square(result + MSBTable[b32]);
120c127
< #endif // ifndef USE_BSFQ
---
> #endif // ifdef NO_BSF
123,124c130,131
< /// Bitboards::pretty() returns an ASCII representation of a bitboard to be
< /// printed to standard output. This is sometimes useful for debugging.
---
> /// Bitboards::pretty() returns an ASCII representation of a bitboard suitable
> /// to be printed to standard output. Useful for debugging.
133c140
<           s.append(b & make_square(f, r) ? "| X " : "|   ");
---
>           s += b & make_square(f, r) ? "| X " : "|   ";
135c142
<       s.append("|\n+---+---+---+---+---+---+---+---+\n");
---
>       s += "|\n+---+---+---+---+---+---+---+---+\n";
146a154,156
>   for (unsigned i = 0; i < (1 << 16); ++i)
>       PopCnt16[i] = (uint8_t) popcount16(i);
> 
153,154c163,164
<   for (Bitboard b = 1; b < 256; ++b)
<       MS1BTable[b] = more_than_one(b) ? MS1BTable[b - 1] : lsb(b);
---
>   for (Bitboard b = 2; b < 256; ++b)
>       MSBTable[b] = MSBTable[b - 1] + !more_than_one(b);
181c191
<               DistanceRingsBB[s1][SquareDistance[s1][s2] - 1] |= s2;
---
>               DistanceRingBB[s1][SquareDistance[s1][s2] - 1] |= s2;
198,199c208,209
<   Square RookDeltas[] = { DELTA_N,  DELTA_E,  DELTA_S,  DELTA_W  };
<   Square BishopDeltas[] = { DELTA_NE, DELTA_SE, DELTA_SW, DELTA_NW };
---
>   Square RookDeltas[] = { NORTH,  EAST,  SOUTH,  WEST  };
>   Square BishopDeltas[] = { NORTH_EAST, SOUTH_EAST, SOUTH_WEST, NORTH_WEST };
209,215c219,223
<       for (Square s2 = SQ_A1; s2 <= SQ_H8; ++s2)
<       {
<           Piece pc = (PseudoAttacks[BISHOP][s1] & s2) ? W_BISHOP :
<                      (PseudoAttacks[ROOK][s1]   & s2) ? W_ROOK   : NO_PIECE;
< 
<           if (pc == NO_PIECE)
<               continue;
---
>       for (Piece pc = W_BISHOP; pc <= W_ROOK; ++pc)
>           for (Square s2 = SQ_A1; s2 <= SQ_H8; ++s2)
>           {
>               if (!(PseudoAttacks[pc][s1] & s2))
>                   continue;
217,219c225,227
<           LineBB[s1][s2] = (attacks_bb(pc, s1, 0) & attacks_bb(pc, s2, 0)) | s1 | s2;
<           BetweenBB[s1][s2] = attacks_bb(pc, s1, SquareBB[s2]) & attacks_bb(pc, s2, SquareBB[s1]);
<       }
---
>               LineBB[s1][s2] = (attacks_bb(pc, s1, 0) & attacks_bb(pc, s2, 0)) | s1 | s2;
>               BetweenBB[s1][s2] = attacks_bb(pc, s1, SquareBB[s2]) & attacks_bb(pc, s2, SquareBB[s1]);
>           }
257c265
<     int i, size;
---
>     int age[4096] = {0}, current = 0, i, size;
273c281
<         shifts[s] = (Is64Bit ? 64 : 32) - popcount<Max15>(masks[s]);
---
>         shifts[s] = (Is64Bit ? 64 : 32) - popcount(masks[s]);
283c291
<                 attacks[s][_pext_u64(b, masks[s])] = reference[size];
---
>                 attacks[s][pext(b, masks[s])] = reference[size];
304,306c312
<             while (popcount<Max15>((magics[s] * masks[s]) >> 56) < 6);
< 
<             std::memset(attacks[s], 0, size * sizeof(Bitboard));
---
>             while (popcount((magics[s] * masks[s]) >> 56) < 6);
312c318
<             for (i = 0; i < size; ++i)
---
>             for (++current, i = 0; i < size; ++i)
314c320
<                 Bitboard& attack = attacks[s][index(s, occupancy[i])];
---
>                 unsigned idx = index(s, occupancy[i]);
316c322,327
<                 if (attack && attack != reference[i])
---
>                 if (age[idx] < current)
>                 {
>                     age[idx] = current;
>                     attacks[s][idx] = reference[i];
>                 }
>                 else if (attacks[s][idx] != reference[i])
318,321d328
< 
<                 assert(reference[i]);
< 
<                 attack = reference[i];
4c4,5
<   Copyright (C) 2008-2014 Marco Costalba, Joona Kiiski, Tord Romstad
---
>   Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
>   Copyright (C) 2015-2017 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
11d11
< 
28c28
< namespace Bitboards {
---
> namespace Bitbases {
31c31
< const std::string pretty(Bitboard b);
---
> bool probe(Square wksq, Square wpsq, Square bksq, Color us);
35c35
< namespace Bitbases {
---
> namespace Bitboards {
37,38c37,38
< void init_kpk();
< bool probe_kpk(Square wksq, Square wpsq, Square bksq, Color us);
---
> void init();
> const std::string pretty(Bitboard b);
41a42,43
> const Bitboard DarkSquares = 0xAA55AA55AA55AA55ULL;
> 
60,68c62
< extern Bitboard RookMasks[SQUARE_NB];
< extern Bitboard RookMagics[SQUARE_NB];
< extern Bitboard* RookAttacks[SQUARE_NB];
< extern unsigned RookShifts[SQUARE_NB];
< 
< extern Bitboard BishopMasks[SQUARE_NB];
< extern Bitboard BishopMagics[SQUARE_NB];
< extern Bitboard* BishopAttacks[SQUARE_NB];
< extern unsigned BishopShifts[SQUARE_NB];
---
> extern int SquareDistance[SQUARE_NB][SQUARE_NB];
78c72
< extern Bitboard DistanceRingsBB[SQUARE_NB][8];
---
> extern Bitboard DistanceRingBB[SQUARE_NB][8];
84,86d77
< extern int SquareDistance[SQUARE_NB][SQUARE_NB];
< 
< const Bitboard DarkSquares = 0xAA55AA55AA55AA55ULL;
95,102d85
< inline Bitboard& operator|=(Bitboard& b, Square s) {
<   return b |= SquareBB[s];
< }
< 
< inline Bitboard& operator^=(Bitboard& b, Square s) {
<   return b ^= SquareBB[s];
< }
< 
111,112c94,95
< inline bool more_than_one(Bitboard b) {
<   return b & (b - 1);
---
> inline Bitboard& operator|=(Bitboard& b, Square s) {
>   return b |= SquareBB[s];
115,126c98,100
< template<typename T> inline int distance(T x, T y) { return x < y ? y - x : x - y; }
< template<> inline int distance<Square>(Square x, Square y) { return SquareDistance[x][y]; }
< 
< template<typename T1, typename T2> inline int distance(T2 x, T2 y);
< template<> inline int distance<File>(Square x, Square y) { return distance(file_of(x), file_of(y)); }
< template<> inline int distance<Rank>(Square x, Square y) { return distance(rank_of(x), rank_of(y)); }
< 
< 
< /// shift_bb() moves bitboard one step along direction Delta. Mainly for pawns.
< 
< template<Square Delta>
< inline Bitboard shift_bb(Bitboard b) {
---
> inline Bitboard& operator^=(Bitboard& b, Square s) {
>   return b ^= SquareBB[s];
> }
128,131c102,103
<   return  Delta == DELTA_N  ?  b             << 8 : Delta == DELTA_S  ?  b             >> 8
<         : Delta == DELTA_NE ? (b & ~FileHBB) << 9 : Delta == DELTA_SE ? (b & ~FileHBB) >> 7
<         : Delta == DELTA_NW ? (b & ~FileABB) << 7 : Delta == DELTA_SW ? (b & ~FileABB) >> 9
<         : 0;
---
> inline bool more_than_one(Bitboard b) {
>   return b & (b - 1);
135,136c107,108
< /// rank_bb() and file_bb() take a file or a square as input and return
< /// a bitboard representing all squares on the given file or rank.
---
> /// rank_bb() and file_bb() return a bitboard representing all the squares on
> /// the given file or rank.
155,156c127
< /// adjacent_files_bb() takes a file as input and returns a bitboard representing
< /// all squares on the adjacent files.
---
> /// shift() moves a bitboard one step along direction D. Mainly for pawns
158,159c129,134
< inline Bitboard adjacent_files_bb(File f) {
<   return AdjacentFilesBB[f];
---
> template<Square D>
> inline Bitboard shift(Bitboard b) {
>   return  D == NORTH      ?  b             << 8 : D == SOUTH      ?  b             >> 8
>         : D == NORTH_EAST ? (b & ~FileHBB) << 9 : D == SOUTH_EAST ? (b & ~FileHBB) >> 7
>         : D == NORTH_WEST ? (b & ~FileABB) << 7 : D == SOUTH_WEST ? (b & ~FileABB) >> 9
>         : 0;
163,166c138,139
< /// in_front_bb() takes a color and a rank as input, and returns a bitboard
< /// representing all the squares on all ranks in front of the rank, from the
< /// given color's point of view. For instance, in_front_bb(BLACK, RANK_3) will
< /// give all squares on ranks 1 and 2.
---
> /// adjacent_files_bb() returns a bitboard representing all the squares on the
> /// adjacent files of the given one.
168,169c141,142
< inline Bitboard in_front_bb(Color c, Rank r) {
<   return InFrontBB[c][r];
---
> inline Bitboard adjacent_files_bb(File f) {
>   return AdjacentFilesBB[f];
173,176c146,149
< /// between_bb() returns a bitboard representing all squares between two squares.
< /// For instance, between_bb(SQ_C4, SQ_F7) returns a bitboard with the bits for
< /// square d5 and e6 set.  If s1 and s2 are not on the same rank, file or diagonal,
< /// 0 is returned.
---
> /// between_bb() returns a bitboard representing all the squares between the two
> /// given ones. For instance, between_bb(SQ_C4, SQ_F7) returns a bitboard with
> /// the bits for square d5 and e6 set. If s1 and s2 are not on the same rank, file
> /// or diagonal, 0 is returned.
183,186c156,167
< /// forward_bb() takes a color and a square as input, and returns a bitboard
< /// representing all squares along the line in front of the square, from the
< /// point of view of the given color. Definition of the table is:
< /// ForwardBB[c][s] = in_front_bb(c, s) & file_bb(s)
---
> /// in_front_bb() returns a bitboard representing all the squares on all the ranks
> /// in front of the given one, from the point of view of the given color. For
> /// instance, in_front_bb(BLACK, RANK_3) will return the squares on ranks 1 and 2.
> 
> inline Bitboard in_front_bb(Color c, Rank r) {
>   return InFrontBB[c][r];
> }
> 
> 
> /// forward_bb() returns a bitboard representing all the squares along the line
> /// in front of the given one, from the point of view of the given color:
> ///        ForwardBB[c][s] = in_front_bb(c, rank_of(s)) & file_bb(s)
193,196c174,177
< /// pawn_attack_span() takes a color and a square as input, and returns a bitboard
< /// representing all squares that can be attacked by a pawn of the given color
< /// when it moves along its file starting from the given square. Definition is:
< /// PawnAttackSpan[c][s] = in_front_bb(c, s) & adjacent_files_bb(s);
---
> /// pawn_attack_span() returns a bitboard representing all the squares that can be
> /// attacked by a pawn of the given color when it moves along its file, starting
> /// from the given square:
> ///       PawnAttackSpan[c][s] = in_front_bb(c, rank_of(s)) & adjacent_files_bb(s);
203,206c184,186
< /// passed_pawn_mask() takes a color and a square as input, and returns a
< /// bitboard mask which can be used to test if a pawn of the given color on
< /// the given square is a passed pawn. Definition of the table is:
< /// PassedPawnMask[c][s] = pawn_attack_span(c, s) | forward_bb(c, s)
---
> /// passed_pawn_mask() returns a bitboard mask which can be used to test if a
> /// pawn of the given color and on the given square is a passed pawn:
> ///       PassedPawnMask[c][s] = pawn_attack_span(c, s) | forward_bb(c, s)
213,214c193,194
< /// squares_of_color() returns a bitboard representing all squares with the same
< /// color of the given square.
---
> /// aligned() returns true if the squares s1, s2 and s3 are aligned either on a
> /// straight or on a diagonal line.
216,217c196,197
< inline Bitboard squares_of_color(Square s) {
<   return DarkSquares & s ? DarkSquares : ~DarkSquares;
---
> inline bool aligned(Square s1, Square s2, Square s3) {
>   return LineBB[s1][s2] & s3;
221,222c201,202
< /// aligned() returns true if the squares s1, s2 and s3 are aligned
< /// either on a straight or on a diagonal line.
---
> /// distance() functions return the distance between x and y, defined as the
> /// number of steps for a king in x to reach y. Works with squares, ranks, files.
224,226c204,209
< inline bool aligned(Square s1, Square s2, Square s3) {
<   return LineBB[s1][s2] & s3;
< }
---
> template<typename T> inline int distance(T x, T y) { return x < y ? y - x : x - y; }
> template<> inline int distance<Square>(Square x, Square y) { return SquareDistance[x][y]; }
> 
> template<typename T1, typename T2> inline int distance(T2 x, T2 y);
> template<> inline int distance<File>(Square x, Square y) { return distance(file_of(x), file_of(y)); }
> template<> inline int distance<Rank>(Square x, Square y) { return distance(rank_of(x), rank_of(y)); }
229,231c212,214
< /// Functions for computing sliding attack bitboards. Function attacks_bb() takes
< /// a square and a bitboard of occupied squares as input, and returns a bitboard
< /// representing all squares attacked by Pt (bishop or rook) on the given square.
---
> /// attacks_bb() returns a bitboard representing all the squares attacked by a
> /// piece of type Pt (bishop or rook) placed on 's'. The helper magic_index()
> /// looks up the index using the 'magic bitboards' approach.
233c216,223
< FORCE_INLINE unsigned magic_index(Square s, Bitboard occupied) {
---
> inline unsigned magic_index(Square s, Bitboard occupied) {
> 
>   extern Bitboard RookMasks[SQUARE_NB];
>   extern Bitboard RookMagics[SQUARE_NB];
>   extern unsigned RookShifts[SQUARE_NB];
>   extern Bitboard BishopMasks[SQUARE_NB];
>   extern Bitboard BishopMagics[SQUARE_NB];
>   extern unsigned BishopShifts[SQUARE_NB];
240c230
<       return unsigned(_pext_u64(occupied, Masks[s]));
---
>       return unsigned(pext(occupied, Masks[s]));
251a242,245
> 
>   extern Bitboard* RookAttacks[SQUARE_NB];
>   extern Bitboard* BishopAttacks[SQUARE_NB];
> 
266,267d259
< /// lsb()/msb() finds the least/most significant bit in a non-zero bitboard.
< /// pop_lsb() finds and clears the least significant bit in a non-zero bitboard.
269c261
< #ifdef USE_BSFQ
---
> /// popcount() counts the number of non-zero bits in a bitboard
271c263
< #  if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
---
> inline int popcount(Bitboard b) {
273,277c265
< FORCE_INLINE Square lsb(Bitboard b) {
<   unsigned long idx;
<   _BitScanForward64(&idx, b);
<   return (Square) idx;
< }
---
> #ifndef USE_POPCNT
279,283c267,273
< FORCE_INLINE Square msb(Bitboard b) {
<   unsigned long idx;
<   _BitScanReverse64(&idx, b);
<   return (Square) idx;
< }
---
>   extern uint8_t PopCnt16[1 << 16];
>   union { Bitboard bb; uint16_t u[4]; } v = { b };
>   return PopCnt16[v.u[0]] + PopCnt16[v.u[1]] + PopCnt16[v.u[2]] + PopCnt16[v.u[3]];
> 
> #elif defined(_MSC_VER) || defined(__INTEL_COMPILER)
> 
>   return (int)_mm_popcnt_u64(b);
285c275
< #  elif defined(__arm__)
---
> #else // Assumed gcc or compatible compiler
287,289c277,279
< FORCE_INLINE int lsb32(uint32_t v) {
<   __asm__("rbit %0, %1" : "=r"(v) : "r"(v));
<   return __builtin_clz(v);
---
>   return __builtin_popcountll(b);
> 
> #endif
292,293c282,289
< FORCE_INLINE Square msb(Bitboard b) {
<   return (Square) (63 - __builtin_clzll(b));
---
> 
> /// lsb() and msb() return the least/most significant bit in a non-zero bitboard
> 
> #if defined(__GNUC__)
> 
> inline Square lsb(Bitboard b) {
>   assert(b);
>   return Square(__builtin_ctzll(b));
296,297c292,294
< FORCE_INLINE Square lsb(Bitboard b) {
<   return (Square) (uint32_t(b) ? lsb32(uint32_t(b)) : 32 + lsb32(uint32_t(b >> 32)));
---
> inline Square msb(Bitboard b) {
>   assert(b);
>   return Square(63 ^ __builtin_clzll(b));
300c297
< #  else
---
> #elif defined(_WIN64) && defined(_MSC_VER)
302,304c299,302
< FORCE_INLINE Square lsb(Bitboard b) { // Assembly code by Heinz van Saanen
<   Bitboard idx;
<   __asm__("bsfq %1, %0": "=r"(idx): "rm"(b) );
---
> inline Square lsb(Bitboard b) {
>   assert(b);
>   unsigned long idx;
>   _BitScanForward64(&idx, b);
308,310c306,309
< FORCE_INLINE Square msb(Bitboard b) {
<   Bitboard idx;
<   __asm__("bsrq %1, %0": "=r"(idx): "rm"(b) );
---
> inline Square msb(Bitboard b) {
>   assert(b);
>   unsigned long idx;
>   _BitScanReverse64(&idx, b);
314c313,323
< #  endif
---
> #else
> 
> #define NO_BSF // Fallback on software implementation for other cases
> 
> Square lsb(Bitboard b);
> Square msb(Bitboard b);
> 
> #endif
> 
> 
> /// pop_lsb() finds and clears the least significant bit in a non-zero bitboard
316c325
< FORCE_INLINE Square pop_lsb(Bitboard* b) {
---
> inline Square pop_lsb(Bitboard* b) {
322,328d330
< #else // if defined(USE_BSFQ)
< 
< extern Square msb(Bitboard b);
< extern Square lsb(Bitboard b);
< extern Square pop_lsb(Bitboard* b);
< 
< #endif
330c332
< /// frontmost_sq() and backmost_sq() find the square corresponding to the
---
> /// frontmost_sq() and backmost_sq() return the square corresponding to the
